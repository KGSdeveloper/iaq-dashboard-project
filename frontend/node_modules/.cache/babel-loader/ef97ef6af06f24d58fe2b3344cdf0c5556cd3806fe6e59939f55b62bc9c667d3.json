{"ast":null,"code":"\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst dgram = require(\"dgram\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst MIN_DATA_LENGTH = 6;\nconst C701_PORT = 0x7002;\n\n/**\n * Check if a buffer chunk can be a Modbus answer or modbus exception.\n *\n * @param {UdpPort} modbus\n * @param {Buffer} buf the buffer to check.\n * @return {boolean} if the buffer can be an answer\n * @private\n */\nfunction _checkData(modbus, buf) {\n  // check buffer size\n  if (buf.length !== modbus._length && buf.length !== 5) return false;\n\n  // calculate crc16\n  const crcIn = buf.readUInt16LE(buf.length - 2);\n\n  // check buffer unit-id, command and crc\n  return buf[0] === modbus._id && (0x7f & buf[1]) === modbus._cmd && crcIn === crc16(buf.slice(0, -2));\n}\nclass UdpPort extends EventEmitter {\n  /**\n   * Simulate a modbus-RTU port using C701 UDP-to-Serial bridge.\n   *\n   * @param ip\n   * @param options\n   * @constructor\n   */\n  constructor(ip, options) {\n    super();\n    const modbus = this;\n    this.ip = ip;\n    this.openFlag = false;\n\n    // options\n    if (typeof options === \"undefined\") options = {};\n    this.port = options.port || C701_PORT; // C701 port\n\n    // create a socket\n    this._client = dgram.createSocket(\"udp4\");\n\n    // wait for answer\n    this._client.on(\"message\", function (data) {\n      let buffer = null;\n\n      // check expected length\n      if (modbus.length < 6) return;\n\n      // check message length\n      if (data.length < 116 + 5) return;\n\n      // check the C701 packet magic\n      if (data.readUInt16LE(2) !== 602) return;\n\n      // check for modbus valid answer\n      // get the serial data from the C701 packet\n      buffer = data.slice(data.length - modbus._length);\n      modbusSerialDebug({\n        action: \"receive c701 upd port\",\n        data: data,\n        buffer: buffer\n      });\n      modbusSerialDebug(JSON.stringify({\n        action: \"receive c701 upd port strings\",\n        data: data,\n        buffer: buffer\n      }));\n\n      // check the serial data\n      if (_checkData(modbus, buffer)) {\n        modbusSerialDebug({\n          action: \"emit data serial rtu buffered port\",\n          buffer: buffer\n        });\n        modbusSerialDebug(JSON.stringify({\n          action: \"emit data serial rtu buffered port strings\",\n          buffer: buffer\n        }));\n        modbus.emit(\"data\", buffer);\n      } else {\n        // check for modbus exception\n        // get the serial data from the C701 packet\n        buffer = data.slice(data.length - 5);\n\n        // check the serial data\n        if (_checkData(modbus, buffer)) {\n          modbusSerialDebug({\n            action: \"emit data serial rtu buffered port\",\n            buffer: buffer\n          });\n          modbusSerialDebug(JSON.stringify({\n            action: \"emit data serial rtu buffered port strings\",\n            buffer: buffer\n          }));\n          modbus.emit(\"data\", buffer);\n        }\n      }\n    });\n    this._client.on(\"listening\", function () {\n      modbus.openFlag = true;\n    });\n    this._client.on(\"close\", function () {\n      modbus.openFlag = false;\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this.openFlag;\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  // eslint-disable-next-line class-methods-use-this\n  open(callback) {\n    if (callback) callback(null);\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    this._client.close();\n    if (callback) callback(null);\n  }\n\n  /**\n   * Send data to a modbus-tcp slave.\n   *\n   * @param data\n   */\n  write(data) {\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n    let length = null;\n\n    // remember current unit and command\n    this._id = data[0];\n    this._cmd = data[1];\n\n    // calculate expected answer length\n    switch (this._cmd) {\n      case 1:\n      case 2:\n        length = data.readUInt16BE(4);\n        this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n        break;\n      case 3:\n      case 4:\n        length = data.readUInt16BE(4);\n        this._length = 3 + 2 * length + 2;\n        break;\n      case 5:\n      case 6:\n      case 15:\n      case 16:\n        this._length = 6 + 2;\n        break;\n      default:\n        // raise and error ?\n        this._length = 0;\n        break;\n    }\n\n    // build C701 header\n    const buffer = Buffer.alloc(data.length + 116);\n    buffer.fill(0);\n    buffer.writeUInt16LE(600, 2); // C701 magic for serial bridge\n    buffer.writeUInt16LE(0, 36); // C701 RS485 connector (0..2)\n    buffer.writeUInt16LE(this._length, 38); // expected serial answer length\n    buffer.writeUInt16LE(1, 102); // C7011 RS481 hub (1..2)\n    buffer.writeUInt16LE(data.length, 104); // serial data length\n\n    // add serial line data\n    data.copy(buffer, 116);\n\n    // send buffer to C701 UDP to serial bridge\n    this._client.send(buffer, 0, buffer.length, this.port, this.ip);\n    modbusSerialDebug({\n      action: \"send c701 upd port\",\n      data: data,\n      buffer: buffer,\n      unitid: this._id,\n      functionCode: this._cmd\n    });\n    modbusSerialDebug(JSON.stringify({\n      action: \"send c701 upd port strings\",\n      data: data,\n      buffer: buffer,\n      unitid: this._id,\n      functionCode: this._cmd\n    }));\n  }\n}\n\n/**\n * UDP port for Modbus.\n *\n * @type {UdpPort}\n */\nmodule.exports = UdpPort;","map":{"version":3,"names":["events","require","EventEmitter","dgram","modbusSerialDebug","crc16","MIN_DATA_LENGTH","C701_PORT","_checkData","modbus","buf","length","_length","crcIn","readUInt16LE","_id","_cmd","slice","UdpPort","constructor","ip","options","openFlag","port","_client","createSocket","on","data","buffer","action","JSON","stringify","emit","isOpen","open","callback","close","write","readUInt16BE","parseInt","Buffer","alloc","fill","writeUInt16LE","copy","send","unitid","functionCode","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/c701port.js"],"sourcesContent":["\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst dgram = require(\"dgram\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst MIN_DATA_LENGTH = 6;\n\nconst C701_PORT = 0x7002;\n\n/**\n * Check if a buffer chunk can be a Modbus answer or modbus exception.\n *\n * @param {UdpPort} modbus\n * @param {Buffer} buf the buffer to check.\n * @return {boolean} if the buffer can be an answer\n * @private\n */\nfunction _checkData(modbus, buf) {\n    // check buffer size\n    if (buf.length !== modbus._length && buf.length !== 5) return false;\n\n    // calculate crc16\n    const crcIn = buf.readUInt16LE(buf.length - 2);\n\n    // check buffer unit-id, command and crc\n    return (buf[0] === modbus._id &&\n        (0x7f & buf[1]) === modbus._cmd &&\n        crcIn === crc16(buf.slice(0, -2)));\n}\n\nclass UdpPort extends EventEmitter {\n    /**\n     * Simulate a modbus-RTU port using C701 UDP-to-Serial bridge.\n     *\n     * @param ip\n     * @param options\n     * @constructor\n     */\n    constructor(ip, options) {\n        super();\n\n        const modbus = this;\n        this.ip = ip;\n        this.openFlag = false;\n\n        // options\n        if (typeof(options) === \"undefined\") options = {};\n        this.port = options.port || C701_PORT; // C701 port\n\n        // create a socket\n        this._client = dgram.createSocket(\"udp4\");\n\n        // wait for answer\n        this._client.on(\"message\", function(data) {\n            let buffer = null;\n\n            // check expected length\n            if (modbus.length < 6) return;\n\n            // check message length\n            if (data.length < (116 + 5)) return;\n\n            // check the C701 packet magic\n            if (data.readUInt16LE(2) !== 602) return;\n\n            // check for modbus valid answer\n            // get the serial data from the C701 packet\n            buffer = data.slice(data.length - modbus._length);\n\n            modbusSerialDebug({ action: \"receive c701 upd port\", data: data, buffer: buffer });\n            modbusSerialDebug(JSON.stringify({ action: \"receive c701 upd port strings\", data: data, buffer: buffer }));\n\n            // check the serial data\n            if (_checkData(modbus, buffer)) {\n                modbusSerialDebug({ action: \"emit data serial rtu buffered port\", buffer: buffer });\n                modbusSerialDebug(JSON.stringify({ action: \"emit data serial rtu buffered port strings\", buffer: buffer }));\n\n                modbus.emit(\"data\", buffer);\n            } else {\n                // check for modbus exception\n                // get the serial data from the C701 packet\n                buffer = data.slice(data.length - 5);\n\n                // check the serial data\n                if (_checkData(modbus, buffer)) {\n                    modbusSerialDebug({ action: \"emit data serial rtu buffered port\", buffer: buffer });\n                    modbusSerialDebug(JSON.stringify({\n                        action: \"emit data serial rtu buffered port strings\",\n                        buffer: buffer\n                    }));\n\n                    modbus.emit(\"data\", buffer);\n                }\n            }\n        });\n\n        this._client.on(\"listening\", function() {\n            modbus.openFlag = true;\n        });\n\n        this._client.on(\"close\", function() {\n            modbus.openFlag = false;\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this.openFlag;\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    // eslint-disable-next-line class-methods-use-this\n    open(callback) {\n        if (callback)\n            callback(null);\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        this._client.close();\n        if (callback)\n            callback(null);\n    }\n\n    /**\n     * Send data to a modbus-tcp slave.\n     *\n     * @param data\n     */\n    write(data) {\n        if(data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n            return;\n        }\n\n        let length = null;\n\n        // remember current unit and command\n        this._id = data[0];\n        this._cmd = data[1];\n\n        // calculate expected answer length\n        switch (this._cmd) {\n            case 1:\n            case 2:\n                length = data.readUInt16BE(4);\n                this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n                break;\n            case 3:\n            case 4:\n                length = data.readUInt16BE(4);\n                this._length = 3 + 2 * length + 2;\n                break;\n            case 5:\n            case 6:\n            case 15:\n            case 16:\n                this._length = 6 + 2;\n                break;\n            default:\n                // raise and error ?\n                this._length = 0;\n                break;\n        }\n\n        // build C701 header\n        const buffer = Buffer.alloc(data.length + 116);\n        buffer.fill(0);\n        buffer.writeUInt16LE(600, 2);           // C701 magic for serial bridge\n        buffer.writeUInt16LE(0, 36);            // C701 RS485 connector (0..2)\n        buffer.writeUInt16LE(this._length, 38); // expected serial answer length\n        buffer.writeUInt16LE(1, 102);           // C7011 RS481 hub (1..2)\n        buffer.writeUInt16LE(data.length, 104); // serial data length\n\n        // add serial line data\n        data.copy(buffer, 116);\n\n        // send buffer to C701 UDP to serial bridge\n        this._client.send(buffer, 0, buffer.length, this.port, this.ip);\n\n        modbusSerialDebug({\n            action: \"send c701 upd port\",\n            data: data,\n            buffer: buffer,\n            unitid: this._id,\n            functionCode: this._cmd\n        });\n\n        modbusSerialDebug(JSON.stringify({\n            action: \"send c701 upd port strings\",\n            data: data,\n            buffer: buffer,\n            unitid: this._id,\n            functionCode: this._cmd\n        }));\n    }\n}\n\n/**\n * UDP port for Modbus.\n *\n * @type {UdpPort}\n */\nmodule.exports = UdpPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}