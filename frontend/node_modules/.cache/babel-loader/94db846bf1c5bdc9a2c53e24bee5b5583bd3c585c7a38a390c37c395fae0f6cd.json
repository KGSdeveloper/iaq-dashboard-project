{"ast":null,"code":"\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst EXCEPTION_LENGTH = 3;\nconst MIN_DATA_LENGTH = 6;\nconst MIN_MBAP_LENGTH = 6;\nconst MAX_TRANSACTIONS = 64; // maximum transaction to wait for\nconst MAX_BUFFER_LENGTH = 256;\nconst CRC_LENGTH = 2;\nconst MODBUS_PORT = 502;\nclass TcpRTUBufferedPort extends EventEmitter {\n  /**\n   * Simulate a modbus-RTU port using TCP connection\n   * @module TcpRTUBufferedPort\n   *\n   * @param {string} ip - ip address\n   * @param {object} options - all options as JSON object\n   *   options.port: Nonstandard Modbus port (default is 502).\n   *   options.localAddress: Local IP address to bind to, default is any.\n   *   options.family: 4 = IPv4-only, 6 = IPv6-only, 0 = either (default).\n   * @constructor\n   */\n  constructor(ip, options) {\n    super();\n    const modbus = this;\n    modbus.openFlag = false;\n    modbus.callback = null;\n    modbus._transactionIdWrite = 1;\n    this._externalSocket = null;\n\n    // options\n    if (typeof ip === \"object\") {\n      options = ip;\n    }\n    if (typeof options === \"undefined\") options = {};\n    modbus.connectOptions = {\n      host: ip || options.ip,\n      port: options.port || MODBUS_PORT,\n      localAddress: options.localAddress,\n      family: options.family || 0\n    };\n    if (options.socket) {\n      if (options.socket instanceof net.Socket) {\n        this._externalSocket = options.socket;\n        this.openFlag = this._externalSocket.readyState === \"opening\" || this._externalSocket.readyState === \"open\";\n      } else {\n        throw new Error(\"invalid socket provided\");\n      }\n    }\n\n    // internal buffer\n    modbus._buffer = Buffer.alloc(0);\n\n    // handle callback - call a callback function only once, for the first event\n    // it will triger\n    const handleCallback = function (had_error) {\n      if (modbus.callback) {\n        modbus.callback(had_error);\n        modbus.callback = null;\n      }\n    };\n\n    // create a socket\n    modbus._client = this._externalSocket || new net.Socket();\n    if (options.timeout) this._client.setTimeout(options.timeout);\n\n    // register the port data event\n    modbus._client.on(\"data\", function onData(data) {\n      // add data to buffer\n      modbus._buffer = Buffer.concat([modbus._buffer, data]);\n      modbusSerialDebug({\n        action: \"receive tcp rtu buffered port\",\n        data: data,\n        buffer: modbus._buffer\n      });\n\n      // check if buffer include a complete modbus answer\n      let bufferLength = modbus._buffer.length;\n\n      // check data length\n      if (bufferLength < MIN_MBAP_LENGTH) return;\n\n      // check buffer size for MAX_BUFFER_SIZE\n      if (bufferLength > MAX_BUFFER_LENGTH) {\n        modbus._buffer = modbus._buffer.slice(-MAX_BUFFER_LENGTH);\n        bufferLength = MAX_BUFFER_LENGTH;\n      }\n\n      // check data length\n      if (bufferLength < MIN_MBAP_LENGTH + EXCEPTION_LENGTH) return;\n\n      // loop and check length-sized buffer chunks\n      const maxOffset = bufferLength - MIN_MBAP_LENGTH;\n      for (let i = 0; i <= maxOffset; i++) {\n        modbus._transactionIdRead = modbus._buffer.readUInt16BE(i);\n        const protocolID = modbus._buffer.readUInt16BE(i + 2);\n        const msgLength = modbus._buffer.readUInt16BE(i + 4);\n        const cmd = modbus._buffer[i + 7];\n        modbusSerialDebug({\n          protocolID: protocolID,\n          msgLength: msgLength,\n          bufferLength: bufferLength,\n          cmd: cmd\n        });\n        if (protocolID === 0 && cmd !== 0 && msgLength >= EXCEPTION_LENGTH && i + MIN_MBAP_LENGTH + msgLength <= bufferLength) {\n          // add crc and emit\n          modbus._emitData(i + MIN_MBAP_LENGTH, msgLength);\n          return;\n        }\n      }\n    });\n    this._client.on(\"connect\", function () {\n      modbus.openFlag = true;\n      handleCallback();\n    });\n    this._client.on(\"close\", function (had_error) {\n      if (modbus.openFlag) {\n        modbus.openFlag = false;\n        modbusSerialDebug(\"TCP buffered port: signal close: \" + had_error);\n        handleCallback(had_error);\n        modbus.emit(\"close\");\n        modbus.removeAllListeners();\n      }\n    });\n    this._client.on(\"error\", function (had_error) {\n      modbus.openFlag = false;\n      handleCallback(had_error);\n    });\n    this._client.on(\"timeout\", function () {\n      // modbus.openFlag is left in its current state as it reflects two types of timeouts,\n      // i.e. 'false' for \"TCP connection timeout\" and 'true' for \"Modbus response timeout\"\n      // (this allows to continue Modbus request re-tries without reconnecting TCP).\n      modbusSerialDebug(\"TcpRTUBufferedPort port: TimedOut\");\n      handleCallback(new Error(\"TcpRTUBufferedPort Connection Timed Out\"));\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this.openFlag;\n  }\n\n  /**\n   * Emit the received response, cut the buffer and reset the internal vars.\n   *\n   * @param {number} start the start index of the response within the buffer\n   * @param {number} length the length of the response\n   * @private\n   */\n  _emitData(start, length) {\n    const modbus = this;\n    const data = modbus._buffer.slice(start, start + length);\n\n    // cut the buffer\n    modbus._buffer = modbus._buffer.slice(start + length);\n    if (data.length > 0) {\n      const buffer = Buffer.alloc(data.length + CRC_LENGTH);\n      data.copy(buffer, 0);\n\n      // add crc\n      const crc = crc16(buffer.slice(0, -CRC_LENGTH));\n      buffer.writeUInt16LE(crc, buffer.length - CRC_LENGTH);\n      modbus.emit(\"data\", buffer);\n\n      // debug\n      modbusSerialDebug({\n        action: \"parsed tcp buffered port\",\n        buffer: buffer,\n        transactionId: modbus._transactionIdRead\n      });\n    } else {\n      modbusSerialDebug({\n        action: \"emit data to short\",\n        data: data\n      });\n    }\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  open(callback) {\n    if (this._externalSocket === null) {\n      this.callback = callback;\n      this._client.connect(this.connectOptions);\n    } else if (this.openFlag) {\n      modbusSerialDebug(\"TcpRTUBuffered port: external socket is opened\");\n      callback(); // go ahead to setup existing socket\n    } else {\n      callback(new Error(\"TcpRTUBuffered port: external socket is not opened\"));\n    }\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    this.callback = callback;\n    // DON'T pass callback to `end()` here, it will be handled by client.on('close') handler\n    this._client.end();\n  }\n\n  /**\n   * Simulate successful destroy port.\n   *\n   * @param callback\n   */\n  destroy(callback) {\n    this.callback = callback;\n    if (!this._client.destroyed) {\n      this._client.destroy();\n    }\n  }\n\n  /**\n   * Send data to a modbus slave via telnet server.\n   *\n   * @param {Buffer} data\n   */\n  write(data) {\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n\n    // remove crc and add mbap\n    const buffer = Buffer.alloc(data.length + MIN_MBAP_LENGTH - CRC_LENGTH);\n    buffer.writeUInt16BE(this._transactionIdWrite, 0);\n    buffer.writeUInt16BE(0, 2);\n    buffer.writeUInt16BE(data.length - CRC_LENGTH, 4);\n    data.copy(buffer, MIN_MBAP_LENGTH);\n    modbusSerialDebug({\n      action: \"send tcp rtu buffered port\",\n      data: data,\n      buffer: buffer,\n      transactionsId: this._transactionIdWrite\n    });\n\n    // get next transaction id\n    this._transactionIdWrite = (this._transactionIdWrite + 1) % MAX_TRANSACTIONS;\n\n    // send buffer to slave\n    this._client.write(buffer);\n  }\n}\n\n/**\n * TCP RTU bufferd port for Modbus.\n *\n * @type {TcpRTUBufferedPort}\n */\nmodule.exports = TcpRTUBufferedPort;","map":{"version":3,"names":["events","require","EventEmitter","net","modbusSerialDebug","crc16","EXCEPTION_LENGTH","MIN_DATA_LENGTH","MIN_MBAP_LENGTH","MAX_TRANSACTIONS","MAX_BUFFER_LENGTH","CRC_LENGTH","MODBUS_PORT","TcpRTUBufferedPort","constructor","ip","options","modbus","openFlag","callback","_transactionIdWrite","_externalSocket","connectOptions","host","port","localAddress","family","socket","Socket","readyState","Error","_buffer","Buffer","alloc","handleCallback","had_error","_client","timeout","setTimeout","on","onData","data","concat","action","buffer","bufferLength","length","slice","maxOffset","i","_transactionIdRead","readUInt16BE","protocolID","msgLength","cmd","_emitData","emit","removeAllListeners","isOpen","start","copy","crc","writeUInt16LE","transactionId","open","connect","close","end","destroy","destroyed","write","writeUInt16BE","transactionsId","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/tcprtubufferedport.js"],"sourcesContent":["\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst EXCEPTION_LENGTH = 3;\nconst MIN_DATA_LENGTH = 6;\nconst MIN_MBAP_LENGTH = 6;\nconst MAX_TRANSACTIONS = 64; // maximum transaction to wait for\nconst MAX_BUFFER_LENGTH = 256;\nconst CRC_LENGTH = 2;\n\nconst MODBUS_PORT = 502;\n\nclass TcpRTUBufferedPort extends EventEmitter {\n    /**\n     * Simulate a modbus-RTU port using TCP connection\n     * @module TcpRTUBufferedPort\n     *\n     * @param {string} ip - ip address\n     * @param {object} options - all options as JSON object\n     *   options.port: Nonstandard Modbus port (default is 502).\n     *   options.localAddress: Local IP address to bind to, default is any.\n     *   options.family: 4 = IPv4-only, 6 = IPv6-only, 0 = either (default).\n     * @constructor\n     */\n    constructor(ip, options) {\n        super();\n\n        const modbus = this;\n        modbus.openFlag = false;\n        modbus.callback = null;\n        modbus._transactionIdWrite = 1;\n        this._externalSocket = null;\n\n        // options\n        if(typeof ip === \"object\") {\n            options = ip;\n        }\n        if (typeof options === \"undefined\") options = {};\n        modbus.connectOptions = {\n            host: ip || options.ip,\n            port: options.port || MODBUS_PORT,\n            localAddress: options.localAddress,\n            family: options.family || 0\n        };\n\n        if(options.socket) {\n            if(options.socket instanceof net.Socket) {\n                this._externalSocket = options.socket;\n                this.openFlag = this._externalSocket.readyState === \"opening\" || this._externalSocket.readyState === \"open\";\n            } else {\n                throw new Error(\"invalid socket provided\");\n            }\n        }\n\n        // internal buffer\n        modbus._buffer = Buffer.alloc(0);\n\n        // handle callback - call a callback function only once, for the first event\n        // it will triger\n        const handleCallback = function(had_error) {\n            if (modbus.callback) {\n                modbus.callback(had_error);\n                modbus.callback = null;\n            }\n        };\n\n        // create a socket\n        modbus._client = this._externalSocket || new net.Socket();\n        if (options.timeout) this._client.setTimeout(options.timeout);\n\n        // register the port data event\n        modbus._client.on(\"data\", function onData(data) {\n            // add data to buffer\n            modbus._buffer = Buffer.concat([modbus._buffer, data]);\n\n            modbusSerialDebug({\n                action: \"receive tcp rtu buffered port\",\n                data: data,\n                buffer: modbus._buffer\n            });\n\n            // check if buffer include a complete modbus answer\n            let bufferLength = modbus._buffer.length;\n\n            // check data length\n            if (bufferLength < MIN_MBAP_LENGTH) return;\n\n            // check buffer size for MAX_BUFFER_SIZE\n            if (bufferLength > MAX_BUFFER_LENGTH) {\n                modbus._buffer = modbus._buffer.slice(-MAX_BUFFER_LENGTH);\n                bufferLength = MAX_BUFFER_LENGTH;\n            }\n\n            // check data length\n            if (bufferLength < MIN_MBAP_LENGTH + EXCEPTION_LENGTH) return;\n\n            // loop and check length-sized buffer chunks\n            const maxOffset = bufferLength - MIN_MBAP_LENGTH;\n            for (let i = 0; i <= maxOffset; i++) {\n                modbus._transactionIdRead = modbus._buffer.readUInt16BE(i);\n                const protocolID = modbus._buffer.readUInt16BE(i + 2);\n                const msgLength = modbus._buffer.readUInt16BE(i + 4);\n                const cmd = modbus._buffer[i + 7];\n\n                modbusSerialDebug({\n                    protocolID: protocolID,\n                    msgLength: msgLength,\n                    bufferLength: bufferLength,\n                    cmd: cmd\n                });\n\n                if (\n                    protocolID === 0 &&\n                    cmd !== 0 &&\n                    msgLength >= EXCEPTION_LENGTH &&\n                    i + MIN_MBAP_LENGTH + msgLength <= bufferLength\n                ) {\n                    // add crc and emit\n                    modbus._emitData(i + MIN_MBAP_LENGTH, msgLength);\n                    return;\n                }\n            }\n        });\n\n        this._client.on(\"connect\", function() {\n            modbus.openFlag = true;\n            handleCallback();\n        });\n\n        this._client.on(\"close\", function(had_error) {\n            if (modbus.openFlag) {\n                modbus.openFlag = false;\n                modbusSerialDebug(\"TCP buffered port: signal close: \" + had_error);\n                handleCallback(had_error);\n\n                modbus.emit(\"close\");\n                modbus.removeAllListeners();\n            }\n        });\n\n        this._client.on(\"error\", function(had_error) {\n            modbus.openFlag = false;\n            handleCallback(had_error);\n        });\n\n        this._client.on(\"timeout\", function() {\n            // modbus.openFlag is left in its current state as it reflects two types of timeouts,\n            // i.e. 'false' for \"TCP connection timeout\" and 'true' for \"Modbus response timeout\"\n            // (this allows to continue Modbus request re-tries without reconnecting TCP).\n            modbusSerialDebug(\"TcpRTUBufferedPort port: TimedOut\");\n            handleCallback(new Error(\"TcpRTUBufferedPort Connection Timed Out\"));\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this.openFlag;\n    }\n\n    /**\n     * Emit the received response, cut the buffer and reset the internal vars.\n     *\n     * @param {number} start the start index of the response within the buffer\n     * @param {number} length the length of the response\n     * @private\n     */\n    _emitData(start, length) {\n        const modbus = this;\n        const data = modbus._buffer.slice(start, start + length);\n\n        // cut the buffer\n        modbus._buffer = modbus._buffer.slice(start + length);\n\n        if (data.length > 0) {\n            const buffer = Buffer.alloc(data.length + CRC_LENGTH);\n            data.copy(buffer, 0);\n\n            // add crc\n            const crc = crc16(buffer.slice(0, -CRC_LENGTH));\n            buffer.writeUInt16LE(crc, buffer.length - CRC_LENGTH);\n\n            modbus.emit(\"data\", buffer);\n\n            // debug\n            modbusSerialDebug({\n                action: \"parsed tcp buffered port\",\n                buffer: buffer,\n                transactionId: modbus._transactionIdRead\n            });\n        } else {\n            modbusSerialDebug({ action: \"emit data to short\", data: data });\n        }\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    open(callback) {\n        if(this._externalSocket === null) {\n            this.callback = callback;\n            this._client.connect(this.connectOptions);\n        } else if(this.openFlag) {\n            modbusSerialDebug(\"TcpRTUBuffered port: external socket is opened\");\n            callback(); // go ahead to setup existing socket\n        } else {\n            callback(new Error(\"TcpRTUBuffered port: external socket is not opened\"));\n        }\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        this.callback = callback;\n        // DON'T pass callback to `end()` here, it will be handled by client.on('close') handler\n        this._client.end();\n    }\n\n    /**\n     * Simulate successful destroy port.\n     *\n     * @param callback\n     */\n    destroy(callback) {\n        this.callback = callback;\n        if (!this._client.destroyed) {\n            this._client.destroy();\n        }\n    }\n\n    /**\n     * Send data to a modbus slave via telnet server.\n     *\n     * @param {Buffer} data\n     */\n    write(data) {\n        if (data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\n                \"expected length of data is to small - minimum is \" +\n                    MIN_DATA_LENGTH\n            );\n            return;\n        }\n\n        // remove crc and add mbap\n        const buffer = Buffer.alloc(data.length + MIN_MBAP_LENGTH - CRC_LENGTH);\n        buffer.writeUInt16BE(this._transactionIdWrite, 0);\n        buffer.writeUInt16BE(0, 2);\n        buffer.writeUInt16BE(data.length - CRC_LENGTH, 4);\n        data.copy(buffer, MIN_MBAP_LENGTH);\n\n        modbusSerialDebug({\n            action: \"send tcp rtu buffered port\",\n            data: data,\n            buffer: buffer,\n            transactionsId: this._transactionIdWrite\n        });\n\n        // get next transaction id\n        this._transactionIdWrite =\n            (this._transactionIdWrite + 1) % MAX_TRANSACTIONS;\n\n        // send buffer to slave\n        this._client.write(buffer);\n    }\n}\n\n/**\n * TCP RTU bufferd port for Modbus.\n *\n * @type {TcpRTUBufferedPort}\n */\nmodule.exports = TcpRTUBufferedPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}