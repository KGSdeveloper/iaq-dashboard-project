{"ast":null,"code":"\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/* TODO: const should be set once, maybe */\nconst EXCEPTION_LENGTH = 5;\nconst MIN_DATA_LENGTH = 6;\nconst TELNET_PORT = 2217;\nclass TelnetPort extends EventEmitter {\n  /**\n   * Simulate a modbus-RTU port using Telent connection.\n   *\n   * @param ip\n   * @param options\n   * @constructor\n   */\n  constructor(ip, options) {\n    super();\n    const self = this;\n    this.ip = ip;\n    this.openFlag = false;\n    this.callback = null;\n    this._externalSocket = null;\n\n    // options\n    if (typeof ip === \"object\") {\n      options = ip;\n      this.ip = options.ip;\n    }\n    if (typeof options === \"undefined\") options = {};\n    this.port = options.port || TELNET_PORT; // telnet server port\n\n    // internal buffer\n    this._buffer = Buffer.alloc(0);\n    this._id = 0;\n    this._cmd = 0;\n    this._length = 0;\n\n    // handle callback - call a callback function only once, for the first event\n    // it will triger\n    const handleCallback = function (had_error) {\n      if (self.callback) {\n        self.callback(had_error);\n        self.callback = null;\n      }\n    };\n    if (options.socket) {\n      if (options.socket instanceof net.Socket) {\n        this._externalSocket = options.socket;\n        this.openFlag = this._externalSocket.readyState === \"opening\" || this._externalSocket.readyState === \"open\";\n      } else {\n        throw new Error(\"invalid socket provided\");\n      }\n    }\n\n    // create a socket\n    this._client = this._externalSocket || new net.Socket();\n    if (options.timeout) this._client.setTimeout(options.timeout);\n\n    // register the port data event\n    this._client.on(\"data\", function onData(data) {\n      // add data to buffer\n      self._buffer = Buffer.concat([self._buffer, data]);\n\n      // check if buffer include a complete modbus answer\n      const expectedLength = self._length;\n      const bufferLength = self._buffer.length;\n      modbusSerialDebug(\"on data expected length:\" + expectedLength + \" buffer length:\" + bufferLength);\n      modbusSerialDebug({\n        action: \"receive tcp telnet port\",\n        data: data,\n        buffer: self._buffer\n      });\n      modbusSerialDebug(JSON.stringify({\n        action: \"receive tcp telnet port strings\",\n        data: data,\n        buffer: self._buffer\n      }));\n\n      // check data length\n      if (expectedLength < 6 || bufferLength < EXCEPTION_LENGTH) return;\n\n      // loop and check length-sized buffer chunks\n      const maxOffset = bufferLength - EXCEPTION_LENGTH;\n      for (let i = 0; i <= maxOffset; i++) {\n        const unitId = self._buffer[i];\n        const functionCode = self._buffer[i + 1];\n        if (unitId !== self._id) continue;\n        if (functionCode === self._cmd && i + expectedLength <= bufferLength) {\n          self._emitData(i, expectedLength);\n          return;\n        }\n        if (functionCode === (0x80 | self._cmd) && i + EXCEPTION_LENGTH <= bufferLength) {\n          self._emitData(i, EXCEPTION_LENGTH);\n          return;\n        }\n\n        // frame header matches, but still missing bytes pending\n        if (functionCode === (0x7f & self._cmd)) break;\n      }\n    });\n    this._client.on(\"connect\", function () {\n      self.openFlag = true;\n      handleCallback();\n    });\n    this._client.on(\"close\", function (had_error) {\n      self.openFlag = false;\n      handleCallback(had_error);\n      self.emit(\"close\");\n    });\n    this._client.on(\"error\", function (had_error) {\n      self.openFlag = false;\n      handleCallback(had_error);\n    });\n    this._client.on(\"timeout\", function () {\n      // modbus.openFlag is left in its current state as it reflects two types of timeouts,\n      // i.e. 'false' for \"TCP connection timeout\" and 'true' for \"Modbus response timeout\"\n      // (this allows to continue Modbus request re-tries without reconnecting TCP).\n      modbusSerialDebug(\"TelnetPort port: TimedOut\");\n      handleCallback(new Error(\"TelnetPort Connection Timed Out.\"));\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this.openFlag;\n  }\n\n  /**\n   * Emit the received response, cut the buffer and reset the internal vars.\n   *\n   * @param {number} start the start index of the response within the buffer\n   * @param {number} length the length of the response\n   * @private\n   */\n  _emitData(start, length) {\n    this.emit(\"data\", this._buffer.slice(start, start + length));\n    this._buffer = this._buffer.slice(start + length);\n\n    // reset internal vars\n    this._id = 0;\n    this._cmd = 0;\n    this._length = 0;\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  open(callback) {\n    if (this._externalSocket === null) {\n      this.callback = callback;\n      this._client.connect(this.port, this.ip);\n    } else if (this.openFlag) {\n      modbusSerialDebug(\"telnet port: external socket is opened\");\n      callback(); // go ahead to setup existing socket\n    } else {\n      callback(new Error(\"telnet port: external socket is not opened\"));\n    }\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    this.callback = callback;\n    this._client.end();\n    this.removeAllListeners();\n  }\n\n  /**\n   * Simulate successful destroy port.\n   *\n   * @param callback\n   */\n  destroy(callback) {\n    this.callback = callback;\n    if (!this._client.destroyed) {\n      this._client.destroy();\n    }\n  }\n\n  /**\n   * Send data to a modbus slave via telnet server.\n   *\n   * @param {Buffer} data\n   */\n  write(data) {\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n    let length = null;\n\n    // remember current unit and command\n    this._id = data[0];\n    this._cmd = data[1];\n\n    // calculate expected answer length\n    switch (this._cmd) {\n      case 1:\n      case 2:\n        length = data.readUInt16BE(4);\n        this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n        break;\n      case 3:\n      case 4:\n        length = data.readUInt16BE(4);\n        this._length = 3 + 2 * length + 2;\n        break;\n      case 5:\n      case 6:\n      case 15:\n      case 16:\n        this._length = 6 + 2;\n        break;\n      default:\n        // raise and error ?\n        this._length = 0;\n        break;\n    }\n\n    // send buffer to slave\n    this._client.write(data);\n    modbusSerialDebug({\n      action: \"send tcp telnet port\",\n      data: data,\n      unitid: this._id,\n      functionCode: this._cmd\n    });\n    modbusSerialDebug(JSON.stringify({\n      action: \"send tcp telnet port strings\",\n      data: data,\n      unitid: this._id,\n      functionCode: this._cmd\n    }));\n  }\n}\n\n/**\n * Telnet port for Modbus.\n *\n * @type {TelnetPort}\n */\nmodule.exports = TelnetPort;","map":{"version":3,"names":["events","require","EventEmitter","net","modbusSerialDebug","EXCEPTION_LENGTH","MIN_DATA_LENGTH","TELNET_PORT","TelnetPort","constructor","ip","options","self","openFlag","callback","_externalSocket","port","_buffer","Buffer","alloc","_id","_cmd","_length","handleCallback","had_error","socket","Socket","readyState","Error","_client","timeout","setTimeout","on","onData","data","concat","expectedLength","bufferLength","length","action","buffer","JSON","stringify","maxOffset","i","unitId","functionCode","_emitData","emit","isOpen","start","slice","open","connect","close","end","removeAllListeners","destroy","destroyed","write","readUInt16BE","parseInt","unitid","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/telnetport.js"],"sourcesContent":["\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/* TODO: const should be set once, maybe */\nconst EXCEPTION_LENGTH = 5;\nconst MIN_DATA_LENGTH = 6;\n\nconst TELNET_PORT = 2217;\n\nclass TelnetPort extends EventEmitter {\n    /**\n     * Simulate a modbus-RTU port using Telent connection.\n     *\n     * @param ip\n     * @param options\n     * @constructor\n     */\n    constructor(ip, options) {\n        super();\n\n        const self = this;\n        this.ip = ip;\n        this.openFlag = false;\n        this.callback = null;\n        this._externalSocket = null;\n\n        // options\n        if(typeof ip === \"object\") {\n            options = ip;\n            this.ip = options.ip;\n        }\n        if (typeof options === \"undefined\") options = {};\n        this.port = options.port || TELNET_PORT; // telnet server port\n\n        // internal buffer\n        this._buffer = Buffer.alloc(0);\n        this._id = 0;\n        this._cmd = 0;\n        this._length = 0;\n\n        // handle callback - call a callback function only once, for the first event\n        // it will triger\n        const handleCallback = function(had_error) {\n            if (self.callback) {\n                self.callback(had_error);\n                self.callback = null;\n            }\n        };\n\n        if(options.socket) {\n            if(options.socket instanceof net.Socket) {\n                this._externalSocket = options.socket;\n                this.openFlag = this._externalSocket.readyState === \"opening\" || this._externalSocket.readyState === \"open\";\n            } else {\n                throw new Error(\"invalid socket provided\");\n            }\n        }\n\n        // create a socket\n        this._client = this._externalSocket || new net.Socket();\n        if (options.timeout) this._client.setTimeout(options.timeout);\n\n        // register the port data event\n        this._client.on(\"data\", function onData(data) {\n            // add data to buffer\n            self._buffer = Buffer.concat([self._buffer, data]);\n\n            // check if buffer include a complete modbus answer\n            const expectedLength = self._length;\n            const bufferLength = self._buffer.length;\n            modbusSerialDebug(\n                \"on data expected length:\" +\n                    expectedLength +\n                    \" buffer length:\" +\n                    bufferLength\n            );\n\n            modbusSerialDebug({\n                action: \"receive tcp telnet port\",\n                data: data,\n                buffer: self._buffer\n            });\n            modbusSerialDebug(\n                JSON.stringify({\n                    action: \"receive tcp telnet port strings\",\n                    data: data,\n                    buffer: self._buffer\n                })\n            );\n\n            // check data length\n            if (expectedLength < 6 || bufferLength < EXCEPTION_LENGTH) return;\n\n            // loop and check length-sized buffer chunks\n            const maxOffset = bufferLength - EXCEPTION_LENGTH;\n            for (let i = 0; i <= maxOffset; i++) {\n                const unitId = self._buffer[i];\n                const functionCode = self._buffer[i + 1];\n\n                if (unitId !== self._id) continue;\n\n                if (\n                    functionCode === self._cmd &&\n                    i + expectedLength <= bufferLength\n                ) {\n                    self._emitData(i, expectedLength);\n                    return;\n                }\n                if (\n                    functionCode === (0x80 | self._cmd) &&\n                    i + EXCEPTION_LENGTH <= bufferLength\n                ) {\n                    self._emitData(i, EXCEPTION_LENGTH);\n                    return;\n                }\n\n                // frame header matches, but still missing bytes pending\n                if (functionCode === (0x7f & self._cmd)) break;\n            }\n        });\n\n        this._client.on(\"connect\", function() {\n            self.openFlag = true;\n            handleCallback();\n        });\n\n        this._client.on(\"close\", function(had_error) {\n            self.openFlag = false;\n            handleCallback(had_error);\n            self.emit(\"close\");\n        });\n\n        this._client.on(\"error\", function(had_error) {\n            self.openFlag = false;\n            handleCallback(had_error);\n        });\n\n        this._client.on(\"timeout\", function() {\n            // modbus.openFlag is left in its current state as it reflects two types of timeouts,\n            // i.e. 'false' for \"TCP connection timeout\" and 'true' for \"Modbus response timeout\"\n            // (this allows to continue Modbus request re-tries without reconnecting TCP).\n            modbusSerialDebug(\"TelnetPort port: TimedOut\");\n            handleCallback(new Error(\"TelnetPort Connection Timed Out.\"));\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this.openFlag;\n    }\n\n    /**\n     * Emit the received response, cut the buffer and reset the internal vars.\n     *\n     * @param {number} start the start index of the response within the buffer\n     * @param {number} length the length of the response\n     * @private\n     */\n    _emitData(start, length) {\n        this.emit(\"data\", this._buffer.slice(start, start + length));\n        this._buffer = this._buffer.slice(start + length);\n\n        // reset internal vars\n        this._id = 0;\n        this._cmd = 0;\n        this._length = 0;\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    open(callback) {\n        if(this._externalSocket === null) {\n            this.callback = callback;\n            this._client.connect(this.port, this.ip);\n        } else if(this.openFlag) {\n            modbusSerialDebug(\"telnet port: external socket is opened\");\n            callback(); // go ahead to setup existing socket\n        } else {\n            callback(new Error(\"telnet port: external socket is not opened\"));\n        }\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        this.callback = callback;\n        this._client.end();\n        this.removeAllListeners();\n    }\n\n    /**\n     * Simulate successful destroy port.\n     *\n     * @param callback\n     */\n    destroy(callback) {\n        this.callback = callback;\n        if (!this._client.destroyed) {\n            this._client.destroy();\n        }\n    }\n\n    /**\n     * Send data to a modbus slave via telnet server.\n     *\n     * @param {Buffer} data\n     */\n    write(data) {\n        if (data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\n                \"expected length of data is to small - minimum is \" +\n                    MIN_DATA_LENGTH\n            );\n            return;\n        }\n\n        let length = null;\n\n        // remember current unit and command\n        this._id = data[0];\n        this._cmd = data[1];\n\n        // calculate expected answer length\n        switch (this._cmd) {\n            case 1:\n            case 2:\n                length = data.readUInt16BE(4);\n                this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n                break;\n            case 3:\n            case 4:\n                length = data.readUInt16BE(4);\n                this._length = 3 + 2 * length + 2;\n                break;\n            case 5:\n            case 6:\n            case 15:\n            case 16:\n                this._length = 6 + 2;\n                break;\n            default:\n                // raise and error ?\n                this._length = 0;\n                break;\n        }\n\n        // send buffer to slave\n        this._client.write(data);\n\n        modbusSerialDebug({\n            action: \"send tcp telnet port\",\n            data: data,\n            unitid: this._id,\n            functionCode: this._cmd\n        });\n\n        modbusSerialDebug(\n            JSON.stringify({\n                action: \"send tcp telnet port strings\",\n                data: data,\n                unitid: this._id,\n                functionCode: this._cmd\n            })\n        );\n    }\n}\n\n/**\n * Telnet port for Modbus.\n *\n * @type {TelnetPort}\n */\nmodule.exports = TelnetPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}