{"ast":null,"code":"\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst MODBUS_PORT = 502; // modbus port\nconst MAX_TRANSACTIONS = 256; // maximum transaction to wait for\nconst MIN_DATA_LENGTH = 6;\nconst MIN_MBAP_LENGTH = 6;\nconst CRC_LENGTH = 2;\nclass TcpPort extends EventEmitter {\n  /**\n   * Simulate a modbus-RTU port using modbus-TCP connection.\n   *\n   * @param {string} ip - IP address of Modbus slave.\n   * @param {{\n   *  port?: number,\n   *  localAddress?: string,\n   *  family?: 0|4|6,\n   *  timeout?: number,\n   *  socket?: net.Socket\n   *  socketOpts?: {\n   *      fd: number,\n   *      allowHalfOpen?: boolean,\n   *      readable?: boolean,\n   *      writable?: boolean,\n   *      signal?: AbortSignal\n   *  },\n   * } & net.TcpSocketConnectOpts} options - Options object.\n   *   options.port: Nonstandard Modbus port (default is 502).\n   *   options.localAddress: Local IP address to bind to, default is any.\n   *   options.family: 4 = IPv4-only, 6 = IPv6-only, 0 = either (default).\n   * @constructor\n   */\n  constructor(ip, options) {\n    super();\n    const self = this;\n    /** @type {boolean} Flag to indicate if port is open */\n    this.openFlag = false;\n    /** @type {(err?: Error) => void} */\n    this.callback = null;\n    this._transactionIdWrite = 1;\n    /** @type {net.Socket?} - Optional custom socket */\n    this._externalSocket = null;\n    if (typeof ip === \"object\") {\n      options = ip;\n      ip = undefined;\n    }\n    if (typeof options === \"undefined\") options = {};\n    this.socketOpts = undefined;\n    if (options.socketOpts) {\n      this.socketOpts = options.socketOpts;\n      delete options.socketOpts;\n    }\n\n    /** @type {net.TcpSocketConnectOpts} - Options for net.connect(). */\n    this.connectOptions = {\n      // Default options\n      ...{\n        host: ip || options.ip,\n        port: MODBUS_PORT\n      },\n      // User options\n      ...options\n    };\n    if (options.socket) {\n      if (options.socket instanceof net.Socket) {\n        this._externalSocket = options.socket;\n        this.openFlag = this._externalSocket.readyState === \"opening\" || this._externalSocket.readyState === \"open\";\n      } else {\n        throw new Error(\"invalid socket provided\");\n      }\n    }\n\n    // handle callback - call a callback function only once, for the first event\n    // it will trigger\n    const handleCallback = function (had_error) {\n      if (self.callback) {\n        self.callback(had_error);\n        self.callback = null;\n      }\n    };\n\n    // init a socket\n    this._client = this._externalSocket || new net.Socket(this.socketOpts);\n    this._writeCompleted = Promise.resolve();\n    if (options.timeout) this._client.setTimeout(options.timeout);\n\n    // register events handlers\n    this._client.on(\"data\", function (data) {\n      let buffer;\n      let crc;\n      let length;\n\n      // data recived\n      modbusSerialDebug({\n        action: \"receive tcp port strings\",\n        data: data\n      });\n\n      // check data length\n      while (data.length > MIN_MBAP_LENGTH) {\n        // parse tcp header length\n        length = data.readUInt16BE(4);\n\n        // cut 6 bytes of mbap and copy pdu\n        buffer = Buffer.alloc(length + CRC_LENGTH);\n        data.copy(buffer, 0, MIN_MBAP_LENGTH);\n\n        // add crc to message\n        crc = crc16(buffer.slice(0, -CRC_LENGTH));\n        buffer.writeUInt16LE(crc, buffer.length - CRC_LENGTH);\n\n        // update transaction id and emit data\n        self._transactionIdRead = data.readUInt16BE(0);\n        self.emit(\"data\", buffer);\n\n        // debug\n        modbusSerialDebug({\n          action: \"parsed tcp port\",\n          buffer: buffer,\n          transactionId: self._transactionIdRead\n        });\n\n        // reset data\n        data = data.slice(length + MIN_MBAP_LENGTH);\n      }\n    });\n    this._client.on(\"connect\", function () {\n      self.openFlag = true;\n      self._writeCompleted = Promise.resolve();\n      modbusSerialDebug(\"TCP port: signal connect\");\n      self._client.setNoDelay();\n      handleCallback();\n    });\n    this._client.on(\"close\", function (had_error) {\n      if (self.openFlag) {\n        self.openFlag = false;\n        modbusSerialDebug(\"TCP port: signal close: \" + had_error);\n        handleCallback(had_error);\n        self.emit(\"close\");\n        self.removeAllListeners();\n      }\n    });\n    this._client.on(\"error\", function (had_error) {\n      self.openFlag = false;\n      modbusSerialDebug(\"TCP port: signal error: \" + had_error);\n      handleCallback(had_error);\n    });\n    this._client.on(\"timeout\", function () {\n      // modbus.openFlag is left in its current state as it reflects two types of timeouts,\n      // i.e. 'false' for \"TCP connection timeout\" and 'true' for \"Modbus response timeout\"\n      // (this allows to continue Modbus request re-tries without reconnecting TCP).\n      modbusSerialDebug(\"TCP port: TimedOut\");\n      handleCallback(new Error(\"TCP Connection Timed Out\"));\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this.openFlag;\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param {(err?: Error) => void} callback\n   */\n  open(callback) {\n    if (this._externalSocket === null) {\n      this.callback = callback;\n      this._client.connect(this.connectOptions);\n    } else if (this.openFlag) {\n      modbusSerialDebug(\"TCP port: external socket is opened\");\n      callback(); // go ahead to setup existing socket\n    } else {\n      callback(new Error(\"TCP port: external socket is not opened\"));\n    }\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param {(err?: Error) => void} callback\n   */\n  close(callback) {\n    this.callback = callback;\n    // DON'T pass callback to `end()` here, it will be handled by client.on('close') handler\n    this._client.end();\n  }\n\n  /**\n   * Simulate successful destroy port.\n   *\n   * @param {(err?: Error) => void} callback\n   */\n  destroy(callback) {\n    this.callback = callback;\n    if (!this._client.destroyed) {\n      this._client.destroy();\n    }\n  }\n\n  /**\n   * Send data to a modbus-tcp slave.\n   *\n   * @param {Buffer} data\n   */\n  write(data) {\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n\n    // remember current unit and command\n    this._id = data[0];\n    this._cmd = data[1];\n\n    // remove crc and add mbap\n    const buffer = Buffer.alloc(data.length + MIN_MBAP_LENGTH - CRC_LENGTH);\n    buffer.writeUInt16BE(this._transactionIdWrite, 0);\n    buffer.writeUInt16BE(0, 2);\n    buffer.writeUInt16BE(data.length - CRC_LENGTH, 4);\n    data.copy(buffer, MIN_MBAP_LENGTH);\n    modbusSerialDebug({\n      action: \"send tcp port\",\n      data: data,\n      buffer: buffer,\n      unitid: this._id,\n      functionCode: this._cmd,\n      transactionsId: this._transactionIdWrite\n    });\n\n    // send buffer to slave\n    const previousWritePromise = this._writeCompleted;\n    const newWritePromise = new Promise((resolveNewWrite, rejectNewWrite) => {\n      // Wait for the completion of any write that happened before.\n      previousWritePromise.finally(() => {\n        try {\n          // The previous write succeeded, write the new buffer.\n          if (this._client.write(buffer)) {\n            // Mark this write as complete.\n            resolveNewWrite();\n          } else {\n            // Wait for one `drain` event to mark this write as complete.\n            this._client.once(\"drain\", resolveNewWrite);\n          }\n        } catch (error) {\n          rejectNewWrite(error);\n        }\n      });\n    });\n    // Overwrite `_writeCompleted` so that the next call to `TcpPort.write` will have to wait on our write to complete.\n    this._writeCompleted = newWritePromise;\n\n    // set next transaction id\n    this._transactionIdWrite = (this._transactionIdWrite + 1) % MAX_TRANSACTIONS;\n  }\n}\n\n/**\n * TCP port for Modbus.\n *\n * @type {TcpPort}\n */\nmodule.exports = TcpPort;","map":{"version":3,"names":["events","require","EventEmitter","net","modbusSerialDebug","crc16","MODBUS_PORT","MAX_TRANSACTIONS","MIN_DATA_LENGTH","MIN_MBAP_LENGTH","CRC_LENGTH","TcpPort","constructor","ip","options","self","openFlag","callback","_transactionIdWrite","_externalSocket","undefined","socketOpts","connectOptions","host","port","socket","Socket","readyState","Error","handleCallback","had_error","_client","_writeCompleted","Promise","resolve","timeout","setTimeout","on","data","buffer","crc","length","action","readUInt16BE","Buffer","alloc","copy","slice","writeUInt16LE","_transactionIdRead","emit","transactionId","setNoDelay","removeAllListeners","isOpen","open","connect","close","end","destroy","destroyed","write","_id","_cmd","writeUInt16BE","unitid","functionCode","transactionsId","previousWritePromise","newWritePromise","resolveNewWrite","rejectNewWrite","finally","once","error","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/tcpport.js"],"sourcesContent":["\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst MODBUS_PORT = 502; // modbus port\nconst MAX_TRANSACTIONS = 256; // maximum transaction to wait for\nconst MIN_DATA_LENGTH = 6;\nconst MIN_MBAP_LENGTH = 6;\nconst CRC_LENGTH = 2;\n\nclass TcpPort extends EventEmitter {\n    /**\n     * Simulate a modbus-RTU port using modbus-TCP connection.\n     *\n     * @param {string} ip - IP address of Modbus slave.\n     * @param {{\n     *  port?: number,\n     *  localAddress?: string,\n     *  family?: 0|4|6,\n     *  timeout?: number,\n     *  socket?: net.Socket\n     *  socketOpts?: {\n     *      fd: number,\n     *      allowHalfOpen?: boolean,\n     *      readable?: boolean,\n     *      writable?: boolean,\n     *      signal?: AbortSignal\n     *  },\n     * } & net.TcpSocketConnectOpts} options - Options object.\n     *   options.port: Nonstandard Modbus port (default is 502).\n     *   options.localAddress: Local IP address to bind to, default is any.\n     *   options.family: 4 = IPv4-only, 6 = IPv6-only, 0 = either (default).\n     * @constructor\n     */\n    constructor(ip, options) {\n        super();\n        const self = this;\n        /** @type {boolean} Flag to indicate if port is open */\n        this.openFlag = false;\n        /** @type {(err?: Error) => void} */\n        this.callback = null;\n        this._transactionIdWrite = 1;\n        /** @type {net.Socket?} - Optional custom socket */\n        this._externalSocket = null;\n\n        if (typeof ip === \"object\") {\n            options = ip;\n            ip = undefined;\n        }\n\n        if (typeof options === \"undefined\") options = {};\n\n        this.socketOpts = undefined;\n        if (options.socketOpts) {\n            this.socketOpts = options.socketOpts;\n            delete options.socketOpts;\n        }\n\n        /** @type {net.TcpSocketConnectOpts} - Options for net.connect(). */\n        this.connectOptions = {\n            // Default options\n            ...{\n                host: ip || options.ip,\n                port: MODBUS_PORT\n            },\n            // User options\n            ...options\n        };\n\n        if (options.socket) {\n            if (options.socket instanceof net.Socket) {\n                this._externalSocket = options.socket;\n                this.openFlag = this._externalSocket.readyState === \"opening\" || this._externalSocket.readyState === \"open\";\n            } else {\n                throw new Error(\"invalid socket provided\");\n            }\n        }\n\n        // handle callback - call a callback function only once, for the first event\n        // it will trigger\n        const handleCallback = function(had_error) {\n            if (self.callback) {\n                self.callback(had_error);\n                self.callback = null;\n            }\n        };\n\n        // init a socket\n        this._client = this._externalSocket || new net.Socket(this.socketOpts);\n        this._writeCompleted = Promise.resolve();\n\n        if (options.timeout) this._client.setTimeout(options.timeout);\n\n        // register events handlers\n        this._client.on(\"data\", function(data) {\n            let buffer;\n            let crc;\n            let length;\n\n            // data recived\n            modbusSerialDebug({ action: \"receive tcp port strings\", data: data });\n\n            // check data length\n            while (data.length > MIN_MBAP_LENGTH) {\n                // parse tcp header length\n                length = data.readUInt16BE(4);\n\n                // cut 6 bytes of mbap and copy pdu\n                buffer = Buffer.alloc(length + CRC_LENGTH);\n                data.copy(buffer, 0, MIN_MBAP_LENGTH);\n\n                // add crc to message\n                crc = crc16(buffer.slice(0, -CRC_LENGTH));\n                buffer.writeUInt16LE(crc, buffer.length - CRC_LENGTH);\n\n                // update transaction id and emit data\n                self._transactionIdRead = data.readUInt16BE(0);\n                self.emit(\"data\", buffer);\n\n                // debug\n                modbusSerialDebug({ action: \"parsed tcp port\", buffer: buffer, transactionId: self._transactionIdRead });\n\n                // reset data\n                data = data.slice(length + MIN_MBAP_LENGTH);\n            }\n        });\n\n        this._client.on(\"connect\", function() {\n            self.openFlag = true;\n            self._writeCompleted = Promise.resolve();\n            modbusSerialDebug(\"TCP port: signal connect\");\n            self._client.setNoDelay();\n            handleCallback();\n        });\n\n        this._client.on(\"close\", function(had_error) {\n            if (self.openFlag)  {\n                self.openFlag = false;\n                modbusSerialDebug(\"TCP port: signal close: \" + had_error);\n                handleCallback(had_error);\n\n                self.emit(\"close\");\n                self.removeAllListeners();\n            }\n        });\n\n        this._client.on(\"error\", function(had_error) {\n            self.openFlag = false;\n            modbusSerialDebug(\"TCP port: signal error: \" + had_error);\n            handleCallback(had_error);\n        });\n\n        this._client.on(\"timeout\", function() {\n            // modbus.openFlag is left in its current state as it reflects two types of timeouts,\n            // i.e. 'false' for \"TCP connection timeout\" and 'true' for \"Modbus response timeout\"\n            // (this allows to continue Modbus request re-tries without reconnecting TCP).\n            modbusSerialDebug(\"TCP port: TimedOut\");\n            handleCallback(new Error(\"TCP Connection Timed Out\"));\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this.openFlag;\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param {(err?: Error) => void} callback\n     */\n    open(callback) {\n        if (this._externalSocket === null) {\n            this.callback = callback;\n            this._client.connect(this.connectOptions);\n        } else if (this.openFlag) {\n            modbusSerialDebug(\"TCP port: external socket is opened\");\n            callback(); // go ahead to setup existing socket\n        } else {\n            callback(new Error(\"TCP port: external socket is not opened\"));\n        }\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param {(err?: Error) => void} callback\n     */\n    close(callback) {\n        this.callback = callback;\n        // DON'T pass callback to `end()` here, it will be handled by client.on('close') handler\n        this._client.end();\n    }\n\n    /**\n     * Simulate successful destroy port.\n     *\n     * @param {(err?: Error) => void} callback\n     */\n    destroy(callback) {\n        this.callback = callback;\n        if (!this._client.destroyed) {\n            this._client.destroy();\n        }\n    }\n\n    /**\n     * Send data to a modbus-tcp slave.\n     *\n     * @param {Buffer} data\n     */\n    write(data) {\n        if (data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n            return;\n        }\n\n        // remember current unit and command\n        this._id = data[0];\n        this._cmd = data[1];\n\n        // remove crc and add mbap\n        const buffer = Buffer.alloc(data.length + MIN_MBAP_LENGTH - CRC_LENGTH);\n        buffer.writeUInt16BE(this._transactionIdWrite, 0);\n        buffer.writeUInt16BE(0, 2);\n        buffer.writeUInt16BE(data.length - CRC_LENGTH, 4);\n        data.copy(buffer, MIN_MBAP_LENGTH);\n\n        modbusSerialDebug({\n            action: \"send tcp port\",\n            data: data,\n            buffer: buffer,\n            unitid: this._id,\n            functionCode: this._cmd,\n            transactionsId: this._transactionIdWrite\n        });\n\n        // send buffer to slave\n        const previousWritePromise = this._writeCompleted;\n        const newWritePromise = new Promise((resolveNewWrite, rejectNewWrite) => {\n            // Wait for the completion of any write that happened before.\n            previousWritePromise.finally(() => {\n                try {\n                    // The previous write succeeded, write the new buffer.\n                    if (this._client.write(buffer)) {\n                        // Mark this write as complete.\n                        resolveNewWrite();\n                    } else {\n                        // Wait for one `drain` event to mark this write as complete.\n                        this._client.once(\"drain\", resolveNewWrite);\n                    }\n                } catch (error) {\n                    rejectNewWrite(error);\n                }\n            });\n        });\n        // Overwrite `_writeCompleted` so that the next call to `TcpPort.write` will have to wait on our write to complete.\n        this._writeCompleted = newWritePromise;\n\n        // set next transaction id\n        this._transactionIdWrite = (this._transactionIdWrite + 1) % MAX_TRANSACTIONS;\n    }\n}\n\n/**\n * TCP port for Modbus.\n *\n * @type {TcpPort}\n */\nmodule.exports = TcpPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}