{"ast":null,"code":"import ModbusRTU from 'modbus-serial';\nimport { MODBUS_CONFIG } from '../utils/constants.js';\nclass ModbusService {\n  constructor() {\n    this.client = new ModbusRTU();\n    this.isConnected = false;\n    this.connectionConfig = {\n      host: 'localhost',\n      // Change to your Modbus device IP\n      port: 502,\n      timeout: 5000\n    };\n  }\n  async connect() {\n    try {\n      await this.client.connectTCP(this.connectionConfig.host, {\n        port: this.connectionConfig.port\n      });\n      this.client.setTimeout(this.connectionConfig.timeout);\n      this.client.setID(MODBUS_CONFIG.DEVICE_ADDRESS);\n      this.isConnected = true;\n      console.log('Modbus connection established');\n      return true;\n    } catch (error) {\n      console.error('Failed to connect to Modbus device:', error);\n      this.isConnected = false;\n      return false;\n    }\n  }\n  async disconnect() {\n    if (this.isConnected) {\n      await this.client.close();\n      this.isConnected = false;\n      console.log('Modbus connection closed');\n    }\n  }\n  async readSensorData() {\n    if (!this.isConnected) {\n      throw new Error('Modbus not connected');\n    }\n    try {\n      const registers = Object.values(MODBUS_CONFIG.REGISTERS);\n      const startRegister = Math.min(...registers);\n      const registerCount = Math.max(...registers) - startRegister + 1;\n      const response = await this.client.readHoldingRegisters(startRegister, registerCount);\n      return {\n        PM25: response.data[MODBUS_CONFIG.REGISTERS.PM25 - startRegister] / 100,\n        // Assuming data needs scaling\n        CO2: response.data[MODBUS_CONFIG.REGISTERS.CO2 - startRegister],\n        TEMPERATURE: response.data[MODBUS_CONFIG.REGISTERS.TEMPERATURE - startRegister] / 100,\n        HUMIDITY: response.data[MODBUS_CONFIG.REGISTERS.HUMIDITY - startRegister] / 100,\n        TVOC: response.data[MODBUS_CONFIG.REGISTERS.TVOC - startRegister]\n      };\n    } catch (error) {\n      console.error('Error reading Modbus data:', error);\n      throw error;\n    }\n  }\n\n  // Simulate sensor data for development/testing\n  simulateSensorData() {\n    return {\n      PM25: Math.random() * 50 + 10,\n      CO2: Math.random() * 1000 + 400,\n      TEMPERATURE: Math.random() * 10 + 20,\n      HUMIDITY: Math.random() * 40 + 30,\n      TVOC: Math.random() * 500 + 100\n    };\n  }\n}\nexport default new ModbusService();","map":{"version":3,"names":["ModbusRTU","MODBUS_CONFIG","ModbusService","constructor","client","isConnected","connectionConfig","host","port","timeout","connect","connectTCP","setTimeout","setID","DEVICE_ADDRESS","console","log","error","disconnect","close","readSensorData","Error","registers","Object","values","REGISTERS","startRegister","Math","min","registerCount","max","response","readHoldingRegisters","PM25","data","CO2","TEMPERATURE","HUMIDITY","TVOC","simulateSensorData","random"],"sources":["D:/code projects/iaq-dashboard/src/services/modbusService.js"],"sourcesContent":["import ModbusRTU from 'modbus-serial';\r\nimport { MODBUS_CONFIG } from '../utils/constants.js';\r\n\r\nclass ModbusService {\r\n  constructor() {\r\n    this.client = new ModbusRTU();\r\n    this.isConnected = false;\r\n    this.connectionConfig = {\r\n      host: 'localhost', // Change to your Modbus device IP\r\n      port: 502,\r\n      timeout: 5000\r\n    };\r\n  }\r\n\r\n  async connect() {\r\n    try {\r\n      await this.client.connectTCP(\r\n        this.connectionConfig.host, \r\n        { port: this.connectionConfig.port }\r\n      );\r\n      this.client.setTimeout(this.connectionConfig.timeout);\r\n      this.client.setID(MODBUS_CONFIG.DEVICE_ADDRESS);\r\n      this.isConnected = true;\r\n      console.log('Modbus connection established');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to connect to Modbus device:', error);\r\n      this.isConnected = false;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async disconnect() {\r\n    if (this.isConnected) {\r\n      await this.client.close();\r\n      this.isConnected = false;\r\n      console.log('Modbus connection closed');\r\n    }\r\n  }\r\n\r\n  async readSensorData() {\r\n    if (!this.isConnected) {\r\n      throw new Error('Modbus not connected');\r\n    }\r\n\r\n    try {\r\n      const registers = Object.values(MODBUS_CONFIG.REGISTERS);\r\n      const startRegister = Math.min(...registers);\r\n      const registerCount = Math.max(...registers) - startRegister + 1;\r\n\r\n      const response = await this.client.readHoldingRegisters(startRegister, registerCount);\r\n      \r\n      return {\r\n        PM25: response.data[MODBUS_CONFIG.REGISTERS.PM25 - startRegister] / 100, // Assuming data needs scaling\r\n        CO2: response.data[MODBUS_CONFIG.REGISTERS.CO2 - startRegister],\r\n        TEMPERATURE: response.data[MODBUS_CONFIG.REGISTERS.TEMPERATURE - startRegister] / 100,\r\n        HUMIDITY: response.data[MODBUS_CONFIG.REGISTERS.HUMIDITY - startRegister] / 100,\r\n        TVOC: response.data[MODBUS_CONFIG.REGISTERS.TVOC - startRegister]\r\n      };\r\n    } catch (error) {\r\n      console.error('Error reading Modbus data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Simulate sensor data for development/testing\r\n  simulateSensorData() {\r\n    return {\r\n      PM25: Math.random() * 50 + 10,\r\n      CO2: Math.random() * 1000 + 400,\r\n      TEMPERATURE: Math.random() * 10 + 20,\r\n      HUMIDITY: Math.random() * 40 + 30,\r\n      TVOC: Math.random() * 500 + 100\r\n    };\r\n  }\r\n}\r\n\r\nexport default new ModbusService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}