{"ast":null,"code":"/* eslint-disable no-var */\n\"use strict\";\n\n/**\n * Copyright (c) 2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/**\n * Check the length of request Buffer for length of 8.\n *\n * @param requestBuffer - request Buffer from client\n * @returns {boolean} - if error it is true, otherwise false\n * @private\n */\nfunction _errorRequestBufferLength(requestBuffer) {\n  if (requestBuffer.length !== 8) {\n    modbusSerialDebug(\"request Buffer length \" + requestBuffer.length + \" is wrong - has to be == 8\");\n    return true;\n  }\n  return false; // length is okay - no error\n}\n\n/**\n * Check the length of request Buffer for length of 8.\n *\n * @param requestBuffer - request Buffer from client\n * @returns {boolean} - if error it is true, otherwise false\n * @private\n */\nfunction _errorRequestBufferLengthEnron(requestBuffer) {\n  if (requestBuffer.length !== 10) {\n    modbusSerialDebug(\"request (Enron) Buffer length \" + requestBuffer.length + \" is wrong - has to be == 10\");\n    return true;\n  }\n  return false; // length is okay - no error\n}\n\n/**\n * Handle the callback invocation for Promises or synchronous values\n *\n * @param promiseOrValue - the Promise to be resolved or value to be returned\n * @param cb - the callback to be invoked\n * @returns undefined\n * @private\n */\nfunction _handlePromiseOrValue(promiseOrValue, cb) {\n  if (promiseOrValue && promiseOrValue.then && typeof promiseOrValue.then === \"function\") {\n    promiseOrValue.then(function (value) {\n      cb(null, value);\n    }).catch(function (err) {\n      cb(err);\n    });\n  } else {\n    cb(null, promiseOrValue);\n  }\n}\n\n/**\n * Function to handle FC1 or FC2 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadCoilsOrInputDiscretes(requestBuffer, vector, unitID, callback, fc) {\n  const address = requestBuffer.readUInt16BE(2);\n  const length = requestBuffer.readUInt16BE(4);\n  if (_errorRequestBufferLength(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const dataBytes = parseInt((length - 1) / 8 + 1);\n  const responseBuffer = Buffer.alloc(3 + dataBytes + 2);\n  try {\n    responseBuffer.writeUInt8(dataBytes, 2);\n  } catch (err) {\n    callback(err);\n    return;\n  }\n  const isGetCoil = fc === 1 && vector.getCoil;\n  const isGetDiscreteInpupt = fc === 2 && vector.getDiscreteInput;\n\n  // read coils\n  if (isGetCoil || isGetDiscreteInpupt) {\n    let callbackInvoked = false;\n    let cbCount = 0;\n    const buildCb = function (i) {\n      return function (err, value) {\n        if (err) {\n          if (!callbackInvoked) {\n            callbackInvoked = true;\n            callback(err);\n          }\n          return;\n        }\n        cbCount = cbCount + 1;\n        responseBuffer.writeBit(value, i % 8, 3 + parseInt(i / 8));\n        if (cbCount === length && !callbackInvoked) {\n          modbusSerialDebug({\n            action: \"FC\" + fc + \" response\",\n            responseBuffer: responseBuffer\n          });\n          callbackInvoked = true;\n          callback(null, responseBuffer);\n        }\n      };\n    };\n    if (length === 0) callback({\n      modbusErrorCode: 0x02,\n      // Illegal address\n      msg: \"Invalid length\"\n    });\n    let i = 0;\n    let cb = null;\n    let promiseOrValue = null;\n    if (isGetCoil && vector.getCoil.length === 3) {\n      for (i = 0; i < length; i++) {\n        cb = buildCb(i);\n        try {\n          vector.getCoil(address + i, unitID, cb);\n        } catch (err) {\n          cb(err);\n        }\n      }\n    } else if (isGetDiscreteInpupt && vector.getDiscreteInput.length === 3) {\n      for (i = 0; i < length; i++) {\n        cb = buildCb(i);\n        try {\n          vector.getDiscreteInput(address + i, unitID, cb);\n        } catch (err) {\n          cb(err);\n        }\n      }\n    } else if (isGetCoil) {\n      for (i = 0; i < length; i++) {\n        cb = buildCb(i);\n        try {\n          promiseOrValue = vector.getCoil(address + i, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        } catch (err) {\n          cb(err);\n        }\n      }\n    } else if (isGetDiscreteInpupt) {\n      for (i = 0; i < length; i++) {\n        cb = buildCb(i);\n        try {\n          promiseOrValue = vector.getDiscreteInput(address + i, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        } catch (err) {\n          cb(err);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Function to handle FC3 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadMultipleRegisters(requestBuffer, vector, unitID, callback) {\n  const valueSize = 2;\n  const address = requestBuffer.readUInt16BE(2);\n  const length = requestBuffer.readUInt16BE(4);\n  if (_errorRequestBufferLength(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(3 + length * valueSize + 2);\n  try {\n    responseBuffer.writeUInt8(length * valueSize, 2);\n  } catch (err) {\n    callback(err);\n    return;\n  }\n  let callbackInvoked = false;\n  let cbCount = 0;\n  const buildCb = function (i) {\n    return function (err, value) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      cbCount = cbCount + 1;\n      responseBuffer.writeUInt16BE(value, 3 + i * valueSize);\n      if (cbCount === length && !callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC3 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n  };\n  if (length === 0) callback({\n    modbusErrorCode: 0x02,\n    // Illegal address\n    msg: \"Invalid length\"\n  });\n\n  // read registers\n  function tryAndHandlePromiseOrValue(i, values) {\n    const cb = buildCb(i);\n    try {\n      const promiseOrValue = values[i];\n      _handlePromiseOrValue(promiseOrValue, cb);\n    } catch (err) {\n      cb(err);\n    }\n  }\n  if (vector.getMultipleHoldingRegisters && length > 1) {\n    if (vector.getMultipleHoldingRegisters.length === 4) {\n      vector.getMultipleHoldingRegisters(address, length, unitID, function (err, values) {\n        if (!err && values.length !== length) {\n          const error = new Error(\"Requested address length and response length do not match\");\n          callback(error);\n        } else if (err) {\n          const cb = buildCb(i);\n          try {\n            cb(err); // no need to use value array if there is an error\n          } catch (ex) {\n            cb(ex);\n          }\n        } else {\n          for (var i = 0; i < length; i++) {\n            const cb = buildCb(i);\n            try {\n              cb(err, values[i]);\n            } catch (ex) {\n              cb(ex);\n            }\n          }\n        }\n      });\n    } else {\n      let values;\n      try {\n        values = vector.getMultipleHoldingRegisters(address, length, unitID);\n      } catch (error) {\n        callback(error);\n        return;\n      }\n      if (values.length === length) {\n        for (i = 0; i < length; i++) {\n          tryAndHandlePromiseOrValue(i, values);\n        }\n      } else {\n        const error = new Error(\"Requested address length and response length do not match\");\n        callback(error);\n      }\n    }\n  } else if (vector.getHoldingRegister) {\n    for (var i = 0; i < length; i++) {\n      const cb = buildCb(i);\n      try {\n        if (vector.getHoldingRegister.length === 3) {\n          vector.getHoldingRegister(address + i, unitID, cb);\n        } else {\n          const promiseOrValue = vector.getHoldingRegister(address + i, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        }\n      } catch (err) {\n        cb(err);\n      }\n    }\n  }\n}\n\n/**\n * Function to handle FC3 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param enronTables - The enron tables definition\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadMultipleRegistersEnron(requestBuffer, vector, unitID, enronTables, callback) {\n  const valueSize = 4;\n  const address = requestBuffer.readUInt16BE(2);\n  const length = requestBuffer.readUInt16BE(4);\n\n  // Fall back to 16 bit for short integer variables\n  if (address >= enronTables.shortRange[0] && address <= enronTables.shortRange[1]) {\n    return _handleReadMultipleRegisters(requestBuffer, vector, unitID, callback);\n  }\n  if (_errorRequestBufferLength(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(3 + length * valueSize + 2);\n  try {\n    responseBuffer.writeUInt8(length * valueSize, 2);\n  } catch (err) {\n    callback(err);\n    return;\n  }\n  let callbackInvoked = false;\n  let cbCount = 0;\n  const buildCb = function (i) {\n    return function (err, value) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      cbCount = cbCount + 1;\n      responseBuffer.writeUInt32BE(value, 3 + i * valueSize);\n      if (cbCount === length && !callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC3 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n  };\n  if (length === 0) callback({\n    modbusErrorCode: 0x02,\n    // Illegal address\n    msg: \"Invalid length\"\n  });\n\n  // read registers\n  function tryAndHandlePromiseOrValue(i, values) {\n    const cb = buildCb(i);\n    try {\n      const promiseOrValue = values[i];\n      _handlePromiseOrValue(promiseOrValue, cb);\n    } catch (err) {\n      cb(err);\n    }\n  }\n  if (vector.getMultipleHoldingRegisters && length > 1) {\n    if (vector.getMultipleHoldingRegisters.length === 4) {\n      vector.getMultipleHoldingRegisters(address, length, unitID, function (err, values) {\n        if (!err && values.length !== length) {\n          const error = new Error(\"Requested address length and response length do not match\");\n          callback(error);\n        } else if (err) {\n          const cb = buildCb(i);\n          try {\n            cb(err); // no need to use value array if there is an error\n          } catch (ex) {\n            cb(ex);\n          }\n        } else {\n          for (var i = 0; i < length; i++) {\n            const cb = buildCb(i);\n            try {\n              cb(err, values[i]);\n            } catch (ex) {\n              cb(ex);\n            }\n          }\n        }\n      });\n    } else {\n      let values;\n      try {\n        values = vector.getMultipleHoldingRegisters(address, length, unitID);\n      } catch (error) {\n        callback(error);\n        return;\n      }\n      if (values.length === length) {\n        for (i = 0; i < length; i++) {\n          tryAndHandlePromiseOrValue(i, values);\n        }\n      } else {\n        const error = new Error(\"Requested address length and response length do not match\");\n        callback(error);\n      }\n    }\n  } else if (vector.getHoldingRegister) {\n    for (var i = 0; i < length; i++) {\n      const cb = buildCb(i);\n      try {\n        if (vector.getHoldingRegister.length === 3) {\n          vector.getHoldingRegister(address + i, unitID, cb);\n        } else {\n          const promiseOrValue = vector.getHoldingRegister(address + i, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        }\n      } catch (err) {\n        cb(err);\n      }\n    }\n  }\n}\n\n/**\n * Function to handle FC4 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadInputRegisters(requestBuffer, vector, unitID, callback) {\n  const address = requestBuffer.readUInt16BE(2);\n  const length = requestBuffer.readUInt16BE(4);\n  if (_errorRequestBufferLength(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(3 + length * 2 + 2);\n  try {\n    responseBuffer.writeUInt8(length * 2, 2);\n  } catch (err) {\n    callback(err);\n    return;\n  }\n  let callbackInvoked = false;\n  let cbCount = 0;\n  const buildCb = function (i) {\n    return function (err, value) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      cbCount = cbCount + 1;\n      responseBuffer.writeUInt16BE(value, 3 + i * 2);\n      if (cbCount === length && !callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC4 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n  };\n  if (length === 0) callback({\n    modbusErrorCode: 0x02,\n    // Illegal address\n    msg: \"Invalid length\"\n  });\n  function tryAndHandlePromiseOrValues(i, values) {\n    const cb = buildCb(i);\n    try {\n      const promiseOrValue = values[i];\n      _handlePromiseOrValue(promiseOrValue, cb);\n    } catch (err) {\n      cb(err);\n    }\n  }\n  if (vector.getMultipleInputRegisters && length > 1) {\n    if (vector.getMultipleInputRegisters.length === 4) {\n      vector.getMultipleInputRegisters(address, length, unitID, function (err, values) {\n        if (!err && values.length !== length) {\n          const error = new Error(\"Requested address length and response length do not match\");\n          callback(error);\n        } else {\n          for (let i = 0; i < length; i++) {\n            const cb = buildCb(i);\n            try {\n              cb(err, values[i]);\n            } catch (ex) {\n              cb(ex);\n            }\n          }\n        }\n      });\n    } else {\n      let values;\n      try {\n        values = vector.getMultipleInputRegisters(address, length, unitID);\n      } catch (error) {\n        callback(error);\n        return;\n      }\n      if (values.length === length) {\n        for (var i = 0; i < length; i++) {\n          tryAndHandlePromiseOrValues(i, values);\n        }\n      } else {\n        const error = new Error(\"Requested address length and response length do not match\");\n        callback(error);\n      }\n    }\n  } else if (vector.getInputRegister) {\n    for (i = 0; i < length; i++) {\n      const cb = buildCb(i);\n      try {\n        if (vector.getInputRegister.length === 3) {\n          vector.getInputRegister(address + i, unitID, cb);\n        } else {\n          const promiseOrValue = vector.getInputRegister(address + i, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        }\n      } catch (ex) {\n        cb(ex);\n      }\n    }\n  }\n}\n\n/**\n * Function to handle FC5 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteCoil(requestBuffer, vector, unitID, callback) {\n  const address = requestBuffer.readUInt16BE(2);\n  const state = requestBuffer.readUInt16BE(4);\n  if (_errorRequestBufferLength(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(8);\n  responseBuffer.writeUInt16BE(address, 2);\n  responseBuffer.writeUInt16BE(state, 4);\n  if (vector.setCoil) {\n    let callbackInvoked = false;\n    const cb = function (err) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      if (!callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC5 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n    try {\n      if (vector.setCoil.length === 4) {\n        vector.setCoil(address, state === 0xff00, unitID, cb);\n      } else {\n        const promiseOrValue = vector.setCoil(address, state === 0xff00, unitID);\n        _handlePromiseOrValue(promiseOrValue, cb);\n      }\n    } catch (err) {\n      cb(err);\n    }\n  }\n}\n\n/**\n * Function to handle FC6 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteSingleRegister(requestBuffer, vector, unitID, callback) {\n  const address = requestBuffer.readUInt16BE(2);\n  const value = requestBuffer.readUInt16BE(4);\n  if (_errorRequestBufferLength(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(8);\n  responseBuffer.writeUInt16BE(address, 2);\n  responseBuffer.writeUInt16BE(value, 4);\n  if (vector.setRegister) {\n    let callbackInvoked = false;\n    const cb = function (err) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      if (!callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC6 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n    try {\n      if (vector.setRegister.length === 4) {\n        vector.setRegister(address, value, unitID, cb);\n      } else {\n        const promiseOrValue = vector.setRegister(address, value, unitID);\n        _handlePromiseOrValue(promiseOrValue, cb);\n      }\n    } catch (err) {\n      cb(err);\n    }\n  }\n}\n\n/**\n * Function to handle FC6 (Enron) request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param enronTables - The enron tables definition\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteSingleRegisterEnron(requestBuffer, vector, unitID, enronTables, callback) {\n  const address = requestBuffer.readUInt16BE(2);\n  const value = requestBuffer.readUInt32BE(4);\n\n  // Fall back to 16 bit for short integer variables\n  if (address >= enronTables.shortRange[0] && address <= enronTables.shortRange[1]) {\n    return _handleWriteSingleRegister(requestBuffer, vector, unitID, callback);\n  }\n  if (_errorRequestBufferLengthEnron(requestBuffer)) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(10);\n  responseBuffer.writeUInt16BE(address, 2);\n  responseBuffer.writeUInt32BE(value, 4);\n  if (vector.setRegister) {\n    let callbackInvoked = false;\n    const cb = function (err) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      if (!callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC6 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n    try {\n      if (vector.setRegister.length === 4) {\n        vector.setRegister(address, value, unitID, cb);\n      } else {\n        const promiseOrValue = vector.setRegister(address, value, unitID);\n        _handlePromiseOrValue(promiseOrValue, cb);\n      }\n    } catch (err) {\n      cb(err);\n    }\n  }\n}\n\n/**\n * Function to handle FC15 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleForceMultipleCoils(requestBuffer, vector, unitID, callback) {\n  const address = requestBuffer.readUInt16BE(2);\n  const length = requestBuffer.readUInt16BE(4);\n\n  // if length is bad, ignore message\n  if (requestBuffer.length !== 7 + Math.ceil(length / 8) + 2) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(8);\n  responseBuffer.writeUInt16BE(address, 2);\n  responseBuffer.writeUInt16BE(length, 4);\n  let callbackInvoked = false;\n  let cbCount = 0;\n  const buildCb = function /* i - not used at the moment */\n  () {\n    return function (err) {\n      if (err) {\n        if (!callbackInvoked) {\n          callbackInvoked = true;\n          callback(err);\n        }\n        return;\n      }\n      cbCount = cbCount + 1;\n      if (cbCount === length && !callbackInvoked) {\n        modbusSerialDebug({\n          action: \"FC15 response\",\n          responseBuffer: responseBuffer\n        });\n        callbackInvoked = true;\n        callback(null, responseBuffer);\n      }\n    };\n  };\n  if (length === 0) callback({\n    modbusErrorCode: 0x02,\n    // Illegal address\n    msg: \"Invalid length\"\n  });\n  if (vector.setCoilArray) {\n    const state = [];\n    for (i = 0; i < length; i++) {\n      cb = buildCb(i);\n      state.push(requestBuffer.readBit(i, 7));\n      _handlePromiseOrValue(promiseOrValue, cb);\n    }\n    try {\n      if (vector.setCoilArray.length === 4) {\n        vector.setCoilArray(address, state, unitID, cb);\n      } else {\n        vector.setCoilArray(address, state, unitID);\n      }\n    } catch (err) {\n      cb(err);\n    }\n  } else if (vector.setCoil) {\n    let state;\n    for (var i = 0; i < length; i++) {\n      var cb = buildCb(i);\n      state = requestBuffer.readBit(i, 7);\n      try {\n        if (vector.setCoil.length === 4) {\n          vector.setCoil(address + i, state !== false, unitID, cb);\n        } else {\n          var promiseOrValue = vector.setCoil(address + i, state !== false, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        }\n      } catch (err) {\n        cb(err);\n      }\n    }\n  }\n}\n/**\n * Function to handle FC16 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteMultipleRegisters(requestBuffer, vector, unitID, callback) {\n  const address = requestBuffer.readUInt16BE(2);\n  const length = requestBuffer.readUInt16BE(4);\n\n  // if length is bad, ignore message\n  if (requestBuffer.length !== 7 + length * 2 + 2) {\n    return;\n  }\n\n  // build answer\n  const responseBuffer = Buffer.alloc(8);\n  responseBuffer.writeUInt16BE(address, 2);\n  responseBuffer.writeUInt16BE(length, 4);\n\n  // write registers\n  let callbackInvoked = false;\n  const cb = function (err) {\n    if (err) {\n      if (!callbackInvoked) {\n        callbackInvoked = true;\n        callback(err);\n      }\n      return;\n    }\n    if (!callbackInvoked) {\n      modbusSerialDebug({\n        action: \"FC16 response\",\n        responseBuffer: responseBuffer\n      });\n      callbackInvoked = true;\n      callback(null, responseBuffer);\n    }\n  };\n  if (length === 0) callback({\n    modbusErrorCode: 0x02,\n    // Illegal address\n    msg: \"Invalid length\"\n  });\n  if (vector.setRegisterArray) {\n    value = [];\n    try {\n      for (i = 0; i < length; i++) {\n        value.push(requestBuffer.readUInt16BE(7 + i * 2));\n      }\n      if (vector.setRegisterArray.length === 4) {\n        vector.setRegisterArray(address, value, unitID, cb);\n      } else {\n        var promiseOrValue = vector.setRegisterArray(address, value, unitID);\n        _handlePromiseOrValue(promiseOrValue, cb);\n      }\n    } catch (err) {\n      cb(err);\n    }\n  } else if (vector.setRegister) {\n    var value;\n    for (var i = 0; i < length; i++) {\n      try {\n        value = requestBuffer.readUInt16BE(7 + i * 2);\n        if (vector.setRegister.length === 4) {\n          vector.setRegister(address + i, value, unitID, cb);\n        } else {\n          const promiseOrValue = vector.setRegister(address + i, value, unitID);\n          _handlePromiseOrValue(promiseOrValue, cb);\n        }\n      } catch (err) {\n        cb(err);\n      }\n    }\n  }\n}\n\n/**\n * Function to handle FC17 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReportServerID(requestBuffer, vector, unitID, callback) {\n  if (!vector.reportServerID) {\n    callback({\n      modbusErrorCode: 0x01\n    });\n    return;\n  }\n\n  // build answer\n  const promiseOrValue = vector.reportServerID(unitID);\n  _handlePromiseOrValue(promiseOrValue, function (err, value) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (!value) {\n      callback({\n        modbusErrorCode: 0x01,\n        msg: \"Report Server ID not supported by device\"\n      });\n      return;\n    }\n    if (!value.id || !value.running) {\n      callback({\n        modbusErrorCode: 0x04,\n        msg: \"Invalid content provided for Report Server ID: \" + JSON.stringify(value)\n      });\n      return;\n    }\n    const id = value.id;\n    const running = value.running;\n    const additionalData = value.additionalData;\n    let contentLength = 2; // serverID + Running\n    if (additionalData) {\n      contentLength += additionalData.length;\n    }\n    const totalLength = 3 + contentLength + 2; // UnitID + FC + Byte-Count + Content-Length + CRC\n\n    let i = 2;\n    const responseBuffer = Buffer.alloc(totalLength);\n    i = responseBuffer.writeUInt8(contentLength, i);\n    i = responseBuffer.writeUInt8(id, i);\n    if (running === true) {\n      i = responseBuffer.writeUInt8(0xFF, i);\n    } else {\n      i += 1;\n    }\n    if (additionalData) {\n      additionalData.copy(responseBuffer, i);\n    }\n    callback(null, responseBuffer);\n  });\n}\n\n/**\n * Function to handle FC43 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleMEI(requestBuffer, vector, unitID, callback) {\n  const MEIType = requestBuffer[2];\n  switch (parseInt(MEIType)) {\n    case 14:\n      _handleReadDeviceIdentification(requestBuffer, vector, unitID, callback);\n      break;\n    default:\n      callback({\n        modbusErrorCode: 0x01\n      });\n    // illegal MEI type\n  }\n}\n\n/**\n * Function to handle FC43/14 MEI request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadDeviceIdentification(requestBuffer, vector, unitID, callback) {\n  const PDULenMax = 253;\n  const MEI14HeaderLen = 6;\n  const stringLengthMax = PDULenMax - MEI14HeaderLen - 2;\n  if (!vector.readDeviceIdentification) {\n    callback({\n      modbusErrorCode: 0x01\n    });\n    return;\n  }\n  const readDeviceIDCode = requestBuffer.readUInt8(3);\n  let objectID = requestBuffer.readUInt8(4);\n\n  // Basic request parameters checks\n  switch (readDeviceIDCode) {\n    case 0x01:\n      if (objectID > 0x02 || objectID > 0x06 && objectID < 0x80) objectID = 0x00;\n      break;\n    case 0x02:\n      if (objectID >= 0x80 || objectID > 0x06 && objectID < 0x80) objectID = 0x00;\n      break;\n    case 0x03:\n      if (objectID > 0x06 && objectID < 0x80) objectID = 0x00;\n      break;\n    case 0x04:\n      if (objectID > 0x06 && objectID < 0x80) {\n        callback({\n          modbusErrorCode: 0x02\n        });\n        return;\n      }\n      break;\n    default:\n      callback({\n        modbusErrorCode: 0x03\n      });\n      return;\n  }\n\n  // Filling mandatory basic device identification objects\n  const objects = {\n    0x00: \"undefined\",\n    0x01: \"undefined\",\n    0x02: \"undefined\"\n  };\n  const pkg = require(\"../package.json\");\n  if (pkg) {\n    if (pkg.author) objects[0x00] = pkg.author;\n    if (pkg.name) objects[0x01] = pkg.name;\n    if (pkg.version) objects[0x02] = pkg.version;\n  }\n  const promiseOrValue = vector.readDeviceIdentification(unitID);\n  _handlePromiseOrValue(promiseOrValue, function (err, value) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const userObjects = value;\n    for (const o of Object.keys(userObjects)) {\n      const i = parseInt(o);\n      if (!isNaN(i) && i >= 0 && i <= 255) objects[i] = userObjects[o];\n    }\n\n    // Checking the existence of the requested objectID\n    if (!objects[objectID]) {\n      if (readDeviceIDCode === 0x04) {\n        callback({\n          modbusErrorCode: 0x02\n        });\n        return;\n      }\n      objectID = 0x00;\n    }\n    const ids = [];\n    let totalLength = 2 + MEI14HeaderLen + 2; // UnitID + FC + MEI14Header + CRC\n    let lastID = 0;\n    let conformityLevel = 0x81;\n    const supportedIDs = Object.keys(objects);\n\n    // Filtering of objects and Conformity level determination\n    for (var id of supportedIDs) {\n      id = parseInt(id);\n      if (isNaN(id)) continue;\n\n      // Enforcing valid object IDs from the user\n      if (id < 0x00 || id > 0x06 && id < 0x80 || id > 0xFF) {\n        callback({\n          modbusErrorCode: 0x04,\n          msg: \"Invalid Object ID provided for Read Device Identification: \" + id\n        });\n      }\n      if (id > 0x02) conformityLevel = 0x82;\n      if (id > 0x80) conformityLevel = 0x83;\n\n      // Starting from requested object ID\n      if (objectID > id) continue;\n\n      // Enforcing maximum string length\n      if (objects[id].length > stringLengthMax) {\n        callback({\n          modbusErrorCode: 0x04,\n          msg: \"Read Device Identification string size can be maximum \" + stringLengthMax\n        });\n      }\n      if (lastID !== 0) continue;\n      if (objects[id].length + 2 > PDULenMax - totalLength) {\n        if (lastID === 0) lastID = id;\n      } else {\n        totalLength += objects[id].length + 2;\n        ids.push(id);\n\n        // Requested a single object\n        if (readDeviceIDCode === 0x04) break;\n      }\n    }\n    ids.sort((a, b) => parseInt(a) - parseInt(b));\n    const responseBuffer = Buffer.alloc(totalLength);\n    let i = 2;\n    i = responseBuffer.writeUInt8(14, i); // MEI type\n    i = responseBuffer.writeUInt8(readDeviceIDCode, i);\n    i = responseBuffer.writeUInt8(conformityLevel, i);\n    if (lastID === 0)\n      // More follows\n      i = responseBuffer.writeUInt8(0x00, i);else i = responseBuffer.writeUInt8(0xFF, i);\n    i = responseBuffer.writeUInt8(lastID, i); // Next Object Id\n    i = responseBuffer.writeUInt8(ids.length, i); // Number of objects\n\n    for (id of ids) {\n      i = responseBuffer.writeUInt8(id, i); // Object id\n      i = responseBuffer.writeUInt8(objects[id].length, i); // Object length\n      i += responseBuffer.write(objects[id], i, objects[id].length); // Object value\n    }\n    callback(null, responseBuffer);\n  });\n}\n\n/**\n * Exports\n */\nmodule.exports = {\n  readCoilsOrInputDiscretes: _handleReadCoilsOrInputDiscretes,\n  readMultipleRegisters: _handleReadMultipleRegisters,\n  readMultipleRegistersEnron: _handleReadMultipleRegistersEnron,\n  readInputRegisters: _handleReadInputRegisters,\n  writeCoil: _handleWriteCoil,\n  writeSingleRegister: _handleWriteSingleRegister,\n  writeSingleRegisterEnron: _handleWriteSingleRegisterEnron,\n  forceMultipleCoils: _handleForceMultipleCoils,\n  writeMultipleRegisters: _handleWriteMultipleRegisters,\n  reportServerID: _handleReportServerID,\n  handleMEI: _handleMEI\n};","map":{"version":3,"names":["modbusSerialDebug","require","_errorRequestBufferLength","requestBuffer","length","_errorRequestBufferLengthEnron","_handlePromiseOrValue","promiseOrValue","cb","then","value","catch","err","_handleReadCoilsOrInputDiscretes","vector","unitID","callback","fc","address","readUInt16BE","dataBytes","parseInt","responseBuffer","Buffer","alloc","writeUInt8","isGetCoil","getCoil","isGetDiscreteInpupt","getDiscreteInput","callbackInvoked","cbCount","buildCb","i","writeBit","action","modbusErrorCode","msg","_handleReadMultipleRegisters","valueSize","writeUInt16BE","tryAndHandlePromiseOrValue","values","getMultipleHoldingRegisters","error","Error","ex","getHoldingRegister","_handleReadMultipleRegistersEnron","enronTables","shortRange","writeUInt32BE","_handleReadInputRegisters","tryAndHandlePromiseOrValues","getMultipleInputRegisters","getInputRegister","_handleWriteCoil","state","setCoil","_handleWriteSingleRegister","setRegister","_handleWriteSingleRegisterEnron","readUInt32BE","_handleForceMultipleCoils","Math","ceil","setCoilArray","push","readBit","_handleWriteMultipleRegisters","setRegisterArray","_handleReportServerID","reportServerID","id","running","JSON","stringify","additionalData","contentLength","totalLength","copy","_handleMEI","MEIType","_handleReadDeviceIdentification","PDULenMax","MEI14HeaderLen","stringLengthMax","readDeviceIdentification","readDeviceIDCode","readUInt8","objectID","objects","pkg","author","name","version","userObjects","o","Object","keys","isNaN","ids","lastID","conformityLevel","supportedIDs","sort","a","b","write","module","exports","readCoilsOrInputDiscretes","readMultipleRegisters","readMultipleRegistersEnron","readInputRegisters","writeCoil","writeSingleRegister","writeSingleRegisterEnron","forceMultipleCoils","writeMultipleRegisters","handleMEI"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/servers/servertcp_handler.js"],"sourcesContent":["/* eslint-disable no-var */\n\"use strict\";\n/**\n * Copyright (c) 2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/**\n * Check the length of request Buffer for length of 8.\n *\n * @param requestBuffer - request Buffer from client\n * @returns {boolean} - if error it is true, otherwise false\n * @private\n */\nfunction _errorRequestBufferLength(requestBuffer) {\n\n    if (requestBuffer.length !== 8) {\n        modbusSerialDebug(\"request Buffer length \" + requestBuffer.length + \" is wrong - has to be == 8\");\n        return true;\n    }\n\n    return false; // length is okay - no error\n}\n\n/**\n * Check the length of request Buffer for length of 8.\n *\n * @param requestBuffer - request Buffer from client\n * @returns {boolean} - if error it is true, otherwise false\n * @private\n */\nfunction _errorRequestBufferLengthEnron(requestBuffer) {\n\n    if (requestBuffer.length !== 10) {\n        modbusSerialDebug(\"request (Enron) Buffer length \" + requestBuffer.length + \" is wrong - has to be == 10\");\n        return true;\n    }\n\n    return false; // length is okay - no error\n}\n\n/**\n * Handle the callback invocation for Promises or synchronous values\n *\n * @param promiseOrValue - the Promise to be resolved or value to be returned\n * @param cb - the callback to be invoked\n * @returns undefined\n * @private\n */\nfunction _handlePromiseOrValue(promiseOrValue, cb) {\n    if (promiseOrValue && promiseOrValue.then && typeof promiseOrValue.then === \"function\") {\n        promiseOrValue\n            .then(function(value) {\n                cb(null, value);\n            })\n            .catch(function(err) {\n                cb(err);\n            });\n    }  else {\n        cb(null, promiseOrValue);\n    }\n}\n\n\n/**\n * Function to handle FC1 or FC2 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadCoilsOrInputDiscretes(requestBuffer, vector, unitID, callback, fc) {\n    const address = requestBuffer.readUInt16BE(2);\n    const length = requestBuffer.readUInt16BE(4);\n\n    if (_errorRequestBufferLength(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const dataBytes = parseInt((length - 1) / 8 + 1);\n    const responseBuffer = Buffer.alloc(3 + dataBytes + 2);\n    try {\n        responseBuffer.writeUInt8(dataBytes, 2);\n    }\n    catch (err) {\n        callback(err);\n        return;\n    }\n\n    const isGetCoil = (fc === 1 && vector.getCoil);\n    const isGetDiscreteInpupt = (fc === 2 && vector.getDiscreteInput);\n\n    // read coils\n    if (isGetCoil || isGetDiscreteInpupt) {\n        let callbackInvoked = false;\n        let cbCount = 0;\n        const buildCb = function(i) {\n            return function(err, value) {\n                if (err) {\n                    if (!callbackInvoked) {\n                        callbackInvoked = true;\n                        callback(err);\n                    }\n\n                    return;\n                }\n\n                cbCount = cbCount + 1;\n\n                responseBuffer.writeBit(value, i % 8, 3 + parseInt(i / 8));\n\n                if (cbCount === length && !callbackInvoked) {\n                    modbusSerialDebug({ action: \"FC\" + fc + \" response\", responseBuffer: responseBuffer });\n\n                    callbackInvoked = true;\n                    callback(null, responseBuffer);\n                }\n            };\n        };\n\n        if (length === 0)\n            callback({\n                modbusErrorCode: 0x02, // Illegal address\n                msg: \"Invalid length\"\n            });\n\n        let i = 0;\n        let cb = null;\n        let promiseOrValue = null;\n\n        if (isGetCoil && vector.getCoil.length === 3) {\n            for (i = 0; i < length; i++) {\n                cb = buildCb(i);\n                try {\n                    vector.getCoil(address + i, unitID, cb);\n                }\n                catch(err) {\n                    cb(err);\n                }\n            }\n        }\n        else if (isGetDiscreteInpupt && vector.getDiscreteInput.length === 3) {\n            for (i = 0; i < length; i++) {\n                cb = buildCb(i);\n                try {\n                    vector.getDiscreteInput(address + i, unitID, cb);\n                }\n                catch(err) {\n                    cb(err);\n                }\n            }\n        }\n        else if (isGetCoil) {\n            for (i = 0; i < length; i++) {\n                cb = buildCb(i);\n                try {\n                    promiseOrValue = vector.getCoil(address + i, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n                catch(err) {\n                    cb(err);\n                }\n            }\n        }\n        else if (isGetDiscreteInpupt) {\n            for (i = 0; i < length; i++) {\n                cb = buildCb(i);\n                try {\n                    promiseOrValue = vector.getDiscreteInput(address + i, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n                catch(err) {\n                    cb(err);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Function to handle FC3 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadMultipleRegisters(requestBuffer, vector, unitID, callback) {\n    const valueSize = 2;\n    const address = requestBuffer.readUInt16BE(2);\n    const length = requestBuffer.readUInt16BE(4);\n\n    if (_errorRequestBufferLength(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(3 + (length * valueSize) + 2);\n    try {\n        responseBuffer.writeUInt8(length * valueSize, 2);\n    }\n    catch (err) {\n        callback(err);\n        return;\n    }\n\n    let callbackInvoked = false;\n    let cbCount = 0;\n    const buildCb = function(i) {\n        return function(err, value) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            cbCount = cbCount + 1;\n\n            responseBuffer.writeUInt16BE(value, 3 + (i * valueSize));\n\n            if (cbCount === length && !callbackInvoked) {\n                modbusSerialDebug({ action: \"FC3 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n    };\n\n    if (length === 0)\n        callback({\n            modbusErrorCode: 0x02, // Illegal address\n            msg: \"Invalid length\"\n        });\n\n    // read registers\n    function tryAndHandlePromiseOrValue(i, values) {\n        const cb = buildCb(i);\n        try {\n            const promiseOrValue = values[i];\n            _handlePromiseOrValue(promiseOrValue, cb);\n        }\n        catch (err) {\n            cb(err);\n        }\n    }\n\n    if (vector.getMultipleHoldingRegisters && length > 1) {\n\n        if (vector.getMultipleHoldingRegisters.length === 4) {\n            vector.getMultipleHoldingRegisters(address, length, unitID, function(err, values) {\n                if (!err && values.length !== length) {\n                    const error = new Error(\"Requested address length and response length do not match\");\n                    callback(error);\n                } else if (err) {\n                    const cb = buildCb(i);\n                    try {\n                        cb(err); // no need to use value array if there is an error\n                    }\n                    catch (ex) {\n                        cb(ex);\n                    }\n                }\n                else {\n                    for (var i = 0; i < length; i++) {\n                        const cb = buildCb(i);\n                        try {\n                            cb(err, values[i]);\n                        }\n                        catch (ex) {\n                            cb(ex);\n                        }\n                    }\n                }\n            });\n        } else {\n            let values;\n            try {\n                values = vector.getMultipleHoldingRegisters(address, length, unitID);\n            } catch (error) {\n                callback(error);\n                return;\n            }\n            if (values.length === length) {\n                for (i = 0; i < length; i++) {\n                    tryAndHandlePromiseOrValue(i, values);\n                }\n            } else {\n                const error = new Error(\"Requested address length and response length do not match\");\n                callback(error);\n            }\n        }\n\n    }\n    else if (vector.getHoldingRegister) {\n        for (var i = 0; i < length; i++) {\n            const cb = buildCb(i);\n            try {\n                if (vector.getHoldingRegister.length === 3) {\n                    vector.getHoldingRegister(address + i, unitID, cb);\n                } else {\n                    const promiseOrValue = vector.getHoldingRegister(address + i, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n            }\n            catch (err) {\n                cb(err);\n            }\n        }\n    }\n}\n\n/**\n * Function to handle FC3 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param enronTables - The enron tables definition\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadMultipleRegistersEnron(requestBuffer, vector, unitID, enronTables, callback) {\n    const valueSize = 4;\n    const address = requestBuffer.readUInt16BE(2);\n    const length = requestBuffer.readUInt16BE(4);\n\n    // Fall back to 16 bit for short integer variables\n    if (address >= enronTables.shortRange[0] && address <= enronTables.shortRange[1]) {\n        return _handleReadMultipleRegisters(requestBuffer, vector, unitID, callback);\n    }\n\n    if (_errorRequestBufferLength(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(3 + (length * valueSize) + 2);\n    try {\n        responseBuffer.writeUInt8(length * valueSize, 2);\n    }\n    catch (err) {\n        callback(err);\n        return;\n    }\n\n    let callbackInvoked = false;\n    let cbCount = 0;\n    const buildCb = function(i) {\n        return function(err, value) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            cbCount = cbCount + 1;\n\n            responseBuffer.writeUInt32BE(value, 3 + (i * valueSize));\n\n            if (cbCount === length && !callbackInvoked) {\n                modbusSerialDebug({ action: \"FC3 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n    };\n\n    if (length === 0)\n        callback({\n            modbusErrorCode: 0x02, // Illegal address\n            msg: \"Invalid length\"\n        });\n\n    // read registers\n    function tryAndHandlePromiseOrValue(i, values) {\n        const cb = buildCb(i);\n        try {\n            const promiseOrValue = values[i];\n            _handlePromiseOrValue(promiseOrValue, cb);\n        }\n        catch (err) {\n            cb(err);\n        }\n    }\n\n    if (vector.getMultipleHoldingRegisters && length > 1) {\n\n        if (vector.getMultipleHoldingRegisters.length === 4) {\n            vector.getMultipleHoldingRegisters(address, length, unitID, function(err, values) {\n                if (!err && values.length !== length) {\n                    const error = new Error(\"Requested address length and response length do not match\");\n                    callback(error);\n                } else if (err) {\n                    const cb = buildCb(i);\n                    try {\n                        cb(err); // no need to use value array if there is an error\n                    }\n                    catch (ex) {\n                        cb(ex);\n                    }\n                }\n                else {\n                    for (var i = 0; i < length; i++) {\n                        const cb = buildCb(i);\n                        try {\n                            cb(err, values[i]);\n                        }\n                        catch (ex) {\n                            cb(ex);\n                        }\n                    }\n                }\n            });\n        } else {\n            let values;\n            try {\n                values = vector.getMultipleHoldingRegisters(address, length, unitID);\n            } catch (error) {\n                callback(error);\n                return;\n            }\n            if (values.length === length) {\n                for (i = 0; i < length; i++) {\n                    tryAndHandlePromiseOrValue(i, values);\n                }\n            } else {\n                const error = new Error(\"Requested address length and response length do not match\");\n                callback(error);\n            }\n        }\n\n    }\n    else if (vector.getHoldingRegister) {\n        for (var i = 0; i < length; i++) {\n            const cb = buildCb(i);\n            try {\n                if (vector.getHoldingRegister.length === 3) {\n                    vector.getHoldingRegister(address + i, unitID, cb);\n                } else {\n                    const promiseOrValue = vector.getHoldingRegister(address + i, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n            }\n            catch (err) {\n                cb(err);\n            }\n        }\n    }\n}\n\n/**\n * Function to handle FC4 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadInputRegisters(requestBuffer, vector, unitID, callback) {\n    const address = requestBuffer.readUInt16BE(2);\n    const length = requestBuffer.readUInt16BE(4);\n\n    if (_errorRequestBufferLength(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(3 + length * 2 + 2);\n    try {\n        responseBuffer.writeUInt8(length * 2, 2);\n    }\n    catch (err) {\n        callback(err);\n        return;\n    }\n\n    let callbackInvoked = false;\n    let cbCount = 0;\n    const buildCb = function(i) {\n        return function(err, value) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            cbCount = cbCount + 1;\n\n            responseBuffer.writeUInt16BE(value, 3 + i * 2);\n\n            if (cbCount === length && !callbackInvoked) {\n                modbusSerialDebug({ action: \"FC4 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n    };\n\n    if (length === 0)\n        callback({\n            modbusErrorCode: 0x02, // Illegal address\n            msg: \"Invalid length\"\n        });\n\n    function tryAndHandlePromiseOrValues(i, values) {\n        const cb = buildCb(i);\n        try {\n            const promiseOrValue = values[i];\n            _handlePromiseOrValue(promiseOrValue, cb);\n        }\n        catch (err) {\n            cb(err);\n        }\n    }\n\n    if (vector.getMultipleInputRegisters && length > 1) {\n\n        if (vector.getMultipleInputRegisters.length === 4) {\n            vector.getMultipleInputRegisters(address, length, unitID, function(err, values) {\n                if (!err && values.length !== length) {\n                    const error = new Error(\"Requested address length and response length do not match\");\n                    callback(error);\n                } else {\n                    for (let i = 0; i < length; i++) {\n                        const cb = buildCb(i);\n                        try {\n                            cb(err, values[i]);\n                        }\n                        catch (ex) {\n                            cb(ex);\n                        }\n                    }\n                }\n            });\n        } else {\n            let values;\n\n            try {\n                values = vector.getMultipleInputRegisters(address, length, unitID);\n            } catch (error) {\n                callback(error);\n                return;\n            }\n\n            if (values.length === length) {\n                for (var i = 0; i < length; i++) {\n                    tryAndHandlePromiseOrValues(i, values);\n                }\n            } else {\n                const error = new Error(\"Requested address length and response length do not match\");\n                callback(error);\n            }\n        }\n\n    }\n    else if (vector.getInputRegister) {\n\n        for (i = 0; i < length; i++) {\n            const cb = buildCb(i);\n            try {\n                if (vector.getInputRegister.length === 3) {\n                    vector.getInputRegister(address + i, unitID, cb);\n                }\n                else {\n                    const promiseOrValue = vector.getInputRegister(address + i, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n            }\n            catch (ex) {\n                cb(ex);\n            }\n        }\n    }\n}\n\n/**\n * Function to handle FC5 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteCoil(requestBuffer, vector, unitID, callback) {\n    const address = requestBuffer.readUInt16BE(2);\n    const state = requestBuffer.readUInt16BE(4);\n\n    if (_errorRequestBufferLength(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(8);\n    responseBuffer.writeUInt16BE(address, 2);\n    responseBuffer.writeUInt16BE(state, 4);\n\n    if (vector.setCoil) {\n        let callbackInvoked = false;\n        const cb = function(err) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            if (!callbackInvoked) {\n                modbusSerialDebug({ action: \"FC5 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n\n        try {\n            if (vector.setCoil.length === 4) {\n                vector.setCoil(address, state === 0xff00, unitID, cb);\n            }\n            else {\n                const promiseOrValue = vector.setCoil(address, state === 0xff00, unitID);\n                _handlePromiseOrValue(promiseOrValue, cb);\n            }\n        }\n        catch(err) {\n            cb(err);\n        }\n    }\n}\n\n/**\n * Function to handle FC6 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteSingleRegister(requestBuffer, vector, unitID, callback) {\n    const address = requestBuffer.readUInt16BE(2);\n    const value = requestBuffer.readUInt16BE(4);\n\n    if (_errorRequestBufferLength(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(8);\n    responseBuffer.writeUInt16BE(address, 2);\n    responseBuffer.writeUInt16BE(value, 4);\n\n    if (vector.setRegister) {\n        let callbackInvoked = false;\n        const cb = function(err) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            if (!callbackInvoked) {\n                modbusSerialDebug({ action: \"FC6 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n\n        try {\n            if (vector.setRegister.length === 4) {\n                vector.setRegister(address, value, unitID, cb);\n            }\n            else {\n                const promiseOrValue = vector.setRegister(address, value, unitID);\n                _handlePromiseOrValue(promiseOrValue, cb);\n            }\n        } catch(err) {\n            cb(err);\n        }\n    }\n}\n\n/**\n * Function to handle FC6 (Enron) request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param enronTables - The enron tables definition\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteSingleRegisterEnron(requestBuffer, vector, unitID, enronTables, callback) {\n    const address = requestBuffer.readUInt16BE(2);\n    const value = requestBuffer.readUInt32BE(4);\n\n    // Fall back to 16 bit for short integer variables\n    if (address >= enronTables.shortRange[0] && address <= enronTables.shortRange[1]) {\n        return _handleWriteSingleRegister(requestBuffer, vector, unitID, callback);\n    }\n\n    if (_errorRequestBufferLengthEnron(requestBuffer)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(10);\n    responseBuffer.writeUInt16BE(address, 2);\n    responseBuffer.writeUInt32BE(value, 4);\n\n    if (vector.setRegister) {\n        let callbackInvoked = false;\n        const cb = function(err) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            if (!callbackInvoked) {\n                modbusSerialDebug({ action: \"FC6 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n\n        try {\n            if (vector.setRegister.length === 4) {\n                vector.setRegister(address, value, unitID, cb);\n            }\n            else {\n                const promiseOrValue = vector.setRegister(address, value, unitID);\n                _handlePromiseOrValue(promiseOrValue, cb);\n            }\n        } catch(err) {\n            cb(err);\n        }\n    }\n}\n\n/**\n * Function to handle FC15 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleForceMultipleCoils(requestBuffer, vector, unitID, callback) {\n    const address = requestBuffer.readUInt16BE(2);\n    const length = requestBuffer.readUInt16BE(4);\n\n    // if length is bad, ignore message\n    if (requestBuffer.length !== 7 + Math.ceil(length / 8) + 2) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(8);\n    responseBuffer.writeUInt16BE(address, 2);\n    responseBuffer.writeUInt16BE(length, 4);\n\n    let callbackInvoked = false;\n    let cbCount = 0;\n    const buildCb = function(/* i - not used at the moment */) {\n        return function(err) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n\n                return;\n            }\n\n            cbCount = cbCount + 1;\n\n            if (cbCount === length && !callbackInvoked) {\n                modbusSerialDebug({ action: \"FC15 response\", responseBuffer: responseBuffer });\n\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n    };\n\n    if (length === 0)\n        callback({\n            modbusErrorCode: 0x02, // Illegal address\n            msg: \"Invalid length\"\n        });\n\n    if (vector.setCoilArray) {\n        const state = [];\n\n        for (i = 0; i < length; i++) {\n            cb = buildCb(i);\n            state.push(requestBuffer.readBit(i, 7));\n            _handlePromiseOrValue(promiseOrValue, cb);\n        }\n\n        try {\n            if (vector.setCoilArray.length === 4) {\n                vector.setCoilArray(address, state, unitID, cb);\n            }\n            else {\n                vector.setCoilArray(address, state, unitID);\n            }\n        }\n        catch(err) {\n            cb(err);\n        }\n    } else if (vector.setCoil) {\n        let state;\n\n        for (var i = 0; i < length; i++) {\n            var cb = buildCb(i);\n            state = requestBuffer.readBit(i, 7);\n\n            try {\n                if (vector.setCoil.length === 4) {\n                    vector.setCoil(address + i, state !== false, unitID, cb);\n                }\n                else {\n                    var promiseOrValue = vector.setCoil(address + i, state !== false, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n            }\n            catch(err) {\n                cb(err);\n            }\n        }\n    }\n}\n/**\n * Function to handle FC16 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleWriteMultipleRegisters(requestBuffer, vector, unitID, callback) {\n    const address = requestBuffer.readUInt16BE(2);\n    const length = requestBuffer.readUInt16BE(4);\n\n    // if length is bad, ignore message\n    if (requestBuffer.length !== (7 + length * 2 + 2)) {\n        return;\n    }\n\n    // build answer\n    const responseBuffer = Buffer.alloc(8);\n    responseBuffer.writeUInt16BE(address, 2);\n    responseBuffer.writeUInt16BE(length, 4);\n\n    // write registers\n    let callbackInvoked = false;\n    const cb = function(err) {\n        if (err) {\n            if (!callbackInvoked) {\n                callbackInvoked = true;\n                callback(err);\n            }\n\n            return;\n        }\n\n        if (!callbackInvoked) {\n            modbusSerialDebug({ action: \"FC16 response\", responseBuffer: responseBuffer });\n\n            callbackInvoked = true;\n            callback(null, responseBuffer);\n        }\n    };\n\n    if (length === 0)\n        callback({\n            modbusErrorCode: 0x02, // Illegal address\n            msg: \"Invalid length\"\n        });\n    if (vector.setRegisterArray) {\n        value = [];\n\n        try {\n            for (i = 0; i < length; i++) {\n                value.push(requestBuffer.readUInt16BE(7 + i * 2));\n            }\n\n            if (vector.setRegisterArray.length === 4) {\n                vector.setRegisterArray(address, value, unitID, cb);\n            }\n            else {\n                var promiseOrValue = vector.setRegisterArray(address, value, unitID);\n                _handlePromiseOrValue(promiseOrValue, cb);\n            }\n        }\n        catch (err) {\n            cb(err);\n        }\n    } else if (vector.setRegister) {\n        var value;\n\n        for (var i = 0; i < length; i++) {\n            try {\n                value = requestBuffer.readUInt16BE(7 + i * 2);\n\n                if (vector.setRegister.length === 4) {\n                    vector.setRegister(address + i, value, unitID, cb);\n                }\n                else {\n                    const promiseOrValue = vector.setRegister(address + i, value, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n            }\n            catch(err) {\n                cb(err);\n            }\n        }\n    }\n}\n\n/**\n * Function to handle FC17 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReportServerID(requestBuffer, vector, unitID, callback) {\n    if(!vector.reportServerID) {\n        callback({ modbusErrorCode: 0x01 });\n        return;\n    }\n\n    // build answer\n    const promiseOrValue = vector.reportServerID(unitID);\n    _handlePromiseOrValue(promiseOrValue, function(err, value) {\n        if(err) {\n            callback(err);\n            return;\n        }\n        if (!value) {\n            callback({ modbusErrorCode: 0x01, msg: \"Report Server ID not supported by device\" });\n            return;\n        }\n        if (!value.id || !value.running) {\n            callback({ modbusErrorCode: 0x04, msg: \"Invalid content provided for Report Server ID: \" + JSON.stringify(value) });\n            return;\n        }\n        const id = value.id;\n        const running = value.running;\n        const additionalData = value.additionalData;\n        let contentLength = 2; // serverID + Running\n        if (additionalData) {\n            contentLength += additionalData.length;\n        }\n        const totalLength = 3 + contentLength + 2; // UnitID + FC + Byte-Count + Content-Length + CRC\n\n        let i = 2;\n        const responseBuffer = Buffer.alloc(totalLength);\n        i = responseBuffer.writeUInt8(contentLength, i);\n        i = responseBuffer.writeUInt8(id, i);\n        if (running === true) {\n            i = responseBuffer.writeUInt8(0xFF, i);\n        } else {\n            i += 1;\n        }\n        if (additionalData) {\n            additionalData.copy(responseBuffer, i);\n        }\n        callback(null, responseBuffer);\n    });\n}\n\n/**\n * Function to handle FC43 request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleMEI(requestBuffer, vector, unitID, callback) {\n    const MEIType = requestBuffer[2];\n    switch(parseInt(MEIType)) {\n        case 14:\n            _handleReadDeviceIdentification(requestBuffer, vector, unitID, callback);\n            break;\n        default:\n            callback({ modbusErrorCode: 0x01 }); // illegal MEI type\n    }\n}\n\n/**\n * Function to handle FC43/14 MEI request.\n *\n * @param requestBuffer - request Buffer from client\n * @param vector - vector of functions for read and write\n * @param unitID - Id of the requesting unit\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @returns undefined\n * @private\n */\nfunction _handleReadDeviceIdentification(requestBuffer, vector, unitID, callback) {\n    const PDULenMax = 253;\n    const MEI14HeaderLen = 6;\n    const stringLengthMax = PDULenMax - MEI14HeaderLen - 2;\n\n    if(!vector.readDeviceIdentification) {\n        callback({ modbusErrorCode: 0x01 });\n        return;\n    }\n\n    const readDeviceIDCode = requestBuffer.readUInt8(3);\n    let objectID = requestBuffer.readUInt8(4);\n\n    // Basic request parameters checks\n    switch(readDeviceIDCode) {\n        case 0x01:\n            if(objectID > 0x02 || (objectID > 0x06 && objectID < 0x80))\n                objectID = 0x00;\n            break;\n\n        case 0x02:\n            if(objectID >= 0x80 || (objectID > 0x06 && objectID < 0x80))\n                objectID = 0x00;\n            break;\n\n        case 0x03:\n            if(objectID > 0x06 && objectID < 0x80)\n                objectID = 0x00;\n            break;\n\n        case 0x04:\n            if(objectID > 0x06 && objectID < 0x80) {\n                callback({ modbusErrorCode: 0x02 });\n                return;\n            }\n            break;\n\n        default:\n            callback({ modbusErrorCode: 0x03 });\n            return;\n    }\n\n    // Filling mandatory basic device identification objects\n    const objects = {\n        0x00: \"undefined\",\n        0x01: \"undefined\",\n        0x02: \"undefined\"\n    };\n\n    const pkg = require(\"../package.json\");\n    if(pkg) {\n        if(pkg.author)\n            objects[0x00] = pkg.author;\n        if(pkg.name)\n            objects[0x01] = pkg.name;\n        if(pkg.version)\n            objects[0x02] = pkg.version;\n    }\n\n    const promiseOrValue = vector.readDeviceIdentification(unitID);\n    _handlePromiseOrValue(promiseOrValue, function(err, value) {\n        if(err) {\n            callback(err);\n            return;\n        }\n\n        const userObjects = value;\n\n        for(const o of Object.keys(userObjects)) {\n            const i = parseInt(o);\n            if(!isNaN(i) && i >= 0 && i <= 255)\n                objects[i] = userObjects[o];\n        }\n\n        // Checking the existence of the requested objectID\n        if(!objects[objectID]) {\n            if(readDeviceIDCode === 0x04) {\n                callback({ modbusErrorCode: 0x02 });\n                return;\n            }\n\n            objectID = 0x00;\n        }\n\n        const ids = [];\n        let totalLength = 2 + MEI14HeaderLen + 2; // UnitID + FC + MEI14Header + CRC\n        let lastID = 0;\n        let conformityLevel = 0x81;\n\n        const supportedIDs = Object.keys(objects);\n\n        // Filtering of objects and Conformity level determination\n        for(var id of supportedIDs) {\n            id = parseInt(id);\n\n            if(isNaN(id))\n                continue;\n\n            // Enforcing valid object IDs from the user\n            if(id < 0x00 || (id > 0x06 && id < 0x80) || id > 0xFF) {\n                callback({ modbusErrorCode: 0x04, msg: \"Invalid Object ID provided for Read Device Identification: \" + id });\n            }\n\n            if(id > 0x02)\n                conformityLevel = 0x82;\n            if(id > 0x80)\n                conformityLevel = 0x83;\n\n            // Starting from requested object ID\n            if(objectID > id)\n                continue;\n\n            // Enforcing maximum string length\n            if(objects[id].length > stringLengthMax) {\n                callback({ modbusErrorCode: 0x04,\n                    msg: \"Read Device Identification string size can be maximum \" +\n                                stringLengthMax });\n            }\n\n            if(lastID !== 0)\n                continue;\n\n            if(objects[id].length + 2 > PDULenMax - totalLength) {\n                if(lastID === 0)\n                    lastID = id;\n            }\n            else {\n                totalLength += objects[id].length + 2;\n                ids.push(id);\n\n                // Requested a single object\n                if(readDeviceIDCode === 0x04)\n                    break;\n            }\n        }\n\n        ids.sort((a, b) => parseInt(a) - parseInt(b));\n        const responseBuffer = Buffer.alloc(totalLength);\n\n        let i = 2;\n        i = responseBuffer.writeUInt8(14, i);                                   // MEI type\n        i = responseBuffer.writeUInt8(readDeviceIDCode, i);\n        i = responseBuffer.writeUInt8(conformityLevel, i);\n        if(lastID === 0)                                                        // More follows\n            i = responseBuffer.writeUInt8(0x00, i);\n        else\n            i = responseBuffer.writeUInt8(0xFF, i);\n\n        i = responseBuffer.writeUInt8(lastID, i);                               // Next Object Id\n        i = responseBuffer.writeUInt8(ids.length, i);                           // Number of objects\n\n        for(id of ids) {\n            i = responseBuffer.writeUInt8(id, i);                               // Object id\n            i = responseBuffer.writeUInt8(objects[id].length, i);               // Object length\n            i += responseBuffer.write(objects[id], i, objects[id].length);      // Object value\n        }\n\n        callback(null, responseBuffer);\n    });\n}\n\n/**\n * Exports\n */\nmodule.exports = {\n    readCoilsOrInputDiscretes: _handleReadCoilsOrInputDiscretes,\n    readMultipleRegisters: _handleReadMultipleRegisters,\n    readMultipleRegistersEnron: _handleReadMultipleRegistersEnron,\n    readInputRegisters: _handleReadInputRegisters,\n    writeCoil: _handleWriteCoil,\n    writeSingleRegister: _handleWriteSingleRegister,\n    writeSingleRegisterEnron: _handleWriteSingleRegisterEnron,\n    forceMultipleCoils: _handleForceMultipleCoils,\n    writeMultipleRegisters: _handleWriteMultipleRegisters,\n    reportServerID: _handleReportServerID,\n    handleMEI: _handleMEI\n};\n"],"mappings":"AAAA;AACA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,iBAAiB,GAAGC,OAAO,CAAC,OAAO,CAAC,CAAC,eAAe,CAAC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,yBAAyBA,CAACC,aAAa,EAAE;EAE9C,IAAIA,aAAa,CAACC,MAAM,KAAK,CAAC,EAAE;IAC5BJ,iBAAiB,CAAC,wBAAwB,GAAGG,aAAa,CAACC,MAAM,GAAG,4BAA4B,CAAC;IACjG,OAAO,IAAI;EACf;EAEA,OAAO,KAAK,CAAC,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,8BAA8BA,CAACF,aAAa,EAAE;EAEnD,IAAIA,aAAa,CAACC,MAAM,KAAK,EAAE,EAAE;IAC7BJ,iBAAiB,CAAC,gCAAgC,GAAGG,aAAa,CAACC,MAAM,GAAG,6BAA6B,CAAC;IAC1G,OAAO,IAAI;EACf;EAEA,OAAO,KAAK,CAAC,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,qBAAqBA,CAACC,cAAc,EAAEC,EAAE,EAAE;EAC/C,IAAID,cAAc,IAAIA,cAAc,CAACE,IAAI,IAAI,OAAOF,cAAc,CAACE,IAAI,KAAK,UAAU,EAAE;IACpFF,cAAc,CACTE,IAAI,CAAC,UAASC,KAAK,EAAE;MAClBF,EAAE,CAAC,IAAI,EAAEE,KAAK,CAAC;IACnB,CAAC,CAAC,CACDC,KAAK,CAAC,UAASC,GAAG,EAAE;MACjBJ,EAAE,CAACI,GAAG,CAAC;IACX,CAAC,CAAC;EACV,CAAC,MAAO;IACJJ,EAAE,CAAC,IAAI,EAAED,cAAc,CAAC;EAC5B;AACJ;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,gCAAgCA,CAACV,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,EAAE,EAAE;EACnF,MAAMC,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMf,MAAM,GAAGD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAE5C,IAAIjB,yBAAyB,CAACC,aAAa,CAAC,EAAE;IAC1C;EACJ;;EAEA;EACA,MAAMiB,SAAS,GAAGC,QAAQ,CAAC,CAACjB,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EAChD,MAAMkB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,GAAGJ,SAAS,GAAG,CAAC,CAAC;EACtD,IAAI;IACAE,cAAc,CAACG,UAAU,CAACL,SAAS,EAAE,CAAC,CAAC;EAC3C,CAAC,CACD,OAAOR,GAAG,EAAE;IACRI,QAAQ,CAACJ,GAAG,CAAC;IACb;EACJ;EAEA,MAAMc,SAAS,GAAIT,EAAE,KAAK,CAAC,IAAIH,MAAM,CAACa,OAAQ;EAC9C,MAAMC,mBAAmB,GAAIX,EAAE,KAAK,CAAC,IAAIH,MAAM,CAACe,gBAAiB;;EAEjE;EACA,IAAIH,SAAS,IAAIE,mBAAmB,EAAE;IAClC,IAAIE,eAAe,GAAG,KAAK;IAC3B,IAAIC,OAAO,GAAG,CAAC;IACf,MAAMC,OAAO,GAAG,SAAAA,CAASC,CAAC,EAAE;MACxB,OAAO,UAASrB,GAAG,EAAEF,KAAK,EAAE;QACxB,IAAIE,GAAG,EAAE;UACL,IAAI,CAACkB,eAAe,EAAE;YAClBA,eAAe,GAAG,IAAI;YACtBd,QAAQ,CAACJ,GAAG,CAAC;UACjB;UAEA;QACJ;QAEAmB,OAAO,GAAGA,OAAO,GAAG,CAAC;QAErBT,cAAc,CAACY,QAAQ,CAACxB,KAAK,EAAEuB,CAAC,GAAG,CAAC,EAAE,CAAC,GAAGZ,QAAQ,CAACY,CAAC,GAAG,CAAC,CAAC,CAAC;QAE1D,IAAIF,OAAO,KAAK3B,MAAM,IAAI,CAAC0B,eAAe,EAAE;UACxC9B,iBAAiB,CAAC;YAAEmC,MAAM,EAAE,IAAI,GAAGlB,EAAE,GAAG,WAAW;YAAEK,cAAc,EAAEA;UAAe,CAAC,CAAC;UAEtFQ,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;QAClC;MACJ,CAAC;IACL,CAAC;IAED,IAAIlB,MAAM,KAAK,CAAC,EACZY,QAAQ,CAAC;MACLoB,eAAe,EAAE,IAAI;MAAE;MACvBC,GAAG,EAAE;IACT,CAAC,CAAC;IAEN,IAAIJ,CAAC,GAAG,CAAC;IACT,IAAIzB,EAAE,GAAG,IAAI;IACb,IAAID,cAAc,GAAG,IAAI;IAEzB,IAAImB,SAAS,IAAIZ,MAAM,CAACa,OAAO,CAACvB,MAAM,KAAK,CAAC,EAAE;MAC1C,KAAK6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;QACzBzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;QACf,IAAI;UACAnB,MAAM,CAACa,OAAO,CAACT,OAAO,GAAGe,CAAC,EAAElB,MAAM,EAAEP,EAAE,CAAC;QAC3C,CAAC,CACD,OAAMI,GAAG,EAAE;UACPJ,EAAE,CAACI,GAAG,CAAC;QACX;MACJ;IACJ,CAAC,MACI,IAAIgB,mBAAmB,IAAId,MAAM,CAACe,gBAAgB,CAACzB,MAAM,KAAK,CAAC,EAAE;MAClE,KAAK6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;QACzBzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;QACf,IAAI;UACAnB,MAAM,CAACe,gBAAgB,CAACX,OAAO,GAAGe,CAAC,EAAElB,MAAM,EAAEP,EAAE,CAAC;QACpD,CAAC,CACD,OAAMI,GAAG,EAAE;UACPJ,EAAE,CAACI,GAAG,CAAC;QACX;MACJ;IACJ,CAAC,MACI,IAAIc,SAAS,EAAE;MAChB,KAAKO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;QACzBzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;QACf,IAAI;UACA1B,cAAc,GAAGO,MAAM,CAACa,OAAO,CAACT,OAAO,GAAGe,CAAC,EAAElB,MAAM,CAAC;UACpDT,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C,CAAC,CACD,OAAMI,GAAG,EAAE;UACPJ,EAAE,CAACI,GAAG,CAAC;QACX;MACJ;IACJ,CAAC,MACI,IAAIgB,mBAAmB,EAAE;MAC1B,KAAKK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;QACzBzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;QACf,IAAI;UACA1B,cAAc,GAAGO,MAAM,CAACe,gBAAgB,CAACX,OAAO,GAAGe,CAAC,EAAElB,MAAM,CAAC;UAC7DT,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C,CAAC,CACD,OAAMI,GAAG,EAAE;UACPJ,EAAE,CAACI,GAAG,CAAC;QACX;MACJ;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,4BAA4BA,CAACnC,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC3E,MAAMuB,SAAS,GAAG,CAAC;EACnB,MAAMrB,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMf,MAAM,GAAGD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAE5C,IAAIjB,yBAAyB,CAACC,aAAa,CAAC,EAAE;IAC1C;EACJ;;EAEA;EACA,MAAMmB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,GAAIpB,MAAM,GAAGmC,SAAU,GAAG,CAAC,CAAC;EACjE,IAAI;IACAjB,cAAc,CAACG,UAAU,CAACrB,MAAM,GAAGmC,SAAS,EAAE,CAAC,CAAC;EACpD,CAAC,CACD,OAAO3B,GAAG,EAAE;IACRI,QAAQ,CAACJ,GAAG,CAAC;IACb;EACJ;EAEA,IAAIkB,eAAe,GAAG,KAAK;EAC3B,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMC,OAAO,GAAG,SAAAA,CAASC,CAAC,EAAE;IACxB,OAAO,UAASrB,GAAG,EAAEF,KAAK,EAAE;MACxB,IAAIE,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEAmB,OAAO,GAAGA,OAAO,GAAG,CAAC;MAErBT,cAAc,CAACkB,aAAa,CAAC9B,KAAK,EAAE,CAAC,GAAIuB,CAAC,GAAGM,SAAU,CAAC;MAExD,IAAIR,OAAO,KAAK3B,MAAM,IAAI,CAAC0B,eAAe,EAAE;QACxC9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,cAAc;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE7EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;EACL,CAAC;EAED,IAAIlB,MAAM,KAAK,CAAC,EACZY,QAAQ,CAAC;IACLoB,eAAe,EAAE,IAAI;IAAE;IACvBC,GAAG,EAAE;EACT,CAAC,CAAC;;EAEN;EACA,SAASI,0BAA0BA,CAACR,CAAC,EAAES,MAAM,EAAE;IAC3C,MAAMlC,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;IACrB,IAAI;MACA,MAAM1B,cAAc,GAAGmC,MAAM,CAACT,CAAC,CAAC;MAChC3B,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;IAC7C,CAAC,CACD,OAAOI,GAAG,EAAE;MACRJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ;EAEA,IAAIE,MAAM,CAAC6B,2BAA2B,IAAIvC,MAAM,GAAG,CAAC,EAAE;IAElD,IAAIU,MAAM,CAAC6B,2BAA2B,CAACvC,MAAM,KAAK,CAAC,EAAE;MACjDU,MAAM,CAAC6B,2BAA2B,CAACzB,OAAO,EAAEd,MAAM,EAAEW,MAAM,EAAE,UAASH,GAAG,EAAE8B,MAAM,EAAE;QAC9E,IAAI,CAAC9B,GAAG,IAAI8B,MAAM,CAACtC,MAAM,KAAKA,MAAM,EAAE;UAClC,MAAMwC,KAAK,GAAG,IAAIC,KAAK,CAAC,2DAA2D,CAAC;UACpF7B,QAAQ,CAAC4B,KAAK,CAAC;QACnB,CAAC,MAAM,IAAIhC,GAAG,EAAE;UACZ,MAAMJ,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;UACrB,IAAI;YACAzB,EAAE,CAACI,GAAG,CAAC,CAAC,CAAC;UACb,CAAC,CACD,OAAOkC,EAAE,EAAE;YACPtC,EAAE,CAACsC,EAAE,CAAC;UACV;QACJ,CAAC,MACI;UACD,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;YAC7B,MAAMzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;YACrB,IAAI;cACAzB,EAAE,CAACI,GAAG,EAAE8B,MAAM,CAACT,CAAC,CAAC,CAAC;YACtB,CAAC,CACD,OAAOa,EAAE,EAAE;cACPtC,EAAE,CAACsC,EAAE,CAAC;YACV;UACJ;QACJ;MACJ,CAAC,CAAC;IACN,CAAC,MAAM;MACH,IAAIJ,MAAM;MACV,IAAI;QACAA,MAAM,GAAG5B,MAAM,CAAC6B,2BAA2B,CAACzB,OAAO,EAAEd,MAAM,EAAEW,MAAM,CAAC;MACxE,CAAC,CAAC,OAAO6B,KAAK,EAAE;QACZ5B,QAAQ,CAAC4B,KAAK,CAAC;QACf;MACJ;MACA,IAAIF,MAAM,CAACtC,MAAM,KAAKA,MAAM,EAAE;QAC1B,KAAK6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;UACzBQ,0BAA0B,CAACR,CAAC,EAAES,MAAM,CAAC;QACzC;MACJ,CAAC,MAAM;QACH,MAAME,KAAK,GAAG,IAAIC,KAAK,CAAC,2DAA2D,CAAC;QACpF7B,QAAQ,CAAC4B,KAAK,CAAC;MACnB;IACJ;EAEJ,CAAC,MACI,IAAI9B,MAAM,CAACiC,kBAAkB,EAAE;IAChC,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;MAC7B,MAAMzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;MACrB,IAAI;QACA,IAAInB,MAAM,CAACiC,kBAAkB,CAAC3C,MAAM,KAAK,CAAC,EAAE;UACxCU,MAAM,CAACiC,kBAAkB,CAAC7B,OAAO,GAAGe,CAAC,EAAElB,MAAM,EAAEP,EAAE,CAAC;QACtD,CAAC,MAAM;UACH,MAAMD,cAAc,GAAGO,MAAM,CAACiC,kBAAkB,CAAC7B,OAAO,GAAGe,CAAC,EAAElB,MAAM,CAAC;UACrET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C;MACJ,CAAC,CACD,OAAOI,GAAG,EAAE;QACRJ,EAAE,CAACI,GAAG,CAAC;MACX;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoC,iCAAiCA,CAAC7C,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEkC,WAAW,EAAEjC,QAAQ,EAAE;EAC7F,MAAMuB,SAAS,GAAG,CAAC;EACnB,MAAMrB,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMf,MAAM,GAAGD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;;EAE5C;EACA,IAAID,OAAO,IAAI+B,WAAW,CAACC,UAAU,CAAC,CAAC,CAAC,IAAIhC,OAAO,IAAI+B,WAAW,CAACC,UAAU,CAAC,CAAC,CAAC,EAAE;IAC9E,OAAOZ,4BAA4B,CAACnC,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,CAAC;EAChF;EAEA,IAAId,yBAAyB,CAACC,aAAa,CAAC,EAAE;IAC1C;EACJ;;EAEA;EACA,MAAMmB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,GAAIpB,MAAM,GAAGmC,SAAU,GAAG,CAAC,CAAC;EACjE,IAAI;IACAjB,cAAc,CAACG,UAAU,CAACrB,MAAM,GAAGmC,SAAS,EAAE,CAAC,CAAC;EACpD,CAAC,CACD,OAAO3B,GAAG,EAAE;IACRI,QAAQ,CAACJ,GAAG,CAAC;IACb;EACJ;EAEA,IAAIkB,eAAe,GAAG,KAAK;EAC3B,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMC,OAAO,GAAG,SAAAA,CAASC,CAAC,EAAE;IACxB,OAAO,UAASrB,GAAG,EAAEF,KAAK,EAAE;MACxB,IAAIE,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEAmB,OAAO,GAAGA,OAAO,GAAG,CAAC;MAErBT,cAAc,CAAC6B,aAAa,CAACzC,KAAK,EAAE,CAAC,GAAIuB,CAAC,GAAGM,SAAU,CAAC;MAExD,IAAIR,OAAO,KAAK3B,MAAM,IAAI,CAAC0B,eAAe,EAAE;QACxC9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,cAAc;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE7EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;EACL,CAAC;EAED,IAAIlB,MAAM,KAAK,CAAC,EACZY,QAAQ,CAAC;IACLoB,eAAe,EAAE,IAAI;IAAE;IACvBC,GAAG,EAAE;EACT,CAAC,CAAC;;EAEN;EACA,SAASI,0BAA0BA,CAACR,CAAC,EAAES,MAAM,EAAE;IAC3C,MAAMlC,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;IACrB,IAAI;MACA,MAAM1B,cAAc,GAAGmC,MAAM,CAACT,CAAC,CAAC;MAChC3B,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;IAC7C,CAAC,CACD,OAAOI,GAAG,EAAE;MACRJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ;EAEA,IAAIE,MAAM,CAAC6B,2BAA2B,IAAIvC,MAAM,GAAG,CAAC,EAAE;IAElD,IAAIU,MAAM,CAAC6B,2BAA2B,CAACvC,MAAM,KAAK,CAAC,EAAE;MACjDU,MAAM,CAAC6B,2BAA2B,CAACzB,OAAO,EAAEd,MAAM,EAAEW,MAAM,EAAE,UAASH,GAAG,EAAE8B,MAAM,EAAE;QAC9E,IAAI,CAAC9B,GAAG,IAAI8B,MAAM,CAACtC,MAAM,KAAKA,MAAM,EAAE;UAClC,MAAMwC,KAAK,GAAG,IAAIC,KAAK,CAAC,2DAA2D,CAAC;UACpF7B,QAAQ,CAAC4B,KAAK,CAAC;QACnB,CAAC,MAAM,IAAIhC,GAAG,EAAE;UACZ,MAAMJ,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;UACrB,IAAI;YACAzB,EAAE,CAACI,GAAG,CAAC,CAAC,CAAC;UACb,CAAC,CACD,OAAOkC,EAAE,EAAE;YACPtC,EAAE,CAACsC,EAAE,CAAC;UACV;QACJ,CAAC,MACI;UACD,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;YAC7B,MAAMzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;YACrB,IAAI;cACAzB,EAAE,CAACI,GAAG,EAAE8B,MAAM,CAACT,CAAC,CAAC,CAAC;YACtB,CAAC,CACD,OAAOa,EAAE,EAAE;cACPtC,EAAE,CAACsC,EAAE,CAAC;YACV;UACJ;QACJ;MACJ,CAAC,CAAC;IACN,CAAC,MAAM;MACH,IAAIJ,MAAM;MACV,IAAI;QACAA,MAAM,GAAG5B,MAAM,CAAC6B,2BAA2B,CAACzB,OAAO,EAAEd,MAAM,EAAEW,MAAM,CAAC;MACxE,CAAC,CAAC,OAAO6B,KAAK,EAAE;QACZ5B,QAAQ,CAAC4B,KAAK,CAAC;QACf;MACJ;MACA,IAAIF,MAAM,CAACtC,MAAM,KAAKA,MAAM,EAAE;QAC1B,KAAK6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;UACzBQ,0BAA0B,CAACR,CAAC,EAAES,MAAM,CAAC;QACzC;MACJ,CAAC,MAAM;QACH,MAAME,KAAK,GAAG,IAAIC,KAAK,CAAC,2DAA2D,CAAC;QACpF7B,QAAQ,CAAC4B,KAAK,CAAC;MACnB;IACJ;EAEJ,CAAC,MACI,IAAI9B,MAAM,CAACiC,kBAAkB,EAAE;IAChC,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;MAC7B,MAAMzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;MACrB,IAAI;QACA,IAAInB,MAAM,CAACiC,kBAAkB,CAAC3C,MAAM,KAAK,CAAC,EAAE;UACxCU,MAAM,CAACiC,kBAAkB,CAAC7B,OAAO,GAAGe,CAAC,EAAElB,MAAM,EAAEP,EAAE,CAAC;QACtD,CAAC,MAAM;UACH,MAAMD,cAAc,GAAGO,MAAM,CAACiC,kBAAkB,CAAC7B,OAAO,GAAGe,CAAC,EAAElB,MAAM,CAAC;UACrET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C;MACJ,CAAC,CACD,OAAOI,GAAG,EAAE;QACRJ,EAAE,CAACI,GAAG,CAAC;MACX;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwC,yBAAyBA,CAACjD,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACxE,MAAME,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMf,MAAM,GAAGD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAE5C,IAAIjB,yBAAyB,CAACC,aAAa,CAAC,EAAE;IAC1C;EACJ;;EAEA;EACA,MAAMmB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,GAAGpB,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;EACvD,IAAI;IACAkB,cAAc,CAACG,UAAU,CAACrB,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;EAC5C,CAAC,CACD,OAAOQ,GAAG,EAAE;IACRI,QAAQ,CAACJ,GAAG,CAAC;IACb;EACJ;EAEA,IAAIkB,eAAe,GAAG,KAAK;EAC3B,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMC,OAAO,GAAG,SAAAA,CAASC,CAAC,EAAE;IACxB,OAAO,UAASrB,GAAG,EAAEF,KAAK,EAAE;MACxB,IAAIE,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEAmB,OAAO,GAAGA,OAAO,GAAG,CAAC;MAErBT,cAAc,CAACkB,aAAa,CAAC9B,KAAK,EAAE,CAAC,GAAGuB,CAAC,GAAG,CAAC,CAAC;MAE9C,IAAIF,OAAO,KAAK3B,MAAM,IAAI,CAAC0B,eAAe,EAAE;QACxC9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,cAAc;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE7EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;EACL,CAAC;EAED,IAAIlB,MAAM,KAAK,CAAC,EACZY,QAAQ,CAAC;IACLoB,eAAe,EAAE,IAAI;IAAE;IACvBC,GAAG,EAAE;EACT,CAAC,CAAC;EAEN,SAASgB,2BAA2BA,CAACpB,CAAC,EAAES,MAAM,EAAE;IAC5C,MAAMlC,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;IACrB,IAAI;MACA,MAAM1B,cAAc,GAAGmC,MAAM,CAACT,CAAC,CAAC;MAChC3B,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;IAC7C,CAAC,CACD,OAAOI,GAAG,EAAE;MACRJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ;EAEA,IAAIE,MAAM,CAACwC,yBAAyB,IAAIlD,MAAM,GAAG,CAAC,EAAE;IAEhD,IAAIU,MAAM,CAACwC,yBAAyB,CAAClD,MAAM,KAAK,CAAC,EAAE;MAC/CU,MAAM,CAACwC,yBAAyB,CAACpC,OAAO,EAAEd,MAAM,EAAEW,MAAM,EAAE,UAASH,GAAG,EAAE8B,MAAM,EAAE;QAC5E,IAAI,CAAC9B,GAAG,IAAI8B,MAAM,CAACtC,MAAM,KAAKA,MAAM,EAAE;UAClC,MAAMwC,KAAK,GAAG,IAAIC,KAAK,CAAC,2DAA2D,CAAC;UACpF7B,QAAQ,CAAC4B,KAAK,CAAC;QACnB,CAAC,MAAM;UACH,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;YAC7B,MAAMzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;YACrB,IAAI;cACAzB,EAAE,CAACI,GAAG,EAAE8B,MAAM,CAACT,CAAC,CAAC,CAAC;YACtB,CAAC,CACD,OAAOa,EAAE,EAAE;cACPtC,EAAE,CAACsC,EAAE,CAAC;YACV;UACJ;QACJ;MACJ,CAAC,CAAC;IACN,CAAC,MAAM;MACH,IAAIJ,MAAM;MAEV,IAAI;QACAA,MAAM,GAAG5B,MAAM,CAACwC,yBAAyB,CAACpC,OAAO,EAAEd,MAAM,EAAEW,MAAM,CAAC;MACtE,CAAC,CAAC,OAAO6B,KAAK,EAAE;QACZ5B,QAAQ,CAAC4B,KAAK,CAAC;QACf;MACJ;MAEA,IAAIF,MAAM,CAACtC,MAAM,KAAKA,MAAM,EAAE;QAC1B,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;UAC7BoB,2BAA2B,CAACpB,CAAC,EAAES,MAAM,CAAC;QAC1C;MACJ,CAAC,MAAM;QACH,MAAME,KAAK,GAAG,IAAIC,KAAK,CAAC,2DAA2D,CAAC;QACpF7B,QAAQ,CAAC4B,KAAK,CAAC;MACnB;IACJ;EAEJ,CAAC,MACI,IAAI9B,MAAM,CAACyC,gBAAgB,EAAE;IAE9B,KAAKtB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;MACzB,MAAMzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;MACrB,IAAI;QACA,IAAInB,MAAM,CAACyC,gBAAgB,CAACnD,MAAM,KAAK,CAAC,EAAE;UACtCU,MAAM,CAACyC,gBAAgB,CAACrC,OAAO,GAAGe,CAAC,EAAElB,MAAM,EAAEP,EAAE,CAAC;QACpD,CAAC,MACI;UACD,MAAMD,cAAc,GAAGO,MAAM,CAACyC,gBAAgB,CAACrC,OAAO,GAAGe,CAAC,EAAElB,MAAM,CAAC;UACnET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C;MACJ,CAAC,CACD,OAAOsC,EAAE,EAAE;QACPtC,EAAE,CAACsC,EAAE,CAAC;MACV;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,gBAAgBA,CAACrD,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC/D,MAAME,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMsC,KAAK,GAAGtD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAE3C,IAAIjB,yBAAyB,CAACC,aAAa,CAAC,EAAE;IAC1C;EACJ;;EAEA;EACA,MAAMmB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACtCF,cAAc,CAACkB,aAAa,CAACtB,OAAO,EAAE,CAAC,CAAC;EACxCI,cAAc,CAACkB,aAAa,CAACiB,KAAK,EAAE,CAAC,CAAC;EAEtC,IAAI3C,MAAM,CAAC4C,OAAO,EAAE;IAChB,IAAI5B,eAAe,GAAG,KAAK;IAC3B,MAAMtB,EAAE,GAAG,SAAAA,CAASI,GAAG,EAAE;MACrB,IAAIA,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEA,IAAI,CAACkB,eAAe,EAAE;QAClB9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,cAAc;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE7EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;IAED,IAAI;MACA,IAAIR,MAAM,CAAC4C,OAAO,CAACtD,MAAM,KAAK,CAAC,EAAE;QAC7BU,MAAM,CAAC4C,OAAO,CAACxC,OAAO,EAAEuC,KAAK,KAAK,MAAM,EAAE1C,MAAM,EAAEP,EAAE,CAAC;MACzD,CAAC,MACI;QACD,MAAMD,cAAc,GAAGO,MAAM,CAAC4C,OAAO,CAACxC,OAAO,EAAEuC,KAAK,KAAK,MAAM,EAAE1C,MAAM,CAAC;QACxET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;MAC7C;IACJ,CAAC,CACD,OAAMI,GAAG,EAAE;MACPJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+C,0BAA0BA,CAACxD,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACzE,MAAME,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMT,KAAK,GAAGP,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAE3C,IAAIjB,yBAAyB,CAACC,aAAa,CAAC,EAAE;IAC1C;EACJ;;EAEA;EACA,MAAMmB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACtCF,cAAc,CAACkB,aAAa,CAACtB,OAAO,EAAE,CAAC,CAAC;EACxCI,cAAc,CAACkB,aAAa,CAAC9B,KAAK,EAAE,CAAC,CAAC;EAEtC,IAAII,MAAM,CAAC8C,WAAW,EAAE;IACpB,IAAI9B,eAAe,GAAG,KAAK;IAC3B,MAAMtB,EAAE,GAAG,SAAAA,CAASI,GAAG,EAAE;MACrB,IAAIA,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEA,IAAI,CAACkB,eAAe,EAAE;QAClB9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,cAAc;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE7EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;IAED,IAAI;MACA,IAAIR,MAAM,CAAC8C,WAAW,CAACxD,MAAM,KAAK,CAAC,EAAE;QACjCU,MAAM,CAAC8C,WAAW,CAAC1C,OAAO,EAAER,KAAK,EAAEK,MAAM,EAAEP,EAAE,CAAC;MAClD,CAAC,MACI;QACD,MAAMD,cAAc,GAAGO,MAAM,CAAC8C,WAAW,CAAC1C,OAAO,EAAER,KAAK,EAAEK,MAAM,CAAC;QACjET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;MAC7C;IACJ,CAAC,CAAC,OAAMI,GAAG,EAAE;MACTJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiD,+BAA+BA,CAAC1D,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEkC,WAAW,EAAEjC,QAAQ,EAAE;EAC3F,MAAME,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMT,KAAK,GAAGP,aAAa,CAAC2D,YAAY,CAAC,CAAC,CAAC;;EAE3C;EACA,IAAI5C,OAAO,IAAI+B,WAAW,CAACC,UAAU,CAAC,CAAC,CAAC,IAAIhC,OAAO,IAAI+B,WAAW,CAACC,UAAU,CAAC,CAAC,CAAC,EAAE;IAC9E,OAAOS,0BAA0B,CAACxD,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,CAAC;EAC9E;EAEA,IAAIX,8BAA8B,CAACF,aAAa,CAAC,EAAE;IAC/C;EACJ;;EAEA;EACA,MAAMmB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,EAAE,CAAC;EACvCF,cAAc,CAACkB,aAAa,CAACtB,OAAO,EAAE,CAAC,CAAC;EACxCI,cAAc,CAAC6B,aAAa,CAACzC,KAAK,EAAE,CAAC,CAAC;EAEtC,IAAII,MAAM,CAAC8C,WAAW,EAAE;IACpB,IAAI9B,eAAe,GAAG,KAAK;IAC3B,MAAMtB,EAAE,GAAG,SAAAA,CAASI,GAAG,EAAE;MACrB,IAAIA,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEA,IAAI,CAACkB,eAAe,EAAE;QAClB9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,cAAc;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE7EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;IAED,IAAI;MACA,IAAIR,MAAM,CAAC8C,WAAW,CAACxD,MAAM,KAAK,CAAC,EAAE;QACjCU,MAAM,CAAC8C,WAAW,CAAC1C,OAAO,EAAER,KAAK,EAAEK,MAAM,EAAEP,EAAE,CAAC;MAClD,CAAC,MACI;QACD,MAAMD,cAAc,GAAGO,MAAM,CAAC8C,WAAW,CAAC1C,OAAO,EAAER,KAAK,EAAEK,MAAM,CAAC;QACjET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;MAC7C;IACJ,CAAC,CAAC,OAAMI,GAAG,EAAE;MACTJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmD,yBAAyBA,CAAC5D,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACxE,MAAME,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMf,MAAM,GAAGD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;;EAE5C;EACA,IAAIhB,aAAa,CAACC,MAAM,KAAK,CAAC,GAAG4D,IAAI,CAACC,IAAI,CAAC7D,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;IACxD;EACJ;;EAEA;EACA,MAAMkB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACtCF,cAAc,CAACkB,aAAa,CAACtB,OAAO,EAAE,CAAC,CAAC;EACxCI,cAAc,CAACkB,aAAa,CAACpC,MAAM,EAAE,CAAC,CAAC;EAEvC,IAAI0B,eAAe,GAAG,KAAK;EAC3B,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMC,OAAO,GAAG,SAASA;EAAA,GAAkC;IACvD,OAAO,UAASpB,GAAG,EAAE;MACjB,IAAIA,GAAG,EAAE;QACL,IAAI,CAACkB,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI;UACtBd,QAAQ,CAACJ,GAAG,CAAC;QACjB;QAEA;MACJ;MAEAmB,OAAO,GAAGA,OAAO,GAAG,CAAC;MAErB,IAAIA,OAAO,KAAK3B,MAAM,IAAI,CAAC0B,eAAe,EAAE;QACxC9B,iBAAiB,CAAC;UAAEmC,MAAM,EAAE,eAAe;UAAEb,cAAc,EAAEA;QAAe,CAAC,CAAC;QAE9EQ,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;MAClC;IACJ,CAAC;EACL,CAAC;EAED,IAAIlB,MAAM,KAAK,CAAC,EACZY,QAAQ,CAAC;IACLoB,eAAe,EAAE,IAAI;IAAE;IACvBC,GAAG,EAAE;EACT,CAAC,CAAC;EAEN,IAAIvB,MAAM,CAACoD,YAAY,EAAE;IACrB,MAAMT,KAAK,GAAG,EAAE;IAEhB,KAAKxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;MACzBzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;MACfwB,KAAK,CAACU,IAAI,CAAChE,aAAa,CAACiE,OAAO,CAACnC,CAAC,EAAE,CAAC,CAAC,CAAC;MACvC3B,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;IAC7C;IAEA,IAAI;MACA,IAAIM,MAAM,CAACoD,YAAY,CAAC9D,MAAM,KAAK,CAAC,EAAE;QAClCU,MAAM,CAACoD,YAAY,CAAChD,OAAO,EAAEuC,KAAK,EAAE1C,MAAM,EAAEP,EAAE,CAAC;MACnD,CAAC,MACI;QACDM,MAAM,CAACoD,YAAY,CAAChD,OAAO,EAAEuC,KAAK,EAAE1C,MAAM,CAAC;MAC/C;IACJ,CAAC,CACD,OAAMH,GAAG,EAAE;MACPJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ,CAAC,MAAM,IAAIE,MAAM,CAAC4C,OAAO,EAAE;IACvB,IAAID,KAAK;IAET,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;MAC7B,IAAIzB,EAAE,GAAGwB,OAAO,CAACC,CAAC,CAAC;MACnBwB,KAAK,GAAGtD,aAAa,CAACiE,OAAO,CAACnC,CAAC,EAAE,CAAC,CAAC;MAEnC,IAAI;QACA,IAAInB,MAAM,CAAC4C,OAAO,CAACtD,MAAM,KAAK,CAAC,EAAE;UAC7BU,MAAM,CAAC4C,OAAO,CAACxC,OAAO,GAAGe,CAAC,EAAEwB,KAAK,KAAK,KAAK,EAAE1C,MAAM,EAAEP,EAAE,CAAC;QAC5D,CAAC,MACI;UACD,IAAID,cAAc,GAAGO,MAAM,CAAC4C,OAAO,CAACxC,OAAO,GAAGe,CAAC,EAAEwB,KAAK,KAAK,KAAK,EAAE1C,MAAM,CAAC;UACzET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C;MACJ,CAAC,CACD,OAAMI,GAAG,EAAE;QACPJ,EAAE,CAACI,GAAG,CAAC;MACX;IACJ;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyD,6BAA6BA,CAAClE,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC5E,MAAME,OAAO,GAAGf,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;EAC7C,MAAMf,MAAM,GAAGD,aAAa,CAACgB,YAAY,CAAC,CAAC,CAAC;;EAE5C;EACA,IAAIhB,aAAa,CAACC,MAAM,KAAM,CAAC,GAAGA,MAAM,GAAG,CAAC,GAAG,CAAE,EAAE;IAC/C;EACJ;;EAEA;EACA,MAAMkB,cAAc,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACtCF,cAAc,CAACkB,aAAa,CAACtB,OAAO,EAAE,CAAC,CAAC;EACxCI,cAAc,CAACkB,aAAa,CAACpC,MAAM,EAAE,CAAC,CAAC;;EAEvC;EACA,IAAI0B,eAAe,GAAG,KAAK;EAC3B,MAAMtB,EAAE,GAAG,SAAAA,CAASI,GAAG,EAAE;IACrB,IAAIA,GAAG,EAAE;MACL,IAAI,CAACkB,eAAe,EAAE;QAClBA,eAAe,GAAG,IAAI;QACtBd,QAAQ,CAACJ,GAAG,CAAC;MACjB;MAEA;IACJ;IAEA,IAAI,CAACkB,eAAe,EAAE;MAClB9B,iBAAiB,CAAC;QAAEmC,MAAM,EAAE,eAAe;QAAEb,cAAc,EAAEA;MAAe,CAAC,CAAC;MAE9EQ,eAAe,GAAG,IAAI;MACtBd,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;IAClC;EACJ,CAAC;EAED,IAAIlB,MAAM,KAAK,CAAC,EACZY,QAAQ,CAAC;IACLoB,eAAe,EAAE,IAAI;IAAE;IACvBC,GAAG,EAAE;EACT,CAAC,CAAC;EACN,IAAIvB,MAAM,CAACwD,gBAAgB,EAAE;IACzB5D,KAAK,GAAG,EAAE;IAEV,IAAI;MACA,KAAKuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;QACzBvB,KAAK,CAACyD,IAAI,CAAChE,aAAa,CAACgB,YAAY,CAAC,CAAC,GAAGc,CAAC,GAAG,CAAC,CAAC,CAAC;MACrD;MAEA,IAAInB,MAAM,CAACwD,gBAAgB,CAAClE,MAAM,KAAK,CAAC,EAAE;QACtCU,MAAM,CAACwD,gBAAgB,CAACpD,OAAO,EAAER,KAAK,EAAEK,MAAM,EAAEP,EAAE,CAAC;MACvD,CAAC,MACI;QACD,IAAID,cAAc,GAAGO,MAAM,CAACwD,gBAAgB,CAACpD,OAAO,EAAER,KAAK,EAAEK,MAAM,CAAC;QACpET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;MAC7C;IACJ,CAAC,CACD,OAAOI,GAAG,EAAE;MACRJ,EAAE,CAACI,GAAG,CAAC;IACX;EACJ,CAAC,MAAM,IAAIE,MAAM,CAAC8C,WAAW,EAAE;IAC3B,IAAIlD,KAAK;IAET,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,MAAM,EAAE6B,CAAC,EAAE,EAAE;MAC7B,IAAI;QACAvB,KAAK,GAAGP,aAAa,CAACgB,YAAY,CAAC,CAAC,GAAGc,CAAC,GAAG,CAAC,CAAC;QAE7C,IAAInB,MAAM,CAAC8C,WAAW,CAACxD,MAAM,KAAK,CAAC,EAAE;UACjCU,MAAM,CAAC8C,WAAW,CAAC1C,OAAO,GAAGe,CAAC,EAAEvB,KAAK,EAAEK,MAAM,EAAEP,EAAE,CAAC;QACtD,CAAC,MACI;UACD,MAAMD,cAAc,GAAGO,MAAM,CAAC8C,WAAW,CAAC1C,OAAO,GAAGe,CAAC,EAAEvB,KAAK,EAAEK,MAAM,CAAC;UACrET,qBAAqB,CAACC,cAAc,EAAEC,EAAE,CAAC;QAC7C;MACJ,CAAC,CACD,OAAMI,GAAG,EAAE;QACPJ,EAAE,CAACI,GAAG,CAAC;MACX;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2D,qBAAqBA,CAACpE,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACpE,IAAG,CAACF,MAAM,CAAC0D,cAAc,EAAE;IACvBxD,QAAQ,CAAC;MAAEoB,eAAe,EAAE;IAAK,CAAC,CAAC;IACnC;EACJ;;EAEA;EACA,MAAM7B,cAAc,GAAGO,MAAM,CAAC0D,cAAc,CAACzD,MAAM,CAAC;EACpDT,qBAAqB,CAACC,cAAc,EAAE,UAASK,GAAG,EAAEF,KAAK,EAAE;IACvD,IAAGE,GAAG,EAAE;MACJI,QAAQ,CAACJ,GAAG,CAAC;MACb;IACJ;IACA,IAAI,CAACF,KAAK,EAAE;MACRM,QAAQ,CAAC;QAAEoB,eAAe,EAAE,IAAI;QAAEC,GAAG,EAAE;MAA2C,CAAC,CAAC;MACpF;IACJ;IACA,IAAI,CAAC3B,KAAK,CAAC+D,EAAE,IAAI,CAAC/D,KAAK,CAACgE,OAAO,EAAE;MAC7B1D,QAAQ,CAAC;QAAEoB,eAAe,EAAE,IAAI;QAAEC,GAAG,EAAE,iDAAiD,GAAGsC,IAAI,CAACC,SAAS,CAAClE,KAAK;MAAE,CAAC,CAAC;MACnH;IACJ;IACA,MAAM+D,EAAE,GAAG/D,KAAK,CAAC+D,EAAE;IACnB,MAAMC,OAAO,GAAGhE,KAAK,CAACgE,OAAO;IAC7B,MAAMG,cAAc,GAAGnE,KAAK,CAACmE,cAAc;IAC3C,IAAIC,aAAa,GAAG,CAAC,CAAC,CAAC;IACvB,IAAID,cAAc,EAAE;MAChBC,aAAa,IAAID,cAAc,CAACzE,MAAM;IAC1C;IACA,MAAM2E,WAAW,GAAG,CAAC,GAAGD,aAAa,GAAG,CAAC,CAAC,CAAC;;IAE3C,IAAI7C,CAAC,GAAG,CAAC;IACT,MAAMX,cAAc,GAAGC,MAAM,CAACC,KAAK,CAACuD,WAAW,CAAC;IAChD9C,CAAC,GAAGX,cAAc,CAACG,UAAU,CAACqD,aAAa,EAAE7C,CAAC,CAAC;IAC/CA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAACgD,EAAE,EAAExC,CAAC,CAAC;IACpC,IAAIyC,OAAO,KAAK,IAAI,EAAE;MAClBzC,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC,IAAI,EAAEQ,CAAC,CAAC;IAC1C,CAAC,MAAM;MACHA,CAAC,IAAI,CAAC;IACV;IACA,IAAI4C,cAAc,EAAE;MAChBA,cAAc,CAACG,IAAI,CAAC1D,cAAc,EAAEW,CAAC,CAAC;IAC1C;IACAjB,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;EAClC,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2D,UAAUA,CAAC9E,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACzD,MAAMkE,OAAO,GAAG/E,aAAa,CAAC,CAAC,CAAC;EAChC,QAAOkB,QAAQ,CAAC6D,OAAO,CAAC;IACpB,KAAK,EAAE;MACHC,+BAA+B,CAAChF,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,CAAC;MACxE;IACJ;MACIA,QAAQ,CAAC;QAAEoB,eAAe,EAAE;MAAK,CAAC,CAAC;IAAE;EAC7C;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+C,+BAA+BA,CAAChF,aAAa,EAAEW,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EAC9E,MAAMoE,SAAS,GAAG,GAAG;EACrB,MAAMC,cAAc,GAAG,CAAC;EACxB,MAAMC,eAAe,GAAGF,SAAS,GAAGC,cAAc,GAAG,CAAC;EAEtD,IAAG,CAACvE,MAAM,CAACyE,wBAAwB,EAAE;IACjCvE,QAAQ,CAAC;MAAEoB,eAAe,EAAE;IAAK,CAAC,CAAC;IACnC;EACJ;EAEA,MAAMoD,gBAAgB,GAAGrF,aAAa,CAACsF,SAAS,CAAC,CAAC,CAAC;EACnD,IAAIC,QAAQ,GAAGvF,aAAa,CAACsF,SAAS,CAAC,CAAC,CAAC;;EAEzC;EACA,QAAOD,gBAAgB;IACnB,KAAK,IAAI;MACL,IAAGE,QAAQ,GAAG,IAAI,IAAKA,QAAQ,GAAG,IAAI,IAAIA,QAAQ,GAAG,IAAK,EACtDA,QAAQ,GAAG,IAAI;MACnB;IAEJ,KAAK,IAAI;MACL,IAAGA,QAAQ,IAAI,IAAI,IAAKA,QAAQ,GAAG,IAAI,IAAIA,QAAQ,GAAG,IAAK,EACvDA,QAAQ,GAAG,IAAI;MACnB;IAEJ,KAAK,IAAI;MACL,IAAGA,QAAQ,GAAG,IAAI,IAAIA,QAAQ,GAAG,IAAI,EACjCA,QAAQ,GAAG,IAAI;MACnB;IAEJ,KAAK,IAAI;MACL,IAAGA,QAAQ,GAAG,IAAI,IAAIA,QAAQ,GAAG,IAAI,EAAE;QACnC1E,QAAQ,CAAC;UAAEoB,eAAe,EAAE;QAAK,CAAC,CAAC;QACnC;MACJ;MACA;IAEJ;MACIpB,QAAQ,CAAC;QAAEoB,eAAe,EAAE;MAAK,CAAC,CAAC;MACnC;EACR;;EAEA;EACA,MAAMuD,OAAO,GAAG;IACZ,IAAI,EAAE,WAAW;IACjB,IAAI,EAAE,WAAW;IACjB,IAAI,EAAE;EACV,CAAC;EAED,MAAMC,GAAG,GAAG3F,OAAO,CAAC,iBAAiB,CAAC;EACtC,IAAG2F,GAAG,EAAE;IACJ,IAAGA,GAAG,CAACC,MAAM,EACTF,OAAO,CAAC,IAAI,CAAC,GAAGC,GAAG,CAACC,MAAM;IAC9B,IAAGD,GAAG,CAACE,IAAI,EACPH,OAAO,CAAC,IAAI,CAAC,GAAGC,GAAG,CAACE,IAAI;IAC5B,IAAGF,GAAG,CAACG,OAAO,EACVJ,OAAO,CAAC,IAAI,CAAC,GAAGC,GAAG,CAACG,OAAO;EACnC;EAEA,MAAMxF,cAAc,GAAGO,MAAM,CAACyE,wBAAwB,CAACxE,MAAM,CAAC;EAC9DT,qBAAqB,CAACC,cAAc,EAAE,UAASK,GAAG,EAAEF,KAAK,EAAE;IACvD,IAAGE,GAAG,EAAE;MACJI,QAAQ,CAACJ,GAAG,CAAC;MACb;IACJ;IAEA,MAAMoF,WAAW,GAAGtF,KAAK;IAEzB,KAAI,MAAMuF,CAAC,IAAIC,MAAM,CAACC,IAAI,CAACH,WAAW,CAAC,EAAE;MACrC,MAAM/D,CAAC,GAAGZ,QAAQ,CAAC4E,CAAC,CAAC;MACrB,IAAG,CAACG,KAAK,CAACnE,CAAC,CAAC,IAAIA,CAAC,IAAI,CAAC,IAAIA,CAAC,IAAI,GAAG,EAC9B0D,OAAO,CAAC1D,CAAC,CAAC,GAAG+D,WAAW,CAACC,CAAC,CAAC;IACnC;;IAEA;IACA,IAAG,CAACN,OAAO,CAACD,QAAQ,CAAC,EAAE;MACnB,IAAGF,gBAAgB,KAAK,IAAI,EAAE;QAC1BxE,QAAQ,CAAC;UAAEoB,eAAe,EAAE;QAAK,CAAC,CAAC;QACnC;MACJ;MAEAsD,QAAQ,GAAG,IAAI;IACnB;IAEA,MAAMW,GAAG,GAAG,EAAE;IACd,IAAItB,WAAW,GAAG,CAAC,GAAGM,cAAc,GAAG,CAAC,CAAC,CAAC;IAC1C,IAAIiB,MAAM,GAAG,CAAC;IACd,IAAIC,eAAe,GAAG,IAAI;IAE1B,MAAMC,YAAY,GAAGN,MAAM,CAACC,IAAI,CAACR,OAAO,CAAC;;IAEzC;IACA,KAAI,IAAIlB,EAAE,IAAI+B,YAAY,EAAE;MACxB/B,EAAE,GAAGpD,QAAQ,CAACoD,EAAE,CAAC;MAEjB,IAAG2B,KAAK,CAAC3B,EAAE,CAAC,EACR;;MAEJ;MACA,IAAGA,EAAE,GAAG,IAAI,IAAKA,EAAE,GAAG,IAAI,IAAIA,EAAE,GAAG,IAAK,IAAIA,EAAE,GAAG,IAAI,EAAE;QACnDzD,QAAQ,CAAC;UAAEoB,eAAe,EAAE,IAAI;UAAEC,GAAG,EAAE,6DAA6D,GAAGoC;QAAG,CAAC,CAAC;MAChH;MAEA,IAAGA,EAAE,GAAG,IAAI,EACR8B,eAAe,GAAG,IAAI;MAC1B,IAAG9B,EAAE,GAAG,IAAI,EACR8B,eAAe,GAAG,IAAI;;MAE1B;MACA,IAAGb,QAAQ,GAAGjB,EAAE,EACZ;;MAEJ;MACA,IAAGkB,OAAO,CAAClB,EAAE,CAAC,CAACrE,MAAM,GAAGkF,eAAe,EAAE;QACrCtE,QAAQ,CAAC;UAAEoB,eAAe,EAAE,IAAI;UAC5BC,GAAG,EAAE,wDAAwD,GACjDiD;QAAgB,CAAC,CAAC;MACtC;MAEA,IAAGgB,MAAM,KAAK,CAAC,EACX;MAEJ,IAAGX,OAAO,CAAClB,EAAE,CAAC,CAACrE,MAAM,GAAG,CAAC,GAAGgF,SAAS,GAAGL,WAAW,EAAE;QACjD,IAAGuB,MAAM,KAAK,CAAC,EACXA,MAAM,GAAG7B,EAAE;MACnB,CAAC,MACI;QACDM,WAAW,IAAIY,OAAO,CAAClB,EAAE,CAAC,CAACrE,MAAM,GAAG,CAAC;QACrCiG,GAAG,CAAClC,IAAI,CAACM,EAAE,CAAC;;QAEZ;QACA,IAAGe,gBAAgB,KAAK,IAAI,EACxB;MACR;IACJ;IAEAa,GAAG,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKtF,QAAQ,CAACqF,CAAC,CAAC,GAAGrF,QAAQ,CAACsF,CAAC,CAAC,CAAC;IAC7C,MAAMrF,cAAc,GAAGC,MAAM,CAACC,KAAK,CAACuD,WAAW,CAAC;IAEhD,IAAI9C,CAAC,GAAG,CAAC;IACTA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC,EAAE,EAAEQ,CAAC,CAAC,CAAC,CAAmC;IACxEA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC+D,gBAAgB,EAAEvD,CAAC,CAAC;IAClDA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC8E,eAAe,EAAEtE,CAAC,CAAC;IACjD,IAAGqE,MAAM,KAAK,CAAC;MAAyD;MACpErE,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC,IAAI,EAAEQ,CAAC,CAAC,CAAC,KAEvCA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC,IAAI,EAAEQ,CAAC,CAAC;IAE1CA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC6E,MAAM,EAAErE,CAAC,CAAC,CAAC,CAA+B;IACxEA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAAC4E,GAAG,CAACjG,MAAM,EAAE6B,CAAC,CAAC,CAAC,CAA2B;;IAExE,KAAIwC,EAAE,IAAI4B,GAAG,EAAE;MACXpE,CAAC,GAAGX,cAAc,CAACG,UAAU,CAACgD,EAAE,EAAExC,CAAC,CAAC,CAAC,CAA+B;MACpEA,CAAC,GAAGX,cAAc,CAACG,UAAU,CAACkE,OAAO,CAAClB,EAAE,CAAC,CAACrE,MAAM,EAAE6B,CAAC,CAAC,CAAC,CAAe;MACpEA,CAAC,IAAIX,cAAc,CAACsF,KAAK,CAACjB,OAAO,CAAClB,EAAE,CAAC,EAAExC,CAAC,EAAE0D,OAAO,CAAClB,EAAE,CAAC,CAACrE,MAAM,CAAC,CAAC,CAAM;IACxE;IAEAY,QAAQ,CAAC,IAAI,EAAEM,cAAc,CAAC;EAClC,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACAuF,MAAM,CAACC,OAAO,GAAG;EACbC,yBAAyB,EAAElG,gCAAgC;EAC3DmG,qBAAqB,EAAE1E,4BAA4B;EACnD2E,0BAA0B,EAAEjE,iCAAiC;EAC7DkE,kBAAkB,EAAE9D,yBAAyB;EAC7C+D,SAAS,EAAE3D,gBAAgB;EAC3B4D,mBAAmB,EAAEzD,0BAA0B;EAC/C0D,wBAAwB,EAAExD,+BAA+B;EACzDyD,kBAAkB,EAAEvD,yBAAyB;EAC7CwD,sBAAsB,EAAElD,6BAA6B;EACrDG,cAAc,EAAED,qBAAqB;EACrCiD,SAAS,EAAEvC;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}