{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst HOST = \"127.0.0.1\";\nconst UNIT_ID = 255; // listen to all adresses\nconst MODBUS_PORT = 502;\n\n// Not really its official length, but we parse UnitID as part of PDU\nconst MBAP_LEN = 6;\n\n/* Get Handlers\n */\nconst handlers = require(\"./servertcp_handler\");\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"../utils/buffer_bit\")();\nconst crc16 = require(\"../utils/crc16\");\n\n/**\n * Helper function for sending debug objects.\n *\n * @param {string} text - text of message, an error or an action\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code.\n * @param {Buffer} requestBuffer - request Buffer from client\n * @returns undefined\n * @private\n */\nfunction _serverDebug(text, unitID, functionCode, responseBuffer) {\n  // If no responseBuffer, then assume this is an error\n  // o/w assume an action\n  if (typeof responseBuffer === \"undefined\") {\n    modbusSerialDebug({\n      error: text,\n      unitID: unitID,\n      functionCode: functionCode\n    });\n  } else {\n    modbusSerialDebug({\n      action: text,\n      unitID: unitID,\n      functionCode: functionCode,\n      responseBuffer: responseBuffer.toString(\"hex\")\n    });\n  }\n}\n\n/**\n * Helper function for creating callback functions.\n *\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code\n * @param {function} sockWriter - write buffer (or error) to tcp socket\n * @returns {function} - a callback function\n * @private\n */\nfunction _callbackFactory(unitID, functionCode, sockWriter) {\n  return function cb(err, responseBuffer) {\n    // If we have an error.\n    if (err) {\n      let errorCode = 0x04; // slave device failure\n      if (!isNaN(err.modbusErrorCode)) {\n        errorCode = err.modbusErrorCode;\n      }\n\n      // Set an error response\n      functionCode = parseInt(functionCode) | 0x80;\n      responseBuffer = Buffer.alloc(3 + 2);\n      responseBuffer.writeUInt8(errorCode, 2);\n      _serverDebug(\"error processing response\", unitID, functionCode);\n    }\n\n    // If we do not have a responseBuffer\n    if (!responseBuffer) {\n      _serverDebug(\"no response buffer\", unitID, functionCode);\n      return sockWriter(null, responseBuffer);\n    }\n\n    // add unit number and function code\n    responseBuffer.writeUInt8(unitID, 0);\n    responseBuffer.writeUInt8(functionCode, 1);\n\n    // Add crc\n    const crc = crc16(responseBuffer.slice(0, -2));\n    responseBuffer.writeUInt16LE(crc, responseBuffer.length - 2);\n\n    // Call callback function\n    _serverDebug(\"server response\", unitID, functionCode, responseBuffer);\n    return sockWriter(null, responseBuffer);\n  };\n}\n\n/**\n * Parse a ModbusRTU buffer and return an answer buffer.\n *\n * @param {Buffer} requestBuffer - request Buffer from client\n * @param {object} vector - vector of functions for read and write\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @param {int} serverUnitID - the server's unitID\n * @param {function} sockWriter - write buffer (or error) to tcp socket\n * @param {object} options - the options object\n * @returns undefined\n * @private\n */\nfunction _parseModbusBuffer(requestBuffer, vector, serverUnitID, sockWriter, options) {\n  // Check requestBuffer length\n  if (!requestBuffer || requestBuffer.length < MBAP_LEN) {\n    modbusSerialDebug(\"wrong size of request Buffer \" + requestBuffer.length);\n    return;\n  }\n  const unitID = requestBuffer[0];\n  let functionCode = requestBuffer[1];\n  const crc = requestBuffer[requestBuffer.length - 2] + requestBuffer[requestBuffer.length - 1] * 0x100;\n\n  // if crc is bad, ignore message\n  if (crc !== crc16(requestBuffer.slice(0, -2))) {\n    modbusSerialDebug(\"wrong CRC of request Buffer\");\n    return;\n  }\n\n  // if crc is bad, ignore message\n  if (serverUnitID !== 255 && serverUnitID !== unitID) {\n    modbusSerialDebug(\"wrong unitID\");\n    return;\n  }\n  modbusSerialDebug(\"request for function code \" + functionCode);\n  const cb = _callbackFactory(unitID, functionCode, sockWriter);\n  switch (parseInt(functionCode)) {\n    case 1:\n    case 2:\n      handlers.readCoilsOrInputDiscretes(requestBuffer, vector, unitID, cb, functionCode);\n      break;\n    case 3:\n      if (options.enron) {\n        handlers.readMultipleRegistersEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n      } else {\n        handlers.readMultipleRegisters(requestBuffer, vector, unitID, cb);\n      }\n      break;\n    case 4:\n      handlers.readInputRegisters(requestBuffer, vector, unitID, cb);\n      break;\n    case 5:\n      handlers.writeCoil(requestBuffer, vector, unitID, cb);\n      break;\n    case 6:\n      if (options.enron) {\n        handlers.writeSingleRegisterEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n      } else {\n        handlers.writeSingleRegister(requestBuffer, vector, unitID, cb);\n      }\n      break;\n    case 15:\n      handlers.forceMultipleCoils(requestBuffer, vector, unitID, cb);\n      break;\n    case 16:\n      handlers.writeMultipleRegisters(requestBuffer, vector, unitID, cb);\n      break;\n    case 43:\n      handlers.handleMEI(requestBuffer, vector, unitID, cb);\n      break;\n    default:\n      {\n        const errorCode = 0x01; // illegal function\n\n        // set an error response\n        functionCode = parseInt(functionCode) | 0x80;\n        const responseBuffer = Buffer.alloc(3 + 2);\n        responseBuffer.writeUInt8(errorCode, 2);\n        modbusSerialDebug({\n          error: \"Illegal function\",\n          functionCode: functionCode\n        });\n        cb({\n          modbusErrorCode: errorCode\n        }, responseBuffer);\n      }\n  }\n}\nclass ServerTCP extends EventEmitter {\n  /**\n   * Class making ModbusTCP server.\n   *\n   * @param vector - vector of server functions (see examples/server.js)\n   * @param options - server options (host (IP), port, debug (true/false), unitID, enron? (true/false), enronTables? (object))\n   * @constructor\n   */\n  constructor(vector, options) {\n    super();\n    const modbus = this;\n    options = options || {};\n\n    // create a tcp server\n    modbus._server = net.createServer();\n    modbus._server.on(\"error\", function (error) {\n      modbus.emit(\"serverError\", error);\n    });\n    modbus._server.listen({\n      port: options.port || MODBUS_PORT,\n      host: options.host || HOST\n    }, function () {\n      modbus.emit(\"initialized\");\n    });\n\n    // create a server unit id\n    const serverUnitID = options.unitID || UNIT_ID;\n\n    // remember open sockets\n    modbus.socks = new Map();\n    modbus._server.on(\"connection\", function (sock) {\n      let recvBuffer = Buffer.from([]);\n      modbus.socks.set(sock, 0);\n      modbusSerialDebug({\n        action: \"connected\",\n        address: sock.address(),\n        remoteAddress: sock.remoteAddress,\n        localPort: sock.localPort\n      });\n      sock.once(\"close\", function () {\n        modbusSerialDebug({\n          action: \"closed\"\n        });\n        modbus.socks.delete(sock);\n      });\n      sock.on(\"data\", function (data) {\n        modbusSerialDebug({\n          action: \"socket data\",\n          data: data\n        });\n        recvBuffer = Buffer.concat([recvBuffer, data], recvBuffer.length + data.length);\n        while (recvBuffer.length > MBAP_LEN) {\n          const transactionsId = recvBuffer.readUInt16BE(0);\n          const pduLen = recvBuffer.readUInt16BE(4);\n\n          // Check the presence of the full request (MBAP + PDU)\n          if (recvBuffer.length - MBAP_LEN < pduLen) break;\n\n          // remove mbap and add crc16\n          const requestBuffer = Buffer.alloc(pduLen + 2);\n          recvBuffer.copy(requestBuffer, 0, MBAP_LEN, MBAP_LEN + pduLen);\n\n          // Move receive buffer on\n          recvBuffer = recvBuffer.slice(MBAP_LEN + pduLen);\n          const crc = crc16(requestBuffer.slice(0, -2));\n          requestBuffer.writeUInt16LE(crc, requestBuffer.length - 2);\n          modbusSerialDebug({\n            action: \"receive\",\n            data: requestBuffer,\n            requestBufferLength: requestBuffer.length\n          });\n          modbusSerialDebug(JSON.stringify({\n            action: \"receive\",\n            data: requestBuffer\n          }));\n          const sockWriter = function (err, responseBuffer) {\n            if (err) {\n              modbus.emit(\"error\", err);\n              return;\n            }\n\n            // send data back\n            if (responseBuffer) {\n              // remove crc and add mbap\n              const outTcp = Buffer.alloc(responseBuffer.length + 6 - 2);\n              outTcp.writeUInt16BE(transactionsId, 0);\n              outTcp.writeUInt16BE(0, 2);\n              outTcp.writeUInt16BE(responseBuffer.length - 2, 4);\n              responseBuffer.copy(outTcp, 6);\n              modbusSerialDebug({\n                action: \"send\",\n                data: responseBuffer\n              });\n              modbusSerialDebug(JSON.stringify({\n                action: \"send string\",\n                data: responseBuffer\n              }));\n\n              // write to port\n              sock.write(outTcp);\n            }\n          };\n\n          // parse the modbusRTU buffer\n          setTimeout(_parseModbusBuffer.bind(this, requestBuffer, vector, serverUnitID, sockWriter, options), 0);\n        }\n      });\n      sock.on(\"error\", function (err) {\n        modbusSerialDebug(JSON.stringify({\n          action: \"socket error\",\n          data: err\n        }));\n        modbus.emit(\"socketError\", err);\n      });\n    });\n  }\n\n  /**\n  * Delegate the close server method to backend.\n  *\n  * @param callback\n  */\n  close(callback) {\n    const modbus = this;\n\n    // close the net port if exist\n    if (modbus._server) {\n      modbus._server.removeAllListeners(\"data\");\n      modbus._server.close(callback);\n      modbus.socks.forEach(function (e, sock) {\n        sock.destroy();\n      });\n      modbusSerialDebug({\n        action: \"close server\"\n      });\n    } else {\n      modbusSerialDebug({\n        action: \"close server\",\n        warning: \"server already closed\"\n      });\n    }\n  }\n}\n\n/**\n * ServerTCP interface export.\n * @type {ServerTCP}\n */\nmodule.exports = ServerTCP;","map":{"version":3,"names":["events","require","EventEmitter","net","modbusSerialDebug","HOST","UNIT_ID","MODBUS_PORT","MBAP_LEN","handlers","crc16","_serverDebug","text","unitID","functionCode","responseBuffer","error","action","toString","_callbackFactory","sockWriter","cb","err","errorCode","isNaN","modbusErrorCode","parseInt","Buffer","alloc","writeUInt8","crc","slice","writeUInt16LE","length","_parseModbusBuffer","requestBuffer","vector","serverUnitID","options","readCoilsOrInputDiscretes","enron","readMultipleRegistersEnron","enronTables","readMultipleRegisters","readInputRegisters","writeCoil","writeSingleRegisterEnron","writeSingleRegister","forceMultipleCoils","writeMultipleRegisters","handleMEI","ServerTCP","constructor","modbus","_server","createServer","on","emit","listen","port","host","socks","Map","sock","recvBuffer","from","set","address","remoteAddress","localPort","once","delete","data","concat","transactionsId","readUInt16BE","pduLen","copy","requestBufferLength","JSON","stringify","outTcp","writeUInt16BE","write","setTimeout","bind","close","callback","removeAllListeners","forEach","e","destroy","warning","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/servers/servertcp.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst net = require(\"net\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst HOST = \"127.0.0.1\";\nconst UNIT_ID = 255; // listen to all adresses\nconst MODBUS_PORT = 502;\n\n// Not really its official length, but we parse UnitID as part of PDU\nconst MBAP_LEN = 6;\n\n/* Get Handlers\n */\nconst handlers = require(\"./servertcp_handler\");\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"../utils/buffer_bit\")();\nconst crc16 = require(\"../utils/crc16\");\n\n/**\n * Helper function for sending debug objects.\n *\n * @param {string} text - text of message, an error or an action\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code.\n * @param {Buffer} requestBuffer - request Buffer from client\n * @returns undefined\n * @private\n */\nfunction _serverDebug(text, unitID, functionCode, responseBuffer) {\n    // If no responseBuffer, then assume this is an error\n    // o/w assume an action\n    if (typeof responseBuffer === \"undefined\") {\n        modbusSerialDebug({\n            error: text,\n            unitID: unitID,\n            functionCode: functionCode\n        });\n\n    } else {\n        modbusSerialDebug({\n            action: text,\n            unitID: unitID,\n            functionCode: functionCode,\n            responseBuffer: responseBuffer.toString(\"hex\")\n        });\n    }\n}\n\n/**\n * Helper function for creating callback functions.\n *\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code\n * @param {function} sockWriter - write buffer (or error) to tcp socket\n * @returns {function} - a callback function\n * @private\n */\nfunction _callbackFactory(unitID, functionCode, sockWriter) {\n    return function cb(err, responseBuffer) {\n        // If we have an error.\n        if (err) {\n            let errorCode = 0x04; // slave device failure\n            if (!isNaN(err.modbusErrorCode)) {\n                errorCode = err.modbusErrorCode;\n            }\n\n            // Set an error response\n            functionCode = parseInt(functionCode) | 0x80;\n            responseBuffer = Buffer.alloc(3 + 2);\n            responseBuffer.writeUInt8(errorCode, 2);\n\n            _serverDebug(\"error processing response\", unitID, functionCode);\n        }\n\n        // If we do not have a responseBuffer\n        if (!responseBuffer) {\n            _serverDebug(\"no response buffer\", unitID, functionCode);\n            return sockWriter(null, responseBuffer);\n        }\n\n        // add unit number and function code\n        responseBuffer.writeUInt8(unitID, 0);\n        responseBuffer.writeUInt8(functionCode, 1);\n\n        // Add crc\n        const crc = crc16(responseBuffer.slice(0, -2));\n        responseBuffer.writeUInt16LE(crc, responseBuffer.length - 2);\n\n        // Call callback function\n        _serverDebug(\"server response\", unitID, functionCode, responseBuffer);\n        return sockWriter(null, responseBuffer);\n    };\n}\n\n/**\n * Parse a ModbusRTU buffer and return an answer buffer.\n *\n * @param {Buffer} requestBuffer - request Buffer from client\n * @param {object} vector - vector of functions for read and write\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @param {int} serverUnitID - the server's unitID\n * @param {function} sockWriter - write buffer (or error) to tcp socket\n * @param {object} options - the options object\n * @returns undefined\n * @private\n */\nfunction _parseModbusBuffer(requestBuffer, vector, serverUnitID, sockWriter, options) {\n    // Check requestBuffer length\n    if (!requestBuffer || requestBuffer.length < MBAP_LEN) {\n        modbusSerialDebug(\"wrong size of request Buffer \" + requestBuffer.length);\n        return;\n    }\n\n    const unitID = requestBuffer[0];\n    let functionCode = requestBuffer[1];\n    const crc = requestBuffer[requestBuffer.length - 2] + requestBuffer[requestBuffer.length - 1] * 0x100;\n\n    // if crc is bad, ignore message\n    if (crc !== crc16(requestBuffer.slice(0, -2))) {\n        modbusSerialDebug(\"wrong CRC of request Buffer\");\n        return;\n    }\n\n    // if crc is bad, ignore message\n    if (serverUnitID !== 255 && serverUnitID !== unitID) {\n        modbusSerialDebug(\"wrong unitID\");\n        return;\n    }\n\n    modbusSerialDebug(\"request for function code \" + functionCode);\n    const cb = _callbackFactory(unitID, functionCode, sockWriter);\n\n    switch (parseInt(functionCode)) {\n        case 1:\n        case 2:\n            handlers.readCoilsOrInputDiscretes(requestBuffer, vector, unitID, cb, functionCode);\n            break;\n        case 3:\n            if (options.enron) {\n                handlers.readMultipleRegistersEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n            } else {\n                handlers.readMultipleRegisters(requestBuffer, vector, unitID, cb);\n            }\n            break;\n        case 4:\n            handlers.readInputRegisters(requestBuffer, vector, unitID, cb);\n            break;\n        case 5:\n            handlers.writeCoil(requestBuffer, vector, unitID, cb);\n            break;\n        case 6:\n            if (options.enron) {\n                handlers.writeSingleRegisterEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n            } else {\n                handlers.writeSingleRegister(requestBuffer, vector, unitID, cb);\n            }\n            break;\n        case 15:\n            handlers.forceMultipleCoils(requestBuffer, vector, unitID, cb);\n            break;\n        case 16:\n            handlers.writeMultipleRegisters(requestBuffer, vector, unitID, cb);\n            break;\n        case 43:\n            handlers.handleMEI(requestBuffer, vector, unitID, cb);\n            break;\n        default: {\n            const errorCode = 0x01; // illegal function\n\n            // set an error response\n            functionCode = parseInt(functionCode) | 0x80;\n            const responseBuffer = Buffer.alloc(3 + 2);\n            responseBuffer.writeUInt8(errorCode, 2);\n\n            modbusSerialDebug({\n                error: \"Illegal function\",\n                functionCode: functionCode\n            });\n\n            cb({ modbusErrorCode: errorCode }, responseBuffer);\n        }\n    }\n}\n\nclass ServerTCP extends EventEmitter {\n    /**\n     * Class making ModbusTCP server.\n     *\n     * @param vector - vector of server functions (see examples/server.js)\n     * @param options - server options (host (IP), port, debug (true/false), unitID, enron? (true/false), enronTables? (object))\n     * @constructor\n     */\n    constructor(vector, options) {\n        super();\n\n        const modbus = this;\n        options = options || {};\n\n        // create a tcp server\n        modbus._server = net.createServer();\n        modbus._server.on(\"error\", function(error) {\n            modbus.emit(\"serverError\", error);\n        });\n        modbus._server.listen({\n            port: options.port || MODBUS_PORT,\n            host: options.host || HOST\n        }, function() {\n            modbus.emit(\"initialized\");\n        });\n\n        // create a server unit id\n        const serverUnitID = options.unitID || UNIT_ID;\n\n        // remember open sockets\n        modbus.socks = new Map();\n\n        modbus._server.on(\"connection\", function(sock) {\n            let recvBuffer = Buffer.from([]);\n            modbus.socks.set(sock, 0);\n\n            modbusSerialDebug({\n                action: \"connected\",\n                address: sock.address(),\n                remoteAddress: sock.remoteAddress,\n                localPort: sock.localPort\n            });\n\n            sock.once(\"close\", function() {\n                modbusSerialDebug({\n                    action: \"closed\"\n                });\n                modbus.socks.delete(sock);\n            });\n\n            sock.on(\"data\", function(data) {\n                modbusSerialDebug({ action: \"socket data\", data: data });\n                recvBuffer = Buffer.concat([recvBuffer, data], recvBuffer.length + data.length);\n\n                while(recvBuffer.length > MBAP_LEN) {\n                    const transactionsId = recvBuffer.readUInt16BE(0);\n                    const pduLen = recvBuffer.readUInt16BE(4);\n\n                    // Check the presence of the full request (MBAP + PDU)\n                    if(recvBuffer.length - MBAP_LEN < pduLen)\n                        break;\n\n                    // remove mbap and add crc16\n                    const requestBuffer = Buffer.alloc(pduLen + 2);\n                    recvBuffer.copy(requestBuffer, 0, MBAP_LEN, MBAP_LEN + pduLen);\n\n                    // Move receive buffer on\n                    recvBuffer = recvBuffer.slice(MBAP_LEN + pduLen);\n\n                    const crc = crc16(requestBuffer.slice(0, -2));\n                    requestBuffer.writeUInt16LE(crc, requestBuffer.length - 2);\n\n                    modbusSerialDebug({ action: \"receive\", data: requestBuffer, requestBufferLength: requestBuffer.length });\n                    modbusSerialDebug(JSON.stringify({ action: \"receive\", data: requestBuffer }));\n\n                    const sockWriter = function(err, responseBuffer) {\n                        if (err) {\n                            modbus.emit(\"error\", err);\n                            return;\n                        }\n\n                        // send data back\n                        if (responseBuffer) {\n                            // remove crc and add mbap\n                            const outTcp = Buffer.alloc(responseBuffer.length + 6 - 2);\n                            outTcp.writeUInt16BE(transactionsId, 0);\n                            outTcp.writeUInt16BE(0, 2);\n                            outTcp.writeUInt16BE(responseBuffer.length - 2, 4);\n                            responseBuffer.copy(outTcp, 6);\n\n                            modbusSerialDebug({ action: \"send\", data: responseBuffer });\n                            modbusSerialDebug(JSON.stringify({ action: \"send string\", data: responseBuffer }));\n\n                            // write to port\n                            sock.write(outTcp);\n                        }\n                    };\n\n                    // parse the modbusRTU buffer\n                    setTimeout(\n                        _parseModbusBuffer.bind(this,\n                            requestBuffer,\n                            vector,\n                            serverUnitID,\n                            sockWriter,\n                            options\n                        ),\n                        0\n                    );\n                }\n            });\n\n            sock.on(\"error\", function(err) {\n                modbusSerialDebug(JSON.stringify({ action: \"socket error\", data: err }));\n\n                modbus.emit(\"socketError\", err);\n            });\n        });\n    }\n\n    /**\n    * Delegate the close server method to backend.\n    *\n    * @param callback\n    */\n    close(callback) {\n        const modbus = this;\n\n        // close the net port if exist\n        if (modbus._server) {\n            modbus._server.removeAllListeners(\"data\");\n            modbus._server.close(callback);\n\n            modbus.socks.forEach(function(e, sock) {\n                sock.destroy();\n            });\n\n            modbusSerialDebug({ action: \"close server\" });\n        } else {\n            modbusSerialDebug({ action: \"close server\", warning: \"server already closed\" });\n        }\n    }\n}\n\n/**\n * ServerTCP interface export.\n * @type {ServerTCP}\n */\nmodule.exports = ServerTCP;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}