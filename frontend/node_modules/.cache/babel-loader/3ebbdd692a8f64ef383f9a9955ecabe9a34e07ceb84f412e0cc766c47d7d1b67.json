{"ast":null,"code":"\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst dgram = require(\"dgram\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst MODBUS_PORT = 502; // modbus port\nconst MAX_TRANSACTIONS = 256; // maximum transaction to wait for\nconst MIN_DATA_LENGTH = 6;\nconst MIN_MBAP_LENGTH = 6;\nconst CRC_LENGTH = 2;\nclass ModbusUdpPort extends EventEmitter {\n  /**\n   * Simulate a modbus-RTU port using modbus-udp.\n   *\n   * @param ip\n   * @param options\n   * @constructor\n   */\n  constructor(ip, options) {\n    super();\n    const modbus = this;\n    this.ip = ip;\n    this.openFlag = false;\n    this._transactionIdWrite = 1;\n    this.port = options.port || MODBUS_PORT;\n\n    // options\n    if (typeof options === \"undefined\") options = {};\n\n    // create a socket\n    this._client = dgram.createSocket(\"udp4\");\n\n    // Bind to the same port as we're sending to\n    this._client.bind();\n\n    // wait for answer\n    const self = this;\n    this._client.on(\"message\", function (data, rinfo) {\n      let buffer;\n      let crc;\n      let length;\n\n      // Filter stuff not intended for us\n      if (rinfo.address !== self.ip || rinfo.port !== self.port) {\n        return;\n      }\n\n      // data received\n      modbusSerialDebug({\n        action: \"receive udp port strings\",\n        data: data\n      });\n\n      // check data length\n      while (data.length > MIN_MBAP_LENGTH) {\n        // parse udp header length\n        length = data.readUInt16BE(4);\n\n        // cut 6 bytes of mbap and copy pdu\n        buffer = Buffer.alloc(length + CRC_LENGTH);\n        data.copy(buffer, 0, MIN_MBAP_LENGTH);\n\n        // add crc to message\n        crc = crc16(buffer.slice(0, -CRC_LENGTH));\n        buffer.writeUInt16LE(crc, buffer.length - CRC_LENGTH);\n\n        // update transaction id and emit data\n        modbus._transactionIdRead = data.readUInt16BE(0);\n        modbus.emit(\"data\", buffer);\n\n        // debug\n        modbusSerialDebug({\n          action: \"parsed udp port\",\n          buffer: buffer,\n          transactionId: modbus._transactionIdRead\n        });\n\n        // reset data\n        data = data.slice(length + MIN_MBAP_LENGTH);\n      }\n    });\n    this._client.on(\"listening\", function () {\n      modbus.openFlag = true;\n    });\n    this._client.on(\"close\", function () {\n      modbus.openFlag = false;\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this.openFlag;\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  // eslint-disable-next-line class-methods-use-this\n  open(callback) {\n    if (callback) callback(null);\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    this._client.close();\n    if (callback) callback(null);\n  }\n\n  /**\n   * Send data to a modbus-udp slave.\n   *\n   * @param data\n   */\n  write(data) {\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is too small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n\n    // remember current unit and command\n    this._id = data[0];\n    this._cmd = data[1];\n\n    // remove crc and add mbap\n    const buffer = Buffer.alloc(data.length + MIN_MBAP_LENGTH - CRC_LENGTH);\n    buffer.writeUInt16BE(this._transactionIdWrite, 0);\n    buffer.writeUInt16BE(0, 2);\n    buffer.writeUInt16BE(data.length - CRC_LENGTH, 4);\n    data.copy(buffer, MIN_MBAP_LENGTH);\n    modbusSerialDebug({\n      action: \"send modbus udp port\",\n      data: data,\n      buffer: buffer,\n      unitid: this._id,\n      functionCode: this._cmd\n    });\n\n    // send buffer via udp\n    this._client.send(buffer, 0, buffer.length, this.port, this.ip);\n\n    // set next transaction id\n    this._transactionIdWrite = (this._transactionIdWrite + 1) % MAX_TRANSACTIONS;\n  }\n}\n\n/**\n * UDP port for Modbus.\n *\n * @type {ModbusUdpPort}\n */\nmodule.exports = ModbusUdpPort;","map":{"version":3,"names":["events","require","EventEmitter","dgram","modbusSerialDebug","crc16","MODBUS_PORT","MAX_TRANSACTIONS","MIN_DATA_LENGTH","MIN_MBAP_LENGTH","CRC_LENGTH","ModbusUdpPort","constructor","ip","options","modbus","openFlag","_transactionIdWrite","port","_client","createSocket","bind","self","on","data","rinfo","buffer","crc","length","address","action","readUInt16BE","Buffer","alloc","copy","slice","writeUInt16LE","_transactionIdRead","emit","transactionId","isOpen","open","callback","close","write","_id","_cmd","writeUInt16BE","unitid","functionCode","send","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/udpport.js"],"sourcesContent":["\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst dgram = require(\"dgram\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst crc16 = require(\"../utils/crc16\");\n\n/* TODO: const should be set once, maybe */\nconst MODBUS_PORT = 502; // modbus port\nconst MAX_TRANSACTIONS = 256; // maximum transaction to wait for\nconst MIN_DATA_LENGTH = 6;\nconst MIN_MBAP_LENGTH = 6;\nconst CRC_LENGTH = 2;\n\nclass ModbusUdpPort extends EventEmitter {\n    /**\n     * Simulate a modbus-RTU port using modbus-udp.\n     *\n     * @param ip\n     * @param options\n     * @constructor\n     */\n    constructor(ip, options) {\n        super();\n\n        const modbus = this;\n        this.ip = ip;\n        this.openFlag = false;\n        this._transactionIdWrite = 1;\n        this.port = options.port || MODBUS_PORT;\n\n        // options\n        if (typeof(options) === \"undefined\") options = {};\n\n        // create a socket\n        this._client = dgram.createSocket(\"udp4\");\n\n        // Bind to the same port as we're sending to\n        this._client.bind();\n\n        // wait for answer\n        const self = this;\n        this._client.on(\"message\", function(data, rinfo) {\n            let buffer;\n            let crc;\n            let length;\n\n            // Filter stuff not intended for us\n            if(rinfo.address !== self.ip || rinfo.port !== self.port)\n            {\n                return;\n            }\n\n            // data received\n            modbusSerialDebug({ action: \"receive udp port strings\", data: data });\n\n            // check data length\n            while (data.length > MIN_MBAP_LENGTH) {\n                // parse udp header length\n                length = data.readUInt16BE(4);\n\n                // cut 6 bytes of mbap and copy pdu\n                buffer = Buffer.alloc(length + CRC_LENGTH);\n                data.copy(buffer, 0, MIN_MBAP_LENGTH);\n\n                // add crc to message\n                crc = crc16(buffer.slice(0, -CRC_LENGTH));\n                buffer.writeUInt16LE(crc, buffer.length - CRC_LENGTH);\n\n                // update transaction id and emit data\n                modbus._transactionIdRead = data.readUInt16BE(0);\n                modbus.emit(\"data\", buffer);\n\n                // debug\n                modbusSerialDebug({ action: \"parsed udp port\", buffer: buffer, transactionId: modbus._transactionIdRead });\n\n                // reset data\n                data = data.slice(length + MIN_MBAP_LENGTH);\n            }\n        });\n\n        this._client.on(\"listening\", function() {\n            modbus.openFlag = true;\n        });\n\n        this._client.on(\"close\", function() {\n            modbus.openFlag = false;\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this.openFlag;\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    // eslint-disable-next-line class-methods-use-this\n    open(callback) {\n        if (callback)\n            callback(null);\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        this._client.close();\n        if (callback)\n            callback(null);\n    }\n\n    /**\n     * Send data to a modbus-udp slave.\n     *\n     * @param data\n     */\n    write(data) {\n        if(data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\"expected length of data is too small - minimum is \" + MIN_DATA_LENGTH);\n            return;\n        }\n\n        // remember current unit and command\n        this._id = data[0];\n        this._cmd = data[1];\n\n        // remove crc and add mbap\n        const buffer = Buffer.alloc(data.length + MIN_MBAP_LENGTH - CRC_LENGTH);\n        buffer.writeUInt16BE(this._transactionIdWrite, 0);\n        buffer.writeUInt16BE(0, 2);\n        buffer.writeUInt16BE(data.length - CRC_LENGTH, 4);\n        data.copy(buffer, MIN_MBAP_LENGTH);\n\n\n        modbusSerialDebug({\n            action: \"send modbus udp port\",\n            data: data,\n            buffer: buffer,\n            unitid: this._id,\n            functionCode: this._cmd\n        });\n\n        // send buffer via udp\n        this._client.send(buffer, 0, buffer.length, this.port, this.ip);\n\n        // set next transaction id\n        this._transactionIdWrite = (this._transactionIdWrite + 1) % MAX_TRANSACTIONS;\n\n    }\n}\n\n/**\n * UDP port for Modbus.\n *\n * @type {ModbusUdpPort}\n */\nmodule.exports = ModbusUdpPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}