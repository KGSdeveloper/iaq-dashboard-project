{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2015, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\n/**\n * Adds Bit Operations to Buffer\n */\nconst addBufferBitOp = function () {\n  /**\n   * Add set one bit in a Buffer prototype.\n   *\n   * @param {boolean} value, new state of bit.\n   * @param {number} bit, The bit offset.\n   * @param {number} offset, the byte offset.\n   */\n  Buffer.prototype.writeBit = function (value, bit, offset) {\n    const byteOffset = parseInt(bit / 8 + offset);\n    const bitOffset = bit % 8;\n    const bitMask = 0x1 << bitOffset;\n\n    // get byte from buffer\n    let byte = this.readUInt8(byteOffset);\n\n    // set bit on / off\n    if (value) {\n      byte |= bitMask;\n    } else {\n      byte &= ~bitMask;\n    }\n\n    // set byte to buffer\n    this.writeUInt8(byte, byteOffset);\n  };\n\n  /**\n   * Add get one bit in a Buffer prototype.\n   *\n   * @param {boolean} bit, The bit offset.\n   * @param {number} offset, the byte offset.\n   *\n   * @return {boolean} the state of the bit.\n   */\n  Buffer.prototype.readBit = function (bit, offset) {\n    const byteOffset = parseInt(bit / 8 + offset);\n    const bitOffset = bit % 8;\n    const bitMask = 0x1 << bitOffset;\n\n    // get byte from buffer\n    const byte = this.readUInt8(byteOffset);\n\n    // check bit state\n    return (byte & bitMask) === bitMask;\n  };\n};\n\n/**\n * Buffer Bit operations.\n *\n * @type {addBufferBitOp}\n */\nmodule.exports = addBufferBitOp;","map":{"version":3,"names":["addBufferBitOp","Buffer","prototype","writeBit","value","bit","offset","byteOffset","parseInt","bitOffset","bitMask","byte","readUInt8","writeUInt8","readBit","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/utils/buffer_bit.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2015, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\n/**\n * Adds Bit Operations to Buffer\n */\nconst addBufferBitOp = function() {\n\n    /**\n     * Add set one bit in a Buffer prototype.\n     *\n     * @param {boolean} value, new state of bit.\n     * @param {number} bit, The bit offset.\n     * @param {number} offset, the byte offset.\n     */\n    Buffer.prototype.writeBit = function(value, bit, offset) {\n        const byteOffset = parseInt(bit / 8 + offset);\n        const bitOffset = bit % 8;\n        const bitMask = 0x1 << bitOffset;\n\n        // get byte from buffer\n        let byte = this.readUInt8(byteOffset);\n\n        // set bit on / off\n        if (value) {\n            byte |= bitMask;\n        } else {\n            byte &= ~bitMask;\n        }\n\n        // set byte to buffer\n        this.writeUInt8(byte, byteOffset);\n    };\n\n    /**\n     * Add get one bit in a Buffer prototype.\n     *\n     * @param {boolean} bit, The bit offset.\n     * @param {number} offset, the byte offset.\n     *\n     * @return {boolean} the state of the bit.\n     */\n    Buffer.prototype.readBit = function(bit, offset) {\n        const byteOffset = parseInt(bit / 8 + offset);\n        const bitOffset = bit % 8;\n        const bitMask = 0x1 << bitOffset;\n\n        // get byte from buffer\n        const byte = this.readUInt8(byteOffset);\n\n        // check bit state\n        return (byte & bitMask) === bitMask;\n    };\n};\n\n/**\n * Buffer Bit operations.\n *\n * @type {addBufferBitOp}\n */\nmodule.exports = addBufferBitOp;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMA,cAAc,GAAG,SAAAA,CAAA,EAAW;EAE9B;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,MAAM,CAACC,SAAS,CAACC,QAAQ,GAAG,UAASC,KAAK,EAAEC,GAAG,EAAEC,MAAM,EAAE;IACrD,MAAMC,UAAU,GAAGC,QAAQ,CAACH,GAAG,GAAG,CAAC,GAAGC,MAAM,CAAC;IAC7C,MAAMG,SAAS,GAAGJ,GAAG,GAAG,CAAC;IACzB,MAAMK,OAAO,GAAG,GAAG,IAAID,SAAS;;IAEhC;IACA,IAAIE,IAAI,GAAG,IAAI,CAACC,SAAS,CAACL,UAAU,CAAC;;IAErC;IACA,IAAIH,KAAK,EAAE;MACPO,IAAI,IAAID,OAAO;IACnB,CAAC,MAAM;MACHC,IAAI,IAAI,CAACD,OAAO;IACpB;;IAEA;IACA,IAAI,CAACG,UAAU,CAACF,IAAI,EAAEJ,UAAU,CAAC;EACrC,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIN,MAAM,CAACC,SAAS,CAACY,OAAO,GAAG,UAAST,GAAG,EAAEC,MAAM,EAAE;IAC7C,MAAMC,UAAU,GAAGC,QAAQ,CAACH,GAAG,GAAG,CAAC,GAAGC,MAAM,CAAC;IAC7C,MAAMG,SAAS,GAAGJ,GAAG,GAAG,CAAC;IACzB,MAAMK,OAAO,GAAG,GAAG,IAAID,SAAS;;IAEhC;IACA,MAAME,IAAI,GAAG,IAAI,CAACC,SAAS,CAACL,UAAU,CAAC;;IAEvC;IACA,OAAO,CAACI,IAAI,GAAGD,OAAO,MAAMA,OAAO;EACvC,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAK,MAAM,CAACC,OAAO,GAAGhB,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}