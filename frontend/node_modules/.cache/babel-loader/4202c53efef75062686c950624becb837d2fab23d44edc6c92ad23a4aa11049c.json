{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst {\n  SerialPort\n} = require(\"serialport\");\nconst ServerSerialPipeHandler = require(\"./serverserial_pipe_handler\");\nconst PORT = \"/dev/tty\";\nconst BAUDRATE = 9600;\nconst PARITY = \"none\";\nconst UNIT_ID = 255; // listen to all adresses\n\nconst ADDR_LEN = 1;\nconst MIN_LEN = 6;\n\n/* Get Handlers\n */\nconst handlers = require(\"./servertcp_handler\");\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"../utils/buffer_bit\")();\nconst crc16 = require(\"../utils/crc16\");\n\n/**\n * Helper function for sending debug objects.\n *\n * @param {string} text - text of message, an error or an action\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code.\n * @param {Buffer} requestBuffer - request Buffer from client\n * @returns undefined\n * @private\n */\nfunction _serverDebug(text, unitID, functionCode, responseBuffer) {\n  // If no responseBuffer, then assume this is an error\n  // o/w assume an action\n  if (typeof responseBuffer === \"undefined\") {\n    modbusSerialDebug({\n      error: text,\n      unitID: unitID,\n      functionCode: functionCode\n    });\n  } else {\n    modbusSerialDebug({\n      action: text,\n      unitID: unitID,\n      functionCode: functionCode,\n      responseBuffer: responseBuffer.toString(\"hex\")\n    });\n  }\n}\n\n/**\n * Helper function for creating callback functions.\n *\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code\n * @param {function} sockWriter - write buffer (or error) to tcp socket\n * @returns {function} - a callback function\n * @private\n */\nfunction _callbackFactory(unitID, functionCode, sockWriter) {\n  return function cb(err, responseBuffer) {\n    // If we have an error.\n    if (err) {\n      let errorCode = 0x04; // slave device failure\n      if (!isNaN(err.modbusErrorCode)) {\n        errorCode = err.modbusErrorCode;\n      }\n\n      // Set an error response\n      functionCode = parseInt(functionCode) | 0x80;\n      responseBuffer = Buffer.alloc(3 + 2);\n      responseBuffer.writeUInt8(errorCode, 2);\n      _serverDebug(\"error processing response\", unitID, functionCode);\n    }\n\n    // If we do not have a responseBuffer\n    if (!responseBuffer) {\n      _serverDebug(\"no response buffer\", unitID, functionCode);\n      return sockWriter(null, responseBuffer);\n    }\n\n    // add unit number and function code\n    responseBuffer.writeUInt8(unitID, 0);\n    responseBuffer.writeUInt8(functionCode, 1);\n\n    // Add crc\n    const crc = crc16(responseBuffer.slice(0, -2));\n    responseBuffer.writeUInt16LE(crc, responseBuffer.length - 2);\n\n    // Call callback function\n    _serverDebug(\"server response\", unitID, functionCode, responseBuffer);\n    return sockWriter(null, responseBuffer);\n  };\n}\n\n/**\n * Parse a ModbusRTU buffer and return an answer buffer.\n *\n * @param {Buffer} requestBuffer - request Buffer from client\n * @param {object} vector - vector of functions for read and write\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @param {object} options - the options object\n * @returns undefined\n * @private\n */\nfunction _parseModbusBuffer(requestBuffer, vector, serverUnitID, sockWriter, options) {\n  // Check requestBuffer length\n  if (!requestBuffer || requestBuffer.length < MIN_LEN) {\n    modbusSerialDebug(\"wrong size of request Buffer \" + requestBuffer.length);\n    return;\n  }\n  const unitID = requestBuffer[0];\n  let functionCode = requestBuffer[1];\n  const crc = requestBuffer[requestBuffer.length - 2] + requestBuffer[requestBuffer.length - 1] * 0x100;\n\n  // if crc is bad, ignore message\n  if (crc !== crc16(requestBuffer.slice(0, -2))) {\n    modbusSerialDebug(\"wrong CRC of request Buffer\");\n    return;\n  }\n\n  // if crc is bad, ignore message\n  if (serverUnitID !== 255 && serverUnitID !== unitID) {\n    modbusSerialDebug(\"wrong unitID\");\n    return;\n  }\n  modbusSerialDebug(\"request for function code \" + functionCode);\n  const cb = _callbackFactory(unitID, functionCode, sockWriter);\n  switch (parseInt(functionCode)) {\n    case 1:\n    case 2:\n      handlers.readCoilsOrInputDiscretes(requestBuffer, vector, unitID, cb, functionCode);\n      break;\n    case 3:\n      if (options && options.enron) {\n        handlers.readMultipleRegistersEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n      } else {\n        handlers.readMultipleRegisters(requestBuffer, vector, unitID, cb);\n      }\n      break;\n    case 4:\n      handlers.readInputRegisters(requestBuffer, vector, unitID, cb);\n      break;\n    case 5:\n      handlers.writeCoil(requestBuffer, vector, unitID, cb);\n      break;\n    case 6:\n      if (options && options.enron) {\n        handlers.writeSingleRegisterEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n      } else {\n        handlers.writeSingleRegister(requestBuffer, vector, unitID, cb);\n      }\n      break;\n    case 15:\n      handlers.forceMultipleCoils(requestBuffer, vector, unitID, cb);\n      break;\n    case 16:\n      handlers.writeMultipleRegisters(requestBuffer, vector, unitID, cb);\n      break;\n    case 17:\n      handlers.reportServerID(requestBuffer, vector, unitID, cb);\n      break;\n    case 43:\n      handlers.handleMEI(requestBuffer, vector, unitID, cb);\n      break;\n    default:\n      {\n        const errorCode = 0x01; // illegal function\n\n        // set an error response\n        functionCode = parseInt(functionCode) | 0x80;\n        const responseBuffer = Buffer.alloc(3 + 2);\n        responseBuffer.writeUInt8(errorCode, 2);\n        modbusSerialDebug({\n          error: \"Illegal function\",\n          functionCode: functionCode\n        });\n        cb({\n          modbusErrorCode: errorCode\n        }, responseBuffer);\n      }\n  }\n}\nclass ServerSerial extends EventEmitter {\n  /**\n   * Class making ModbusRTU server.\n   *\n   * @param vector - vector of server functions (see examples/server.js)\n   * @param options - server options (host (IP), port, debug (true/false), unitID, enron? (true/false), enronTables? (object))\n   * @param serialportOptions - additional parameters for serialport options\n   * @constructor\n   */\n  constructor(vector, options, serialportOptions) {\n    super();\n    const modbus = this;\n    options = options || {};\n    const optionsWithBinding = {\n      path: options.path || options.port || PORT,\n      baudRate: options.baudRate || options.baudrate || BAUDRATE,\n      parity: options.parity || PARITY,\n      debug: options.debug || false,\n      unitID: options.unitID || 255\n    };\n    const optionsWithSerialPortTimeoutParser = {\n      maxBufferSize: options.maxBufferSize || 65536,\n      interval: options.interval || 30\n    };\n    if (options.binding) optionsWithBinding.binding = options.binding;\n\n    // Assign extra parameters in serialport\n    const optionsWithBindingandSerialport = Object.assign({}, serialportOptions, optionsWithBinding);\n\n    // create a serial server\n    modbus._serverPath = new SerialPort(optionsWithBindingandSerialport, options.openCallback);\n\n    // create a serial server with a timeout parser\n    modbus._server = modbus._serverPath.pipe(new ServerSerialPipeHandler(optionsWithSerialPortTimeoutParser));\n\n    // Open errors will be emitted as an error event\n    modbus._server.on(\"error\", function (err) {\n      console.log(\"Error: \", err.message);\n    });\n\n    // create a server unit id\n    const serverUnitID = options.unitID || UNIT_ID;\n\n    // remember open sockets\n    modbus.socks = new Map();\n    modbus._serverPath.on(\"open\", function () {\n      modbus.socks.set(modbus._server, 0);\n      modbusSerialDebug({\n        action: \"connected\"\n        // address: sock.address(),\n        // remoteAddress: sock.remoteAddress,\n        // localPort: sock.localPort\n      });\n      modbus._server.on(\"close\", function () {\n        modbusSerialDebug({\n          action: \"closed\"\n        });\n        modbus.socks.delete(modbus._server);\n      });\n      modbus.emit(\"initialized\");\n    });\n    modbus._server.on(\"data\", function (data) {\n      let recvBuffer = Buffer.from([]);\n      modbusSerialDebug({\n        action: \"socket data\",\n        data: data\n      });\n      recvBuffer = Buffer.concat([recvBuffer, data], recvBuffer.length + data.length);\n      while (recvBuffer.length > ADDR_LEN) {\n        const requestBuffer = Buffer.alloc(recvBuffer.length);\n        recvBuffer.copy(requestBuffer, 0, 0, recvBuffer.length);\n\n        // Move receive buffer on\n        recvBuffer = recvBuffer.slice(recvBuffer.length);\n        const crc = crc16(requestBuffer.slice(0, -2));\n        requestBuffer.writeUInt16LE(crc, requestBuffer.length - 2);\n        modbusSerialDebug({\n          action: \"receive\",\n          data: requestBuffer,\n          requestBufferLength: requestBuffer.length\n        });\n        modbusSerialDebug(JSON.stringify({\n          action: \"receive\",\n          data: requestBuffer\n        }));\n        const sockWriter = function (err, responseBuffer) {\n          if (err) {\n            console.error(err, responseBuffer);\n            modbus.emit(\"error\", err);\n            return;\n          }\n\n          // send data back\n          if (responseBuffer) {\n            modbusSerialDebug({\n              action: \"send\",\n              data: responseBuffer\n            });\n            modbusSerialDebug(JSON.stringify({\n              action: \"send string\",\n              data: responseBuffer\n            }));\n\n            // write to port\n            (options.portResponse || modbus._serverPath).write(responseBuffer);\n          }\n        };\n\n        // parse the modbusRTU buffer\n        setTimeout(_parseModbusBuffer.bind(this, requestBuffer, vector, serverUnitID, sockWriter, options), 0);\n      }\n    });\n    modbus._server.on(\"error\", function (err) {\n      modbusSerialDebug(JSON.stringify({\n        action: \"socket error\",\n        data: err\n      }));\n      modbus.emit(\"socketError\", err);\n    });\n  }\n  getPort() {\n    return this._serverPath;\n  }\n\n  /**\n  * Delegate the close server method to backend.\n  *\n  * @param callback\n  */\n  close(callback) {\n    const modbus = this;\n\n    // close the net port if exist\n    if (modbus._server) {\n      modbus._server.removeAllListeners(\"data\");\n      modbus._serverPath.close(callback);\n      modbus.socks.forEach(function (e, sock) {\n        sock.destroy();\n      });\n      modbusSerialDebug({\n        action: \"close server\"\n      });\n    } else {\n      modbusSerialDebug({\n        action: \"close server\",\n        warning: \"server already closed\"\n      });\n    }\n  }\n}\n\n/**\n * ServerSerial interface export.\n * @type {ServerSerial}\n */\nmodule.exports = ServerSerial;","map":{"version":3,"names":["events","require","EventEmitter","modbusSerialDebug","SerialPort","ServerSerialPipeHandler","PORT","BAUDRATE","PARITY","UNIT_ID","ADDR_LEN","MIN_LEN","handlers","crc16","_serverDebug","text","unitID","functionCode","responseBuffer","error","action","toString","_callbackFactory","sockWriter","cb","err","errorCode","isNaN","modbusErrorCode","parseInt","Buffer","alloc","writeUInt8","crc","slice","writeUInt16LE","length","_parseModbusBuffer","requestBuffer","vector","serverUnitID","options","readCoilsOrInputDiscretes","enron","readMultipleRegistersEnron","enronTables","readMultipleRegisters","readInputRegisters","writeCoil","writeSingleRegisterEnron","writeSingleRegister","forceMultipleCoils","writeMultipleRegisters","reportServerID","handleMEI","ServerSerial","constructor","serialportOptions","modbus","optionsWithBinding","path","port","baudRate","baudrate","parity","debug","optionsWithSerialPortTimeoutParser","maxBufferSize","interval","binding","optionsWithBindingandSerialport","Object","assign","_serverPath","openCallback","_server","pipe","on","console","log","message","socks","Map","set","delete","emit","data","recvBuffer","from","concat","copy","requestBufferLength","JSON","stringify","portResponse","write","setTimeout","bind","getPort","close","callback","removeAllListeners","forEach","e","sock","destroy","warning","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/servers/serverserial.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst { SerialPort } = require(\"serialport\");\nconst ServerSerialPipeHandler = require(\"./serverserial_pipe_handler\");\n\nconst PORT = \"/dev/tty\";\nconst BAUDRATE = 9600;\nconst PARITY = \"none\";\n\nconst UNIT_ID = 255; // listen to all adresses\n\nconst ADDR_LEN = 1;\nconst MIN_LEN = 6;\n\n/* Get Handlers\n */\nconst handlers = require(\"./servertcp_handler\");\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"../utils/buffer_bit\")();\nconst crc16 = require(\"../utils/crc16\");\n\n/**\n * Helper function for sending debug objects.\n *\n * @param {string} text - text of message, an error or an action\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code.\n * @param {Buffer} requestBuffer - request Buffer from client\n * @returns undefined\n * @private\n */\nfunction _serverDebug(text, unitID, functionCode, responseBuffer) {\n    // If no responseBuffer, then assume this is an error\n    // o/w assume an action\n    if (typeof responseBuffer === \"undefined\") {\n        modbusSerialDebug({\n            error: text,\n            unitID: unitID,\n            functionCode: functionCode\n        });\n\n    } else {\n        modbusSerialDebug({\n            action: text,\n            unitID: unitID,\n            functionCode: functionCode,\n            responseBuffer: responseBuffer.toString(\"hex\")\n        });\n    }\n}\n\n/**\n * Helper function for creating callback functions.\n *\n * @param {int} unitID - Id of the requesting unit\n * @param {int} functionCode - a modbus function code\n * @param {function} sockWriter - write buffer (or error) to tcp socket\n * @returns {function} - a callback function\n * @private\n */\nfunction _callbackFactory(unitID, functionCode, sockWriter) {\n    return function cb(err, responseBuffer) {\n        // If we have an error.\n        if (err) {\n            let errorCode = 0x04; // slave device failure\n            if (!isNaN(err.modbusErrorCode)) {\n                errorCode = err.modbusErrorCode;\n            }\n\n            // Set an error response\n            functionCode = parseInt(functionCode) | 0x80;\n            responseBuffer = Buffer.alloc(3 + 2);\n            responseBuffer.writeUInt8(errorCode, 2);\n\n            _serverDebug(\"error processing response\", unitID, functionCode);\n        }\n\n        // If we do not have a responseBuffer\n        if (!responseBuffer) {\n            _serverDebug(\"no response buffer\", unitID, functionCode);\n            return sockWriter(null, responseBuffer);\n        }\n\n        // add unit number and function code\n        responseBuffer.writeUInt8(unitID, 0);\n        responseBuffer.writeUInt8(functionCode, 1);\n\n        // Add crc\n        const crc = crc16(responseBuffer.slice(0, -2));\n        responseBuffer.writeUInt16LE(crc, responseBuffer.length - 2);\n\n        // Call callback function\n        _serverDebug(\"server response\", unitID, functionCode, responseBuffer);\n        return sockWriter(null, responseBuffer);\n    };\n}\n\n/**\n * Parse a ModbusRTU buffer and return an answer buffer.\n *\n * @param {Buffer} requestBuffer - request Buffer from client\n * @param {object} vector - vector of functions for read and write\n * @param {function} callback - callback to be invoked passing {Buffer} response\n * @param {object} options - the options object\n * @returns undefined\n * @private\n */\nfunction _parseModbusBuffer(requestBuffer, vector, serverUnitID, sockWriter, options) {\n    // Check requestBuffer length\n    if (!requestBuffer || requestBuffer.length < MIN_LEN) {\n        modbusSerialDebug(\"wrong size of request Buffer \" + requestBuffer.length);\n        return;\n    }\n\n    const unitID = requestBuffer[0];\n    let functionCode = requestBuffer[1];\n    const crc = requestBuffer[requestBuffer.length - 2] + requestBuffer[requestBuffer.length - 1] * 0x100;\n\n    // if crc is bad, ignore message\n    if (crc !== crc16(requestBuffer.slice(0, -2))) {\n        modbusSerialDebug(\"wrong CRC of request Buffer\");\n        return;\n    }\n\n    // if crc is bad, ignore message\n    if (serverUnitID !== 255 && serverUnitID !== unitID) {\n        modbusSerialDebug(\"wrong unitID\");\n        return;\n    }\n\n    modbusSerialDebug(\"request for function code \" + functionCode);\n    const cb = _callbackFactory(unitID, functionCode, sockWriter);\n\n    switch (parseInt(functionCode)) {\n        case 1:\n        case 2:\n            handlers.readCoilsOrInputDiscretes(requestBuffer, vector, unitID, cb, functionCode);\n            break;\n        case 3:\n            if (options && options.enron) {\n                handlers.readMultipleRegistersEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n            } else {\n                handlers.readMultipleRegisters(requestBuffer, vector, unitID, cb);\n            }\n            break;\n        case 4:\n            handlers.readInputRegisters(requestBuffer, vector, unitID, cb);\n            break;\n        case 5:\n            handlers.writeCoil(requestBuffer, vector, unitID, cb);\n            break;\n        case 6:\n            if (options && options.enron) {\n                handlers.writeSingleRegisterEnron(requestBuffer, vector, unitID, options.enronTables, cb);\n            } else {\n                handlers.writeSingleRegister(requestBuffer, vector, unitID, cb);\n            }\n            break;\n        case 15:\n            handlers.forceMultipleCoils(requestBuffer, vector, unitID, cb);\n            break;\n        case 16:\n            handlers.writeMultipleRegisters(requestBuffer, vector, unitID, cb);\n            break;\n        case 17:\n            handlers.reportServerID(requestBuffer, vector, unitID, cb);\n            break;\n        case 43:\n            handlers.handleMEI(requestBuffer, vector, unitID, cb);\n            break;\n        default: {\n            const errorCode = 0x01; // illegal function\n\n            // set an error response\n            functionCode = parseInt(functionCode) | 0x80;\n            const responseBuffer = Buffer.alloc(3 + 2);\n            responseBuffer.writeUInt8(errorCode, 2);\n\n            modbusSerialDebug({\n                error: \"Illegal function\",\n                functionCode: functionCode\n            });\n\n            cb({ modbusErrorCode: errorCode }, responseBuffer);\n        }\n    }\n}\n\nclass ServerSerial extends EventEmitter {\n    /**\n     * Class making ModbusRTU server.\n     *\n     * @param vector - vector of server functions (see examples/server.js)\n     * @param options - server options (host (IP), port, debug (true/false), unitID, enron? (true/false), enronTables? (object))\n     * @param serialportOptions - additional parameters for serialport options\n     * @constructor\n     */\n    constructor(vector, options, serialportOptions) {\n        super();\n\n        const modbus = this;\n        options = options || {};\n\n        const optionsWithBinding = {\n            path: options.path || options.port || PORT,\n            baudRate: options.baudRate || options.baudrate || BAUDRATE,\n            parity: options.parity || PARITY,\n            debug: options.debug || false,\n            unitID: options.unitID || 255\n        };\n\n        const optionsWithSerialPortTimeoutParser = {\n            maxBufferSize: options.maxBufferSize || 65536,\n            interval: options.interval || 30\n        };\n\n        if (options.binding) optionsWithBinding.binding = options.binding;\n\n        // Assign extra parameters in serialport\n        const optionsWithBindingandSerialport = Object.assign({}, serialportOptions, optionsWithBinding);\n\n        // create a serial server\n        modbus._serverPath = new SerialPort(optionsWithBindingandSerialport, options.openCallback);\n\n        // create a serial server with a timeout parser\n        modbus._server = modbus._serverPath.pipe(new ServerSerialPipeHandler(optionsWithSerialPortTimeoutParser));\n\n        // Open errors will be emitted as an error event\n        modbus._server.on(\"error\", function(err) {\n            console.log(\"Error: \", err.message);\n        });\n\n        // create a server unit id\n        const serverUnitID = options.unitID || UNIT_ID;\n\n        // remember open sockets\n        modbus.socks = new Map();\n\n        modbus._serverPath.on(\"open\", function() {\n            modbus.socks.set(modbus._server, 0);\n\n            modbusSerialDebug({\n                action: \"connected\"\n                // address: sock.address(),\n                // remoteAddress: sock.remoteAddress,\n                // localPort: sock.localPort\n            });\n\n            modbus._server.on(\"close\", function() {\n                modbusSerialDebug({\n                    action: \"closed\"\n                });\n                modbus.socks.delete(modbus._server);\n            });\n\n            modbus.emit(\"initialized\");\n        });\n\n        modbus._server.on(\"data\", function(data) {\n            let recvBuffer = Buffer.from([]);\n\n            modbusSerialDebug({ action: \"socket data\", data: data });\n            recvBuffer = Buffer.concat([recvBuffer, data], recvBuffer.length + data.length);\n\n            while (recvBuffer.length > ADDR_LEN) {\n                const requestBuffer = Buffer.alloc(recvBuffer.length);\n                recvBuffer.copy(requestBuffer, 0, 0, recvBuffer.length);\n\n                // Move receive buffer on\n                recvBuffer = recvBuffer.slice(recvBuffer.length);\n\n                const crc = crc16(requestBuffer.slice(0, -2));\n                requestBuffer.writeUInt16LE(crc, requestBuffer.length - 2);\n\n                modbusSerialDebug({ action: \"receive\", data: requestBuffer, requestBufferLength: requestBuffer.length });\n                modbusSerialDebug(JSON.stringify({ action: \"receive\", data: requestBuffer }));\n\n                const sockWriter = function(err, responseBuffer) {\n                    if (err) {\n                        console.error(err, responseBuffer);\n                        modbus.emit(\"error\", err);\n                        return;\n                    }\n\n                    // send data back\n                    if (responseBuffer) {\n                        modbusSerialDebug({ action: \"send\", data: responseBuffer });\n                        modbusSerialDebug(JSON.stringify({ action: \"send string\", data: responseBuffer }));\n\n                        // write to port\n                        (options.portResponse || modbus._serverPath).write(responseBuffer);\n                    }\n                };\n\n                // parse the modbusRTU buffer\n                setTimeout(\n                    _parseModbusBuffer.bind(this,\n                        requestBuffer,\n                        vector,\n                        serverUnitID,\n                        sockWriter,\n                        options\n                    ),\n                    0\n                );\n            }\n        });\n\n        modbus._server.on(\"error\", function(err) {\n            modbusSerialDebug(JSON.stringify({ action: \"socket error\", data: err }));\n\n            modbus.emit(\"socketError\", err);\n        });\n\n    }\n\n    getPort() {\n        return this._serverPath;\n    }\n\n    /**\n    * Delegate the close server method to backend.\n    *\n    * @param callback\n    */\n    close(callback) {\n        const modbus = this;\n\n        // close the net port if exist\n        if (modbus._server) {\n            modbus._server.removeAllListeners(\"data\");\n            modbus._serverPath.close(callback);\n\n            modbus.socks.forEach(function(e, sock) {\n                sock.destroy();\n            });\n\n            modbusSerialDebug({ action: \"close server\" });\n        } else {\n            modbusSerialDebug({ action: \"close server\", warning: \"server already closed\" });\n        }\n    }\n}\n\n/**\n * ServerSerial interface export.\n * @type {ServerSerial}\n */\nmodule.exports = ServerSerial;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}