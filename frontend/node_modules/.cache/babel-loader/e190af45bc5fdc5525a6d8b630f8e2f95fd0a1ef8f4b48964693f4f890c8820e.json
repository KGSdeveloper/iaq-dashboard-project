{"ast":null,"code":"\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst SerialPort = require(\"serialport\").SerialPort;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/* TODO: const should be set once, maybe */\nconst EXCEPTION_LENGTH = 5;\nconst MIN_DATA_LENGTH = 6;\nconst MIN_WRITE_DATA_LENGTH = 4;\nconst MAX_BUFFER_LENGTH = 256;\nconst CRC_LENGTH = 2;\nconst READ_DEVICE_IDENTIFICATION_FUNCTION_CODE = 43;\nconst REPORT_SERVER_ID_FUNCTION_CODE = 17;\nconst LENGTH_UNKNOWN = \"unknown\";\nconst BITS_TO_NUM_OF_OBJECTS = 7;\n\n// Helper function -> Bool\n// BIT | TYPE\n// 8 | OBJECTID\n// 9 | length of OBJECTID\n// 10 -> n | the object\n// 10 + n + 1 | new object id\nconst calculateFC43Length = function (buffer, numObjects, i, bufferLength) {\n  const result = {\n    hasAllData: true\n  };\n  let currentByte = 8 + i; // current byte starts at object id.\n  if (numObjects > 0) {\n    for (let j = 0; j < numObjects; j++) {\n      if (bufferLength < currentByte) {\n        result.hasAllData = false;\n        break;\n      }\n      const objLength = buffer[currentByte + 1];\n      if (!objLength) {\n        result.hasAllData = false;\n        break;\n      }\n      currentByte += 2 + objLength;\n    }\n  }\n  if (currentByte + CRC_LENGTH > bufferLength) {\n    // still waiting on the CRC!\n    result.hasAllData = false;\n  }\n  if (result.hasAllData) {\n    result.bufLength = currentByte + CRC_LENGTH;\n  }\n  return result;\n};\nclass RTUBufferedPort extends EventEmitter {\n  /**\n   * Simulate a modbus-RTU port using buffered serial connection.\n   *\n   * @param path\n   * @param options\n   * @constructor\n   */\n  constructor(path, options) {\n    super();\n    const self = this;\n\n    // options\n    if (typeof options === \"undefined\") options = {};\n\n    // disable auto open, as we handle the open\n    options.autoOpen = false;\n\n    // internal buffer\n    this._buffer = Buffer.alloc(0);\n    this._id = 0;\n    this._cmd = 0;\n    this._length = 0;\n\n    // create the SerialPort\n    this._client = new SerialPort(Object.assign({}, {\n      path\n    }, options));\n\n    // attach an error listner on the SerialPort object\n    this._client.on(\"error\", function (error) {\n      self.emit(\"error\", error);\n    });\n\n    // attach a close listner on the SerialPort object\n    this._client.on(\"close\", function () {\n      self.emit(\"close\");\n    });\n\n    // register the port data event\n    this._client.on(\"data\", function onData(data) {\n      // add data to buffer\n      self._buffer = Buffer.concat([self._buffer, data]);\n      modbusSerialDebug({\n        action: \"receive serial rtu buffered port\",\n        data: data,\n        buffer: self._buffer\n      });\n\n      // check if buffer include a complete modbus answer\n      const expectedLength = self._length;\n      let bufferLength = self._buffer.length;\n\n      // check data length\n      if (expectedLength !== LENGTH_UNKNOWN && expectedLength < MIN_DATA_LENGTH || bufferLength < EXCEPTION_LENGTH) {\n        return;\n      }\n\n      // check buffer size for MAX_BUFFER_SIZE\n      if (bufferLength > MAX_BUFFER_LENGTH) {\n        self._buffer = self._buffer.slice(-MAX_BUFFER_LENGTH);\n        bufferLength = MAX_BUFFER_LENGTH;\n      }\n\n      // loop and check length-sized buffer chunks\n      const maxOffset = bufferLength - EXCEPTION_LENGTH;\n      for (let i = 0; i <= maxOffset; i++) {\n        const unitId = self._buffer[i];\n        const functionCode = self._buffer[i + 1];\n        if (unitId !== self._id) continue;\n        if (functionCode === self._cmd && functionCode === READ_DEVICE_IDENTIFICATION_FUNCTION_CODE) {\n          if (bufferLength <= BITS_TO_NUM_OF_OBJECTS + i) {\n            return;\n          }\n          const numObjects = self._buffer[7 + i];\n          const result = calculateFC43Length(self._buffer, numObjects, i, bufferLength);\n          if (result.hasAllData) {\n            self._emitData(i, result.bufLength);\n            return;\n          }\n        } else if (functionCode === self._cmd && functionCode === REPORT_SERVER_ID_FUNCTION_CODE) {\n          const contentLength = self._buffer[i + 2];\n          self._emitData(i, contentLength + 5); // length + serverID + status + contentLength + CRC\n          return;\n        } else {\n          if (functionCode === self._cmd && i + expectedLength <= bufferLength) {\n            self._emitData(i, expectedLength);\n            return;\n          }\n          if (functionCode === (0x80 | self._cmd) && i + EXCEPTION_LENGTH <= bufferLength) {\n            self._emitData(i, EXCEPTION_LENGTH);\n            return;\n          }\n        }\n\n        // frame header matches, but still missing bytes pending\n        if (functionCode === (0x7f & self._cmd)) break;\n      }\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this._client.isOpen;\n  }\n\n  /**\n   * Emit the received response, cut the buffer and reset the internal vars.\n   *\n   * @param {number} start The start index of the response within the buffer.\n   * @param {number} length The length of the response.\n   * @private\n   */\n  _emitData(start, length) {\n    const buffer = this._buffer.slice(start, start + length);\n    modbusSerialDebug({\n      action: \"emit data serial rtu buffered port\",\n      buffer: buffer\n    });\n    this.emit(\"data\", buffer);\n    this._buffer = this._buffer.slice(start + length);\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  open(callback) {\n    this._client.open(callback);\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    this._client.close(callback);\n    this.removeAllListeners(\"data\");\n  }\n\n  /**\n   * Send data to a modbus slave.\n   *\n   * @param {Buffer} data\n   */\n  write(data) {\n    if (data.length < MIN_WRITE_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_WRITE_DATA_LENGTH);\n      return;\n    }\n    let length = null;\n\n    // remember current unit and command\n    this._id = data[0];\n    this._cmd = data[1];\n\n    // calculate expected answer length\n    switch (this._cmd) {\n      case 1:\n      case 2:\n        length = data.readUInt16BE(4);\n        this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n        break;\n      case 3:\n      case 4:\n        length = data.readUInt16BE(4);\n        this._length = 3 + 2 * length + 2;\n        break;\n      case 5:\n      case 6:\n      case 15:\n      case 16:\n        this._length = 6 + 2;\n        break;\n      case 17:\n        // response is device specific\n        this._length = LENGTH_UNKNOWN;\n        break;\n      case 43:\n        // this function is super special\n        // you know the format of the code response\n        // and you need to continuously check that all of the data has arrived before emitting\n        // see onData for more info.\n        this._length = LENGTH_UNKNOWN;\n        break;\n      default:\n        // raise and error ?\n        this._length = 0;\n        break;\n    }\n\n    // send buffer to slave\n    this._client.write(data);\n    modbusSerialDebug({\n      action: \"send serial rtu buffered\",\n      data: data,\n      unitid: this._id,\n      functionCode: this._cmd,\n      length: this._length\n    });\n  }\n}\n\n/**\n * RTU buffered port for Modbus.\n *\n * @type {RTUBufferedPort}\n */\nmodule.exports = RTUBufferedPort;","map":{"version":3,"names":["events","require","EventEmitter","SerialPort","modbusSerialDebug","EXCEPTION_LENGTH","MIN_DATA_LENGTH","MIN_WRITE_DATA_LENGTH","MAX_BUFFER_LENGTH","CRC_LENGTH","READ_DEVICE_IDENTIFICATION_FUNCTION_CODE","REPORT_SERVER_ID_FUNCTION_CODE","LENGTH_UNKNOWN","BITS_TO_NUM_OF_OBJECTS","calculateFC43Length","buffer","numObjects","i","bufferLength","result","hasAllData","currentByte","j","objLength","bufLength","RTUBufferedPort","constructor","path","options","self","autoOpen","_buffer","Buffer","alloc","_id","_cmd","_length","_client","Object","assign","on","error","emit","onData","data","concat","action","expectedLength","length","slice","maxOffset","unitId","functionCode","_emitData","contentLength","isOpen","start","open","callback","close","removeAllListeners","write","readUInt16BE","parseInt","unitid","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/rtubufferedport.js"],"sourcesContent":["\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst SerialPort = require(\"serialport\").SerialPort;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/* TODO: const should be set once, maybe */\nconst EXCEPTION_LENGTH = 5;\nconst MIN_DATA_LENGTH = 6;\nconst MIN_WRITE_DATA_LENGTH = 4;\nconst MAX_BUFFER_LENGTH = 256;\nconst CRC_LENGTH = 2;\nconst READ_DEVICE_IDENTIFICATION_FUNCTION_CODE = 43;\nconst REPORT_SERVER_ID_FUNCTION_CODE = 17;\nconst LENGTH_UNKNOWN = \"unknown\";\nconst BITS_TO_NUM_OF_OBJECTS = 7;\n\n// Helper function -> Bool\n// BIT | TYPE\n// 8 | OBJECTID\n// 9 | length of OBJECTID\n// 10 -> n | the object\n// 10 + n + 1 | new object id\nconst calculateFC43Length = function(buffer, numObjects, i, bufferLength) {\n    const result = { hasAllData: true };\n    let currentByte = 8 + i; // current byte starts at object id.\n    if (numObjects > 0) {\n        for (let j = 0; j < numObjects; j++) {\n            if (bufferLength < currentByte) {\n                result.hasAllData = false;\n                break;\n            }\n            const objLength = buffer[currentByte + 1];\n            if (!objLength) {\n                result.hasAllData = false;\n                break;\n            }\n            currentByte += 2 + objLength;\n        }\n    }\n    if (currentByte + CRC_LENGTH > bufferLength) {\n        // still waiting on the CRC!\n        result.hasAllData = false;\n    }\n    if (result.hasAllData) {\n        result.bufLength = currentByte + CRC_LENGTH;\n    }\n    return result;\n};\n\nclass RTUBufferedPort extends EventEmitter {\n    /**\n     * Simulate a modbus-RTU port using buffered serial connection.\n     *\n     * @param path\n     * @param options\n     * @constructor\n     */\n    constructor(path, options) {\n        super();\n\n        const self = this;\n\n        // options\n        if (typeof(options) === \"undefined\") options = {};\n\n        // disable auto open, as we handle the open\n        options.autoOpen = false;\n\n        // internal buffer\n        this._buffer = Buffer.alloc(0);\n        this._id = 0;\n        this._cmd = 0;\n        this._length = 0;\n\n        // create the SerialPort\n        this._client = new SerialPort(Object.assign({}, { path }, options));\n\n        // attach an error listner on the SerialPort object\n        this._client.on(\"error\", function(error) {\n            self.emit(\"error\", error);\n        });\n\n        // attach a close listner on the SerialPort object\n        this._client.on(\"close\", function() {\n            self.emit(\"close\");\n        });\n\n        // register the port data event\n        this._client.on(\"data\", function onData(data) {\n            // add data to buffer\n            self._buffer = Buffer.concat([self._buffer, data]);\n\n            modbusSerialDebug({ action: \"receive serial rtu buffered port\", data: data, buffer: self._buffer });\n\n            // check if buffer include a complete modbus answer\n            const expectedLength = self._length;\n            let bufferLength = self._buffer.length;\n\n\n            // check data length\n            if (expectedLength !== LENGTH_UNKNOWN &&\n                expectedLength < MIN_DATA_LENGTH ||\n                bufferLength < EXCEPTION_LENGTH\n            ) { return; }\n\n            // check buffer size for MAX_BUFFER_SIZE\n            if (bufferLength > MAX_BUFFER_LENGTH) {\n                self._buffer = self._buffer.slice(-MAX_BUFFER_LENGTH);\n                bufferLength = MAX_BUFFER_LENGTH;\n            }\n\n            // loop and check length-sized buffer chunks\n            const maxOffset = bufferLength - EXCEPTION_LENGTH;\n\n            for (let i = 0; i <= maxOffset; i++) {\n                const unitId = self._buffer[i];\n                const functionCode = self._buffer[i + 1];\n\n                if (unitId !== self._id) continue;\n\n                if (functionCode === self._cmd && functionCode === READ_DEVICE_IDENTIFICATION_FUNCTION_CODE) {\n                    if (bufferLength <= BITS_TO_NUM_OF_OBJECTS + i) {\n                        return;\n                    }\n                    const numObjects = self._buffer[7 + i];\n                    const result = calculateFC43Length(self._buffer, numObjects, i, bufferLength);\n                    if (result.hasAllData) {\n                        self._emitData(i, result.bufLength);\n                        return;\n                    }\n                } else if (functionCode === self._cmd && functionCode === REPORT_SERVER_ID_FUNCTION_CODE) {\n                    const contentLength = self._buffer[i + 2];\n                    self._emitData(i, contentLength + 5); // length + serverID + status + contentLength + CRC\n                    return;\n                } else {\n                    if (functionCode === self._cmd && i + expectedLength <= bufferLength) {\n                        self._emitData(i, expectedLength);\n                        return;\n                    }\n                    if (functionCode === (0x80 | self._cmd) && i + EXCEPTION_LENGTH <= bufferLength) {\n                        self._emitData(i, EXCEPTION_LENGTH);\n                        return;\n                    }\n                }\n\n                // frame header matches, but still missing bytes pending\n                if (functionCode === (0x7f & self._cmd)) break;\n            }\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this._client.isOpen;\n    }\n\n    /**\n     * Emit the received response, cut the buffer and reset the internal vars.\n     *\n     * @param {number} start The start index of the response within the buffer.\n     * @param {number} length The length of the response.\n     * @private\n     */\n    _emitData(start, length) {\n        const buffer = this._buffer.slice(start, start + length);\n        modbusSerialDebug({ action: \"emit data serial rtu buffered port\", buffer: buffer });\n        this.emit(\"data\", buffer);\n        this._buffer = this._buffer.slice(start + length);\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    open(callback) {\n        this._client.open(callback);\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        this._client.close(callback);\n        this.removeAllListeners(\"data\");\n    }\n\n    /**\n     * Send data to a modbus slave.\n     *\n     * @param {Buffer} data\n     */\n    write(data) {\n        if(data.length < MIN_WRITE_DATA_LENGTH) {\n            modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_WRITE_DATA_LENGTH);\n            return;\n        }\n\n        let length = null;\n\n        // remember current unit and command\n        this._id = data[0];\n        this._cmd = data[1];\n\n        // calculate expected answer length\n        switch (this._cmd) {\n            case 1:\n            case 2:\n                length = data.readUInt16BE(4);\n                this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n                break;\n            case 3:\n            case 4:\n                length = data.readUInt16BE(4);\n                this._length = 3 + 2 * length + 2;\n                break;\n            case 5:\n            case 6:\n            case 15:\n            case 16:\n                this._length = 6 + 2;\n                break;\n            case 17:\n                // response is device specific\n                this._length = LENGTH_UNKNOWN;\n                break;\n            case 43:\n                // this function is super special\n                // you know the format of the code response\n                // and you need to continuously check that all of the data has arrived before emitting\n                // see onData for more info.\n                this._length = LENGTH_UNKNOWN;\n                break;\n            default:\n                // raise and error ?\n                this._length = 0;\n                break;\n        }\n\n        // send buffer to slave\n        this._client.write(data);\n\n        modbusSerialDebug({\n            action: \"send serial rtu buffered\",\n            data: data,\n            unitid: this._id,\n            functionCode: this._cmd,\n            length: this._length\n        });\n    }\n}\n\n/**\n * RTU buffered port for Modbus.\n *\n * @type {RTUBufferedPort}\n */\nmodule.exports = RTUBufferedPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}