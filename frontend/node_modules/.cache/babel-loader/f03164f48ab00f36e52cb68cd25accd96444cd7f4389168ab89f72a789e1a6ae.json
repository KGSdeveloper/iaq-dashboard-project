{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2015-2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"./utils/buffer_bit\")();\nconst crc16 = require(\"./utils/crc16\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst PORT_NOT_OPEN_MESSAGE = \"Port Not Open\";\nconst PORT_NOT_OPEN_ERRNO = \"ECONNREFUSED\";\nconst BAD_ADDRESS_MESSAGE = \"Bad Client Address\";\nconst BAD_ADDRESS_ERRNO = \"ECONNREFUSED\";\nconst TRANSACTION_TIMED_OUT_MESSAGE = \"Timed out\";\nconst TRANSACTION_TIMED_OUT_ERRNO = \"ETIMEDOUT\";\nconst modbusErrorMessages = [\"Unknown error\", \"Illegal function (device does not support this read/write function)\", \"Illegal data address (register not supported by device)\", \"Illegal data value (value cannot be written to this register)\", \"Slave device failure (device reports internal error)\", \"Acknowledge (requested data will be available later)\", \"Slave device busy (retry request again later)\", \"Negative acknowledge (slave device cannot perform programming functions)\", \"Memory parity error (slave device detected a parity error in memory)\", \"Unknown error\", \"Gateway path unavailable (misconfigured gateway)\", \"Gateway target device failed to respond (retry request again later)\"];\nconst PortNotOpenError = function () {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = PORT_NOT_OPEN_MESSAGE;\n  this.errno = PORT_NOT_OPEN_ERRNO;\n};\nconst BadAddressError = function () {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = BAD_ADDRESS_MESSAGE;\n  this.errno = BAD_ADDRESS_ERRNO;\n};\nconst TransactionTimedOutError = function () {\n  this.name = this.constructor.name;\n  this.message = TRANSACTION_TIMED_OUT_MESSAGE;\n  this.errno = TRANSACTION_TIMED_OUT_ERRNO;\n};\nconst SerialPortError = function () {\n  this.name = this.constructor.name;\n  this.message = null;\n  this.errno = \"ECONNREFUSED\";\n};\n\n/**\n * @fileoverview ModbusRTU module, exports the ModbusRTU class.\n * this class makes ModbusRTU calls fun and easy.\n *\n * Modbus is a serial communications protocol, first used in 1979.\n * Modbus is simple and robust, openly published, royalty-free and\n * easy to deploy and maintain.\n */\n\n/**\n * Parse the data for a Modbus -\n * Read Coils (FC=02, 01)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC2(data, next) {\n  const length = data.readUInt8(2);\n  const contents = [];\n  for (let i = 0; i < length; i++) {\n    let reg = data[i + 3];\n    for (let j = 0; j < 8; j++) {\n      contents.push((reg & 1) === 1);\n      reg = reg >> 1;\n    }\n  }\n  if (next) next(null, {\n    \"data\": contents,\n    \"buffer\": data.slice(3, 3 + length)\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Read Input Registers (FC=04, 03)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC3or4(data, next) {\n  const length = data.readUInt8(2);\n  const contents = [];\n  for (let i = 0; i < length; i += 2) {\n    const reg = data.readUInt16BE(i + 3);\n    contents.push(reg);\n  }\n  if (next) next(null, {\n    \"data\": contents,\n    \"buffer\": data.slice(3, 3 + length)\n  });\n}\n\n/**\n * Parse the data for a Modbus (Enron) -\n * Read Registers (FC=04, 03)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC3or4Enron(data, next) {\n  const length = data.readUInt8(2);\n  const contents = [];\n  for (let i = 0; i < length; i += 4) {\n    const reg = data.readUInt32BE(i + 3);\n    contents.push(reg);\n  }\n  if (next) next(null, {\n    \"data\": contents,\n    \"buffer\": data.slice(3, 3 + length)\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Force Single Coil (FC=05)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC5(data, next) {\n  const dataAddress = data.readUInt16BE(2);\n  const state = data.readUInt16BE(4);\n  if (next) next(null, {\n    \"address\": dataAddress,\n    \"state\": state === 0xff00\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Preset Single Registers (FC=06)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC6(data, next) {\n  const dataAddress = data.readUInt16BE(2);\n  const value = data.readUInt16BE(4);\n  if (next) next(null, {\n    \"address\": dataAddress,\n    \"value\": value\n  });\n}\n\n/**\n * Parse the data for a Modbus (Enron) -\n * Preset Single Registers (FC=06)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC6Enron(data, next) {\n  const dataAddress = data.readUInt16BE(2);\n  const value = data.readUInt32BE(4);\n  if (next) next(null, {\n    \"address\": dataAddress,\n    \"value\": value\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Preset Multiple Registers (FC=15, 16)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC16(data, next) {\n  const dataAddress = data.readUInt16BE(2);\n  const length = data.readUInt16BE(4);\n  if (next) next(null, {\n    \"address\": dataAddress,\n    \"length\": length\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Report server ID (FC=17)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC17(data, next) {\n  const length = parseInt(data.readUInt8(2));\n  const serverId = parseInt(data.readUInt8(3));\n  const running = data.readUInt8(4) === 0xFF;\n  let additionalData;\n  if (length > 2) {\n    additionalData = Buffer.alloc(length - 2);\n    // copy additional data\n    data.copy(additionalData, 0, 5, data.length - 2);\n  } else {\n    additionalData = Buffer.alloc(0);\n  }\n  if (next) next(null, {\n    serverId: serverId,\n    running: running,\n    additionalData: additionalData\n  });\n}\n\n/**\n * Parse  the data fro Modbus -\n * Read File Records\n *\n * @param {Buffer4} buffer\n * @param {Function} next\n */\nfunction _readFC20(data, next) {\n  const fileRespLength = parseInt(data.readUInt8(2));\n  const result = [];\n  for (let i = 5; i < fileRespLength + 5; i++) {\n    const reg = data.readUInt8(i);\n    result.push(reg);\n  }\n  if (next) next(null, {\n    \"data\": result,\n    \"length\": fileRespLength\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Mask Write Register (FC=22)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC22(data, next) {\n  const dataAddress = data.readUInt16BE(2);\n  const andMask = data.readUInt16BE(4);\n  const orMask = data.readUInt16BE(6);\n  if (next) next(null, {\n    \"address\": dataAddress,\n    \"andMask\": andMask,\n    \"orMask\": orMask\n  });\n}\n\n/**\n * Parse the data for a Modbus -\n * Read Device Identification (FC=43)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Modbus} modbus the client in case we need to read more device information\n * @param {Function} next the function to call next.\n */\nfunction _readFC43(data, modbus, next) {\n  const address = parseInt(data.readUInt8(0));\n  const readDeviceIdCode = parseInt(data.readUInt8(3));\n  const conformityLevel = parseInt(data.readUInt8(4));\n  const moreFollows = parseInt(data.readUInt8(5));\n  const nextObjectId = parseInt(data.readUInt8(6));\n  const numOfObjects = parseInt(data.readUInt8(7));\n  let startAt = 8;\n  const result = {};\n  // The modbus specification states that numOfObjects is the number of\n  // objects in the response, but the example on page 45 shows the total\n  // number over all responses. Therefore be careful about reading more data than available\n  for (let i = 0; i < numOfObjects && startAt < data.length; i++) {\n    const objectId = parseInt(data.readUInt8(startAt));\n    const objectLength = parseInt(data.readUInt8(startAt + 1));\n    const startOfData = startAt + 2;\n    result[objectId] = data.toString(\"ascii\", startOfData, startOfData + objectLength);\n    startAt = startOfData + objectLength;\n  }\n\n  // is it saying to follow and did you previously get data\n  // if you did not previously get data go ahead and halt to prevent an infinite loop\n  if (moreFollows && numOfObjects) {\n    const cb = function (err, data) {\n      data.data = Object.assign(data.data, result);\n      return next(err, data);\n    };\n    modbus.writeFC43(address, readDeviceIdCode, nextObjectId, cb);\n  } else if (next) {\n    next(null, {\n      data: result,\n      conformityLevel\n    });\n  }\n}\n\n/**\n * Wrapper method for writing to a port with timeout. <code><b>[this]</b></code> has the context of ModbusRTU\n * @param {Buffer} buffer The data to send\n * @private\n */\nfunction _writeBufferToPort(buffer, transactionId) {\n  const transaction = this._transactions[transactionId];\n  if (transaction) {\n    transaction._timeoutFired = false;\n    transaction._timeoutHandle = _startTimeout(this._timeout, transaction);\n\n    // If in debug mode, stash a copy of the request payload\n    if (this._debugEnabled) {\n      transaction.request = Uint8Array.prototype.slice.call(buffer);\n      transaction.responses = [];\n    }\n  }\n  this._port.write(buffer);\n}\n\n/**\n * Starts the timeout timer with the given duration.\n * If the timeout ends before it was cancelled, it will call the callback with an error.\n * @param {number} duration the timeout duration in milliseconds.\n * @param {Function} next the function to call next.\n * @return {number} The handle of the timeout\n * @private\n */\nfunction _startTimeout(duration, transaction) {\n  if (!duration) {\n    return undefined;\n  }\n  return setTimeout(function () {\n    transaction._timeoutFired = true;\n    if (transaction.next) {\n      const err = new TransactionTimedOutError();\n      if (transaction.request && transaction.responses) {\n        err.modbusRequest = transaction.request;\n        err.modbusResponses = transaction.responses;\n      }\n      transaction.next(err);\n    }\n  }, duration);\n}\n\n/**\n * Cancel the given timeout.\n *\n * @param {number} timeoutHandle The handle of the timeout\n * @private\n */\nfunction _cancelTimeout(timeoutHandle) {\n  clearTimeout(timeoutHandle);\n}\n\n/**\n * Handle incoming data from the Modbus port.\n *\n * @param {Buffer} data The data received\n * @private\n */\nfunction _onReceive(data) {\n  const modbus = this;\n  let error;\n\n  // set locale helpers variables\n  const transaction = modbus._transactions[modbus._port._transactionIdRead];\n\n  // the _transactionIdRead can be missing, ignore wrong transaction it's\n  if (!transaction) {\n    return;\n  }\n  if (transaction.responses) {\n    /* Stash what we received */\n    transaction.responses.push(Uint8Array.prototype.slice.call(data));\n  }\n\n  /* What do we do next? */\n  const next = function (err, res) {\n    if (transaction.next) {\n      /* Include request/response data if enabled */\n      if (transaction.request && transaction.responses) {\n        if (err) {\n          err.modbusRequest = transaction.request;\n          err.modbusResponses = transaction.responses;\n        }\n        if (res) {\n          res.request = transaction.request;\n          res.responses = transaction.responses;\n        }\n      }\n\n      /* Pass the data on */\n      return transaction.next(err, res);\n    }\n  };\n\n  /* cancel the timeout */\n  _cancelTimeout(transaction._timeoutHandle);\n  transaction._timeoutHandle = undefined;\n\n  /* check if the timeout fired */\n  if (transaction._timeoutFired === true) {\n    // we have already called back with an error, so don't generate a new callback\n    return;\n  }\n\n  /* check incoming data\n   */\n\n  /* check minimal length\n   */\n  if (!transaction.lengthUnknown && data.length < 5) {\n    error = \"Data length error, expected \" + transaction.nextLength + \" got \" + data.length;\n    next(new Error(error));\n    return;\n  }\n\n  /* check message CRC\n   * if CRC is bad raise an error\n   */\n  const crcIn = data.readUInt16LE(data.length - 2);\n  if (crcIn !== crc16(data.slice(0, -2))) {\n    error = \"CRC error\";\n    next(new Error(error));\n    return;\n  }\n\n  // if crc is OK, read address and function code\n  const address = data.readUInt8(0);\n  const code = data.readUInt8(1);\n\n  /* check for modbus exception\n   */\n  if (data.length >= 5 && code === (0x80 | transaction.nextCode)) {\n    const errorCode = data.readUInt8(2);\n    if (transaction.next) {\n      error = new Error(\"Modbus exception \" + errorCode + \": \" + (modbusErrorMessages[errorCode] || \"Unknown error\"));\n      error.modbusCode = errorCode;\n      next(error);\n    }\n    return;\n  }\n\n  /* check enron options are valid\n   */\n  if (modbus._enron) {\n    const example = {\n      enronTables: {\n        booleanRange: [1001, 1999],\n        shortRange: [3001, 3999],\n        longRange: [5001, 5999],\n        floatRange: [7001, 7999]\n      }\n    };\n    if (typeof modbus._enronTables === \"undefined\" || modbus._enronTables.shortRange.length !== 2 || modbus._enronTables.shortRange[0] >= modbus._enronTables.shortRange[1]) {\n      next(new Error(\"Enron table definition missing from options. Example: \" + JSON.stringify(example)));\n      return;\n    }\n  }\n\n  /* check message length\n   * if we do not expect this data\n   * raise an error\n   */\n  if (!transaction.lengthUnknown && data.length !== transaction.nextLength) {\n    error = \"Data length error, expected \" + transaction.nextLength + \" got \" + data.length;\n    next(new Error(error));\n    return;\n  }\n\n  /* check message address\n   * if we do not expect this message\n   * raise an error\n   */\n  if (Number(address) !== Number(transaction.nextAddress)) {\n    error = \"Unexpected data error, expected \" + \"address \" + transaction.nextAddress + \" got \" + address;\n    if (transaction.next) next(new Error(error));\n    return;\n  }\n\n  /* check message code\n   * if we do not expect this message\n   * raise an error\n   */\n  if (code !== transaction.nextCode) {\n    error = \"Unexpected data error, expected \" + \"code \" + transaction.nextCode + \" got \" + code;\n    if (transaction.next) next(new Error(error));\n    return;\n  }\n\n  /* parse incoming data\n   */\n  try {\n    switch (code) {\n      case 1:\n      case 2:\n        // Read Coil Status (FC=01)\n        // Read Input Status (FC=02)\n        _readFC2(data, next);\n        break;\n      case 3:\n      case 4:\n        // Read Input Registers (FC=04)\n        // Read Holding Registers (FC=03)\n        if (modbus._enron && !(transaction.nextDataAddress >= modbus._enronTables.shortRange[0] && transaction.nextDataAddress <= modbus._enronTables.shortRange[1])) {\n          _readFC3or4Enron(data, next);\n        } else {\n          _readFC3or4(data, next);\n        }\n        break;\n      case 5:\n        // Force Single Coil\n        _readFC5(data, next);\n        break;\n      case 6:\n        // Preset Single Register\n        if (modbus._enron && !(transaction.nextDataAddress >= modbus._enronTables.shortRange[0] && transaction.nextDataAddress <= modbus._enronTables.shortRange[1])) {\n          _readFC6Enron(data, next);\n        } else {\n          _readFC6(data, next);\n        }\n        break;\n      case 15:\n      case 16:\n        // Force Multiple Coils\n        // Preset Multiple Registers\n        _readFC16(data, next);\n        break;\n      case 17:\n        _readFC17(data, next);\n        break;\n      case 20:\n        _readFC20(data, transaction.next);\n        break;\n      case 22:\n        _readFC22(data, next);\n        break;\n      case 43:\n        // read device identification\n        _readFC43(data, modbus, next);\n    }\n  } catch (e) {\n    if (transaction.next) {\n      next(e);\n    }\n  }\n}\n\n/**\n * Handle SerialPort errors.\n *\n * @param {Error} error The error received\n * @private\n */\nfunction _onError(e) {\n  const err = new SerialPortError();\n  err.message = e.message;\n  err.stack = e.stack;\n  this.emit(\"error\", err);\n}\nclass ModbusRTU extends EventEmitter {\n  /**\n   * Class making ModbusRTU calls fun and easy.\n   *\n   * @param {SerialPort} port the serial port to use.\n   */\n  constructor(port) {\n    super();\n\n    // the serial port to use\n    this._port = port;\n\n    // state variables\n    this._transactions = {};\n    this._timeout = null; // timeout in msec before unanswered request throws timeout error\n    this._unitID = 1;\n\n    // Flag to indicate whether debug mode (pass-through of raw\n    // request/response) is enabled.\n    this._debugEnabled = false;\n    this._onReceive = _onReceive.bind(this);\n    this._onError = _onError.bind(this);\n  }\n\n  /**\n   * Open the serial port and register Modbus parsers\n   *\n   * @param {Function} callback the function to call next on open success\n   *      of failure.\n   */\n  open(callback) {\n    const modbus = this;\n\n    // open the serial port\n    modbus._port.open(function (error) {\n      if (error) {\n        modbusSerialDebug({\n          action: \"port open error\",\n          error: error\n        });\n        /* On serial port open error call next function */\n        if (callback) callback(error);\n      } else {\n        /* init ports transaction id and counter */\n        modbus._port._transactionIdRead = 1;\n        modbus._port._transactionIdWrite = 1;\n\n        /* On serial port success\n         * (re-)register the modbus parser functions\n         */\n        modbus._port.removeListener(\"data\", modbus._onReceive);\n        modbus._port.on(\"data\", modbus._onReceive);\n\n        /* On serial port error\n         * (re-)register the error listener function\n         */\n        modbus._port.removeListener(\"error\", modbus._onError);\n        modbus._port.on(\"error\", modbus._onError);\n\n        /* Hook the close event so we can relay it to our callers. */\n        modbus._port.once(\"close\", modbus.emit.bind(modbus, \"close\"));\n\n        /* On serial port open OK call next function with no error */\n        if (callback) callback(error);\n      }\n    });\n  }\n  get isDebugEnabled() {\n    return this._debugEnabled;\n  }\n  set isDebugEnabled(enable) {\n    enable = Boolean(enable);\n    this._debugEnabled = enable;\n  }\n  get isOpen() {\n    if (this._port) {\n      return this._port.isOpen;\n    }\n    return false;\n  }\n\n  /**\n   * Clears the timeout for all pending transactions.\n   * This essentially cancels all pending requests.\n   */\n  _cancelPendingTransactions() {\n    if (Object.keys(this._transactions).length > 0) {\n      Object.values(this._transactions).forEach(transaction => {\n        if (transaction._timeoutHandle) {\n          _cancelTimeout(transaction._timeoutHandle);\n        }\n      });\n    }\n  }\n\n  /**\n   * Close the serial port\n   *\n   * @param {Function} callback the function to call next on close success\n   *      or failure.\n   */\n  close(callback) {\n    // close the serial port if exist\n    if (this._port) {\n      this._port.removeAllListeners(\"data\");\n      this._port.close(callback);\n    } else {\n      // nothing needed to be done\n      callback();\n    }\n  }\n\n  /**\n   * Destroy the serial port\n   *\n   * @param {Function} callback the function to call next on close success\n   *      or failure.\n   */\n  destroy(callback) {\n    // cancel all pending requests as we're closing the port\n    this._cancelPendingTransactions();\n\n    // close the serial port if exist and it has a destroy function\n    if (this._port && this._port.destroy) {\n      this._port.removeAllListeners(\"data\");\n      this._port.destroy();\n      callback();\n    } else {\n      // nothing needed to be done\n      callback();\n    }\n  }\n\n  /**\n   * Write a Modbus \"Read Coil Status\" (FC=01) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the first coil.\n   * @param {number} length the total number of coils requested.\n   * @param {Function} next the function to call next.\n   */\n  writeFC1(address, dataAddress, length, next) {\n    this.writeFC2(address, dataAddress, length, next, 1);\n  }\n\n  /**\n   * Write a Modbus \"Read Input Status\" (FC=02) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the first digital input.\n   * @param {number} length the total number of digital inputs requested.\n   * @param {Function} next the function to call next.\n   */\n  writeFC2(address, dataAddress, length, next, code) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n\n    // sanity check\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n\n    // function code defaults to 2\n    code = code || 2;\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      nextLength: 3 + parseInt((length - 1) / 8 + 1) + 2,\n      next: next\n    };\n    const codeLength = 6;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    buf.writeUInt16BE(length, 4);\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Read Holding Registers\" (FC=03) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the first register.\n   * @param {number} length the total number of registers requested.\n   * @param {Function} next the function to call next.\n   */\n  writeFC3(address, dataAddress, length, next) {\n    this.writeFC4(address, dataAddress, length, next, 3);\n  }\n\n  /**\n   * Write a Modbus \"Read Input Registers\" (FC=04) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the first register.\n   * @param {number} length the total number of registers requested.\n   * @param {Function} next the function to call next.\n   */\n  writeFC4(address, dataAddress, length, next, code) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n\n    // sanity check\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n\n    // function code defaults to 4\n    code = code || 4;\n    let valueSize = 2;\n    if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n      valueSize = 4;\n    }\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextDataAddress: dataAddress,\n      nextCode: code,\n      nextLength: 3 + valueSize * length + 2,\n      next: next\n    };\n    const codeLength = 6;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    buf.writeUInt16BE(length, 4);\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Force Single Coil\" (FC=05) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the coil.\n   * @param {number} state the boolean state to write to the coil (true / false).\n   * @param {Function} next the function to call next.\n   */\n  writeFC5(address, dataAddress, state, next) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n\n    // sanity check\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n    const code = 5;\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      nextLength: 8,\n      next: next\n    };\n    const codeLength = 6;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    if (state) {\n      buf.writeUInt16BE(0xff00, 4);\n    } else {\n      buf.writeUInt16BE(0x0000, 4);\n    }\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Preset Single Register \" (FC=6) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the register.\n   * @param {number} value the value to write to the register.\n   * @param {Function} next the function to call next.\n   */\n  writeFC6(address, dataAddress, value, next) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n\n    // sanity check\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n    const code = 6;\n    let valueSize = 8;\n    if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n      valueSize = 10;\n    }\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextDataAddress: dataAddress,\n      nextCode: code,\n      nextLength: valueSize,\n      next: next\n    };\n    let codeLength = 6; // 1B deviceAddress + 1B functionCode + 2B dataAddress + (2B value | 4B value (enron))\n    if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n      codeLength = 8;\n    }\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    if (Buffer.isBuffer(value)) {\n      value.copy(buf, 4);\n    } else if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n      buf.writeUInt32BE(value, 4);\n    } else {\n      buf.writeUInt16BE(value, 4);\n    }\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Force Multiple Coils\" (FC=15) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the first coil.\n   * @param {Array} array the array of boolean states to write to coils.\n   * @param {Function} next the function to call next.\n   */\n  writeFC15(address, dataAddress, array, next) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n\n    // sanity check\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n    const code = 15;\n    let i = 0;\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      nextLength: 8,\n      next: next\n    };\n    const dataBytes = Math.ceil(array.length / 8);\n    const codeLength = 7 + dataBytes;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    buf.writeUInt16BE(array.length, 4);\n    buf.writeUInt8(dataBytes, 6);\n\n    // clear the data bytes before writing bits data\n    for (i = 0; i < dataBytes; i++) {\n      buf.writeUInt8(0, 7 + i);\n    }\n    for (i = 0; i < array.length; i++) {\n      // buffer bits are already all zero (0)\n      // only set the ones set to one (1)\n      if (array[i]) {\n        buf.writeBit(1, i, 7);\n      }\n    }\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Preset Multiple Registers\" (FC=16) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the first register.\n   * @param {Array} array the array of values to write to registers.\n   * @param {Function} next the function to call next.\n   */\n  writeFC16(address, dataAddress, array, next) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n\n    // sanity check\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n    const code = 16;\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      nextLength: 8,\n      next: next\n    };\n    let dataLength = array.length;\n    if (Buffer.isBuffer(array)) {\n      // if array is a buffer it has double length\n      dataLength = array.length / 2;\n    }\n    const codeLength = 7 + 2 * dataLength;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    buf.writeUInt16BE(dataLength, 4);\n    buf.writeUInt8(dataLength * 2, 6);\n\n    // copy content of array to buf\n    if (Buffer.isBuffer(array)) {\n      array.copy(buf, 7);\n    } else {\n      for (let i = 0; i < dataLength; i++) {\n        buf.writeUInt16BE(array[i], 7 + 2 * i);\n      }\n    }\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Report Server ID\" (FC=17) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {Function} next the function to call next.\n   */\n  writeFC17(address, da, l, next) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n    const code = 17;\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      lengthUnknown: true,\n      next: next\n    };\n    const codeLength = 2;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write  mODBUS \"Read Device Identification\" (FC=20) to serial port\n   * @param {number} address the slave unit address.\n   * @param {Function} next;\n   */\n  writeFC20(address, fileNumber, recordNumber, next) {\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n    // sanity check\n    if (typeof address === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n    // function code defaults to 20\n    const code = 20;\n    const codeLength = 10;\n    const byteCount = 7;\n    const chunck = 100;\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      lengthUnknown: true,\n      next: next\n    };\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt8(byteCount, 2);\n    buf.writeUInt8(6, 3); // ReferenceType\n    buf.writeUInt16BE(fileNumber, 4);\n    buf.writeUInt16BE(recordNumber, 6);\n    buf.writeUInt8(chunck, 9);\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Mask Write Register\" (FC=22) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} dataAddress the Data Address of the register.\n   * @param {number} andMask the AND mask value.\n   * @param {number} orMask the OR mask value.\n   * @param {Function} next the function to call next.\n   */\n  writeFC22(address, dataAddress, andMask, orMask, next) {\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n    if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n      if (next) next(new BadAddressError());\n      return;\n    }\n    const code = 22;\n    const codeLength = 8;\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      nextLength: codeLength + 2,\n      next: next\n    };\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt16BE(dataAddress, 2);\n    buf.writeUInt16BE(andMask, 4);\n    buf.writeUInt16BE(orMask, 6);\n    buf.writeUInt16LE(crc16(buf.slice(0, -2)), codeLength);\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n\n  /**\n   * Write a Modbus \"Read Device Identification\" (FC=43) to serial port.\n   *\n   * @param {number} address the slave unit address.\n   * @param {number} deviceIdCode the read device access code.\n   * @param {number} objectId the array of values to write to registers.\n   * @param {Function} next the function to call next.\n   */\n  writeFC43(address, deviceIdCode, objectId, next) {\n    // check port is actually open before attempting write\n    if (this.isOpen !== true) {\n      if (next) next(new PortNotOpenError());\n      return;\n    }\n    const code = 0x2B; // 43\n\n    // set state variables\n    this._transactions[this._port._transactionIdWrite] = {\n      nextAddress: address,\n      nextCode: code,\n      lengthUnknown: true,\n      next: next\n    };\n    const codeLength = 5;\n    const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n    buf.writeUInt8(address, 0);\n    buf.writeUInt8(code, 1);\n    buf.writeUInt8(0x0E, 2); // 16 MEI Type\n    buf.writeUInt8(deviceIdCode, 3);\n    buf.writeUInt8(objectId, 4);\n    // add crc bytes to buffer\n    buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n    // write buffer to serial port\n    _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n  }\n}\n\n// add the connection shorthand API\nrequire(\"./apis/connection\")(ModbusRTU);\n\n// add the promise API\nrequire(\"./apis/promise\")(ModbusRTU);\n\n// add worker API\nrequire(\"./apis/worker\")(ModbusRTU);\n\n// exports\nmodule.exports = ModbusRTU;\nmodule.exports.getPorts = function getPorts() {\n  const {\n    SerialPort\n  } = require(\"serialport\");\n  return SerialPort.list();\n};\nmodule.exports.TestPort = require(\"./ports/testport\");\ntry {\n  module.exports.RTUBufferedPort = require(\"./ports/rtubufferedport\");\n} catch (err) {}\nmodule.exports.TcpPort = require(\"./ports/tcpport\");\nmodule.exports.TcpRTUBufferedPort = require(\"./ports/tcprtubufferedport\");\nmodule.exports.TelnetPort = require(\"./ports/telnetport\");\nmodule.exports.C701Port = require(\"./ports/c701port\");\nmodule.exports.ServerTCP = require(\"./servers/servertcp\");\ntry {\n  module.exports.ServerSerial = require(\"./servers/serverserial\");\n} catch (err) {}\nmodule.exports.default = module.exports;","map":{"version":3,"names":["require","crc16","modbusSerialDebug","events","EventEmitter","PORT_NOT_OPEN_MESSAGE","PORT_NOT_OPEN_ERRNO","BAD_ADDRESS_MESSAGE","BAD_ADDRESS_ERRNO","TRANSACTION_TIMED_OUT_MESSAGE","TRANSACTION_TIMED_OUT_ERRNO","modbusErrorMessages","PortNotOpenError","Error","captureStackTrace","constructor","name","message","errno","BadAddressError","TransactionTimedOutError","SerialPortError","_readFC2","data","next","length","readUInt8","contents","i","reg","j","push","slice","_readFC3or4","readUInt16BE","_readFC3or4Enron","readUInt32BE","_readFC5","dataAddress","state","_readFC6","value","_readFC6Enron","_readFC16","_readFC17","parseInt","serverId","running","additionalData","Buffer","alloc","copy","_readFC20","fileRespLength","result","_readFC22","andMask","orMask","_readFC43","modbus","address","readDeviceIdCode","conformityLevel","moreFollows","nextObjectId","numOfObjects","startAt","objectId","objectLength","startOfData","toString","cb","err","Object","assign","writeFC43","_writeBufferToPort","buffer","transactionId","transaction","_transactions","_timeoutFired","_timeoutHandle","_startTimeout","_timeout","_debugEnabled","request","Uint8Array","prototype","call","responses","_port","write","duration","undefined","setTimeout","modbusRequest","modbusResponses","_cancelTimeout","timeoutHandle","clearTimeout","_onReceive","error","_transactionIdRead","res","lengthUnknown","nextLength","crcIn","readUInt16LE","code","nextCode","errorCode","modbusCode","_enron","example","enronTables","booleanRange","shortRange","longRange","floatRange","_enronTables","JSON","stringify","Number","nextAddress","nextDataAddress","e","_onError","stack","emit","ModbusRTU","port","_unitID","bind","open","callback","action","_transactionIdWrite","removeListener","on","once","isDebugEnabled","enable","Boolean","isOpen","_cancelPendingTransactions","keys","values","forEach","close","removeAllListeners","destroy","writeFC1","writeFC2","codeLength","buf","writeUInt8","writeUInt16BE","writeUInt16LE","subarray","writeFC3","writeFC4","valueSize","writeFC5","writeFC6","isBuffer","writeUInt32BE","writeFC15","array","dataBytes","Math","ceil","writeBit","writeFC16","dataLength","writeFC17","da","l","writeFC20","fileNumber","recordNumber","byteCount","chunck","writeFC22","deviceIdCode","module","exports","getPorts","SerialPort","list","TestPort","RTUBufferedPort","TcpPort","TcpRTUBufferedPort","TelnetPort","C701Port","ServerTCP","ServerSerial","default"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/index.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2015-2017, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"./utils/buffer_bit\")();\nconst crc16 = require(\"./utils/crc16\");\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\n\nconst PORT_NOT_OPEN_MESSAGE = \"Port Not Open\";\nconst PORT_NOT_OPEN_ERRNO = \"ECONNREFUSED\";\n\nconst BAD_ADDRESS_MESSAGE = \"Bad Client Address\";\nconst BAD_ADDRESS_ERRNO = \"ECONNREFUSED\";\n\nconst TRANSACTION_TIMED_OUT_MESSAGE = \"Timed out\";\nconst TRANSACTION_TIMED_OUT_ERRNO = \"ETIMEDOUT\";\n\nconst modbusErrorMessages = [\n    \"Unknown error\",\n    \"Illegal function (device does not support this read/write function)\",\n    \"Illegal data address (register not supported by device)\",\n    \"Illegal data value (value cannot be written to this register)\",\n    \"Slave device failure (device reports internal error)\",\n    \"Acknowledge (requested data will be available later)\",\n    \"Slave device busy (retry request again later)\",\n    \"Negative acknowledge (slave device cannot perform programming functions)\",\n    \"Memory parity error (slave device detected a parity error in memory)\",\n    \"Unknown error\",\n    \"Gateway path unavailable (misconfigured gateway)\",\n    \"Gateway target device failed to respond (retry request again later)\"\n];\n\nconst PortNotOpenError = function() {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = PORT_NOT_OPEN_MESSAGE;\n    this.errno = PORT_NOT_OPEN_ERRNO;\n};\n\nconst BadAddressError = function() {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = BAD_ADDRESS_MESSAGE;\n    this.errno = BAD_ADDRESS_ERRNO;\n};\n\nconst TransactionTimedOutError = function() {\n    this.name = this.constructor.name;\n    this.message = TRANSACTION_TIMED_OUT_MESSAGE;\n    this.errno = TRANSACTION_TIMED_OUT_ERRNO;\n};\n\nconst SerialPortError = function() {\n    this.name = this.constructor.name;\n    this.message = null;\n    this.errno = \"ECONNREFUSED\";\n};\n\n/**\n * @fileoverview ModbusRTU module, exports the ModbusRTU class.\n * this class makes ModbusRTU calls fun and easy.\n *\n * Modbus is a serial communications protocol, first used in 1979.\n * Modbus is simple and robust, openly published, royalty-free and\n * easy to deploy and maintain.\n */\n\n/**\n * Parse the data for a Modbus -\n * Read Coils (FC=02, 01)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC2(data, next) {\n    const length = data.readUInt8(2);\n    const contents = [];\n\n    for (let i = 0; i < length; i++) {\n        let reg = data[i + 3];\n\n        for (let j = 0; j < 8; j++) {\n            contents.push((reg & 1) === 1);\n            reg = reg >> 1;\n        }\n    }\n\n    if (next)\n        next(null, { \"data\": contents, \"buffer\": data.slice(3, 3 + length) });\n}\n\n/**\n * Parse the data for a Modbus -\n * Read Input Registers (FC=04, 03)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC3or4(data, next) {\n    const length = data.readUInt8(2);\n    const contents = [];\n\n    for (let i = 0; i < length; i += 2) {\n        const reg = data.readUInt16BE(i + 3);\n        contents.push(reg);\n    }\n\n    if (next)\n        next(null, { \"data\": contents, \"buffer\": data.slice(3, 3 + length) });\n}\n\n/**\n * Parse the data for a Modbus (Enron) -\n * Read Registers (FC=04, 03)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC3or4Enron(data, next) {\n    const length = data.readUInt8(2);\n    const contents = [];\n\n    for (let i = 0; i < length; i += 4) {\n        const reg = data.readUInt32BE(i + 3);\n        contents.push(reg);\n    }\n\n    if (next)\n        next(null, { \"data\": contents, \"buffer\": data.slice(3, 3 + length) });\n}\n\n/**\n * Parse the data for a Modbus -\n * Force Single Coil (FC=05)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC5(data, next) {\n    const dataAddress = data.readUInt16BE(2);\n    const state = data.readUInt16BE(4);\n\n    if (next)\n        next(null, { \"address\": dataAddress, \"state\": (state === 0xff00) });\n}\n\n/**\n * Parse the data for a Modbus -\n * Preset Single Registers (FC=06)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC6(data, next) {\n    const dataAddress = data.readUInt16BE(2);\n    const value = data.readUInt16BE(4);\n\n    if (next)\n        next(null, { \"address\": dataAddress, \"value\": value });\n}\n\n/**\n * Parse the data for a Modbus (Enron) -\n * Preset Single Registers (FC=06)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC6Enron(data, next) {\n    const dataAddress = data.readUInt16BE(2);\n    const value = data.readUInt32BE(4);\n\n    if (next)\n        next(null, { \"address\": dataAddress, \"value\": value });\n}\n\n/**\n * Parse the data for a Modbus -\n * Preset Multiple Registers (FC=15, 16)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC16(data, next) {\n    const dataAddress = data.readUInt16BE(2);\n    const length = data.readUInt16BE(4);\n\n    if (next)\n        next(null, { \"address\": dataAddress, \"length\": length });\n}\n\n/**\n * Parse the data for a Modbus -\n * Report server ID (FC=17)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC17(data, next) {\n    const length = parseInt(data.readUInt8(2));\n    const serverId = parseInt(data.readUInt8(3));\n    const running = data.readUInt8(4) === 0xFF;\n    let additionalData;\n    if (length > 2) {\n        additionalData = Buffer.alloc(length - 2);\n        // copy additional data\n        data.copy(additionalData, 0, 5, data.length - 2);\n    } else {\n        additionalData = Buffer.alloc(0);\n    }\n\n    if (next)\n        next(null, { serverId: serverId, running: running, additionalData: additionalData });\n}\n\n/**\n * Parse  the data fro Modbus -\n * Read File Records\n *\n * @param {Buffer4} buffer\n * @param {Function} next\n */\nfunction _readFC20(data,  next) {\n    const fileRespLength = parseInt(data.readUInt8(2));\n    const result = [];\n    for (let i = 5; i < fileRespLength + 5; i++) {\n        const reg = data.readUInt8(i);\n        result.push(reg);\n    }\n    if(next)\n        next(null, { \"data\": result, \"length\": fileRespLength });\n}\n\n/**\n * Parse the data for a Modbus -\n * Mask Write Register (FC=22)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Function} next the function to call next.\n */\nfunction _readFC22(data, next) {\n    const dataAddress = data.readUInt16BE(2);\n    const andMask = data.readUInt16BE(4);\n    const orMask = data.readUInt16BE(6);\n\n    if (next)\n        next(null, { \"address\": dataAddress, \"andMask\": andMask, \"orMask\": orMask });\n}\n\n/**\n * Parse the data for a Modbus -\n * Read Device Identification (FC=43)\n *\n * @param {Buffer} data the data buffer to parse.\n * @param {Modbus} modbus the client in case we need to read more device information\n * @param {Function} next the function to call next.\n */\nfunction _readFC43(data, modbus, next) {\n    const address = parseInt(data.readUInt8(0));\n    const readDeviceIdCode = parseInt(data.readUInt8(3));\n    const conformityLevel = parseInt(data.readUInt8(4));\n    const moreFollows = parseInt(data.readUInt8(5));\n    const nextObjectId = parseInt(data.readUInt8(6));\n    const numOfObjects = parseInt(data.readUInt8(7));\n\n    let startAt = 8;\n    const result = {};\n    // The modbus specification states that numOfObjects is the number of\n    // objects in the response, but the example on page 45 shows the total\n    // number over all responses. Therefore be careful about reading more data than available\n    for (let i = 0; i < numOfObjects && startAt < data.length; i++) {\n        const objectId = parseInt(data.readUInt8(startAt));\n        const objectLength = parseInt(data.readUInt8(startAt + 1));\n        const startOfData = startAt + 2;\n        result[objectId] = data.toString(\"ascii\", startOfData, startOfData + objectLength);\n        startAt = startOfData + objectLength;\n    }\n\n    // is it saying to follow and did you previously get data\n    // if you did not previously get data go ahead and halt to prevent an infinite loop\n    if (moreFollows && numOfObjects) {\n        const cb = function(err, data) {\n            data.data = Object.assign(data.data, result);\n            return next(err, data);\n        };\n        modbus.writeFC43(address, readDeviceIdCode, nextObjectId, cb);\n    } else if (next) {\n        next(null, { data: result, conformityLevel });\n    }\n}\n\n/**\n * Wrapper method for writing to a port with timeout. <code><b>[this]</b></code> has the context of ModbusRTU\n * @param {Buffer} buffer The data to send\n * @private\n */\nfunction _writeBufferToPort(buffer, transactionId) {\n    const transaction = this._transactions[transactionId];\n\n    if (transaction) {\n        transaction._timeoutFired = false;\n        transaction._timeoutHandle = _startTimeout(this._timeout, transaction);\n\n        // If in debug mode, stash a copy of the request payload\n        if (this._debugEnabled) {\n            transaction.request = Uint8Array.prototype.slice.call(buffer);\n            transaction.responses = [];\n        }\n    }\n\n    this._port.write(buffer);\n}\n\n/**\n * Starts the timeout timer with the given duration.\n * If the timeout ends before it was cancelled, it will call the callback with an error.\n * @param {number} duration the timeout duration in milliseconds.\n * @param {Function} next the function to call next.\n * @return {number} The handle of the timeout\n * @private\n */\nfunction _startTimeout(duration, transaction) {\n    if (!duration) {\n        return undefined;\n    }\n    return setTimeout(function() {\n        transaction._timeoutFired = true;\n        if (transaction.next) {\n            const err = new TransactionTimedOutError();\n            if (transaction.request && transaction.responses) {\n                err.modbusRequest = transaction.request;\n                err.modbusResponses = transaction.responses;\n            }\n            transaction.next(err);\n        }\n    }, duration);\n}\n\n/**\n * Cancel the given timeout.\n *\n * @param {number} timeoutHandle The handle of the timeout\n * @private\n */\nfunction _cancelTimeout(timeoutHandle) {\n    clearTimeout(timeoutHandle);\n}\n\n/**\n * Handle incoming data from the Modbus port.\n *\n * @param {Buffer} data The data received\n * @private\n */\nfunction _onReceive(data) {\n    const modbus = this;\n    let error;\n\n    // set locale helpers variables\n    const transaction = modbus._transactions[modbus._port._transactionIdRead];\n\n    // the _transactionIdRead can be missing, ignore wrong transaction it's\n    if (!transaction) {\n        return;\n    }\n\n    if (transaction.responses) {\n        /* Stash what we received */\n        transaction.responses.push(Uint8Array.prototype.slice.call(data));\n    }\n\n    /* What do we do next? */\n    const next = function(err, res) {\n        if (transaction.next) {\n            /* Include request/response data if enabled */\n            if (transaction.request && transaction.responses) {\n                if (err) {\n                    err.modbusRequest = transaction.request;\n                    err.modbusResponses = transaction.responses;\n                }\n\n                if (res) {\n                    res.request = transaction.request;\n                    res.responses = transaction.responses;\n                }\n            }\n\n            /* Pass the data on */\n            return transaction.next(err, res);\n        }\n    };\n\n    /* cancel the timeout */\n    _cancelTimeout(transaction._timeoutHandle);\n    transaction._timeoutHandle = undefined;\n\n    /* check if the timeout fired */\n    if (transaction._timeoutFired === true) {\n        // we have already called back with an error, so don't generate a new callback\n        return;\n    }\n\n    /* check incoming data\n     */\n\n    /* check minimal length\n     */\n    if (!transaction.lengthUnknown && data.length < 5) {\n        error = \"Data length error, expected \" +\n            transaction.nextLength + \" got \" + data.length;\n        next(new Error(error));\n        return;\n    }\n\n    /* check message CRC\n     * if CRC is bad raise an error\n     */\n    const crcIn = data.readUInt16LE(data.length - 2);\n    if (crcIn !== crc16(data.slice(0, -2))) {\n        error = \"CRC error\";\n        next(new Error(error));\n        return;\n    }\n\n    // if crc is OK, read address and function code\n    const address = data.readUInt8(0);\n    const code = data.readUInt8(1);\n\n    /* check for modbus exception\n     */\n    if (data.length >= 5 &&\n        code === (0x80 | transaction.nextCode)) {\n        const errorCode = data.readUInt8(2);\n        if (transaction.next) {\n            error = new Error(\"Modbus exception \" + errorCode + \": \" + (modbusErrorMessages[errorCode] || \"Unknown error\"));\n            error.modbusCode = errorCode;\n            next(error);\n        }\n        return;\n    }\n\n    /* check enron options are valid\n     */\n    if (modbus._enron) {\n        const example = {\n            enronTables: {\n                booleanRange: [1001, 1999],\n                shortRange: [3001, 3999],\n                longRange: [5001, 5999],\n                floatRange: [7001, 7999]\n            }\n        };\n\n        if (typeof modbus._enronTables === \"undefined\" ||\n                modbus._enronTables.shortRange.length !== 2 ||\n                modbus._enronTables.shortRange[0] >= modbus._enronTables.shortRange[1]) {\n            next(new Error(\"Enron table definition missing from options. Example: \" + JSON.stringify(example)));\n            return;\n        }\n    }\n\n    /* check message length\n     * if we do not expect this data\n     * raise an error\n     */\n    if (!transaction.lengthUnknown && data.length !== transaction.nextLength) {\n        error = \"Data length error, expected \" +\n            transaction.nextLength + \" got \" + data.length;\n        next(new Error(error));\n        return;\n    }\n\n    /* check message address\n     * if we do not expect this message\n     * raise an error\n     */\n    if (Number(address) !== Number(transaction.nextAddress)) {\n        error = \"Unexpected data error, expected \" +\n              \"address \" + transaction.nextAddress + \" got \" + address;\n        if (transaction.next)\n            next(new Error(error));\n        return;\n    }\n\n    /* check message code\n     * if we do not expect this message\n     * raise an error\n     */\n    if (code !== transaction.nextCode) {\n        error = \"Unexpected data error, expected \" +\n            \"code \" + transaction.nextCode + \" got \" + code;\n        if (transaction.next)\n            next(new Error(error));\n        return;\n    }\n\n    /* parse incoming data\n     */\n    try {\n        switch (code) {\n            case 1:\n            case 2:\n                // Read Coil Status (FC=01)\n                // Read Input Status (FC=02)\n                _readFC2(data, next);\n                break;\n            case 3:\n            case 4:\n                // Read Input Registers (FC=04)\n                // Read Holding Registers (FC=03)\n                if (modbus._enron && !(transaction.nextDataAddress >= modbus._enronTables.shortRange[0] && transaction.nextDataAddress <= modbus._enronTables.shortRange[1])) {\n                    _readFC3or4Enron(data, next);\n                } else {\n                    _readFC3or4(data, next);\n                }\n                break;\n            case 5:\n                // Force Single Coil\n                _readFC5(data, next);\n                break;\n            case 6:\n                // Preset Single Register\n                if (modbus._enron && !(transaction.nextDataAddress >= modbus._enronTables.shortRange[0] && transaction.nextDataAddress <= modbus._enronTables.shortRange[1])) {\n                    _readFC6Enron(data, next);\n                } else {\n                    _readFC6(data, next);\n                }\n                break;\n            case 15:\n            case 16:\n                // Force Multiple Coils\n                // Preset Multiple Registers\n                _readFC16(data, next);\n                break;\n            case 17:\n                _readFC17(data, next);\n                break;\n            case 20:\n                _readFC20(data, transaction.next);\n                break;\n            case 22:\n                _readFC22(data, next);\n                break;\n            case 43:\n                // read device identification\n                _readFC43(data, modbus, next);\n        }\n    } catch (e) {\n        if (transaction.next) {\n            next(e);\n        }\n    }\n}\n\n/**\n * Handle SerialPort errors.\n *\n * @param {Error} error The error received\n * @private\n */\nfunction _onError(e) {\n    const err = new SerialPortError();\n    err.message = e.message;\n    err.stack = e.stack;\n    this.emit(\"error\", err);\n}\n\nclass ModbusRTU extends EventEmitter {\n    /**\n     * Class making ModbusRTU calls fun and easy.\n     *\n     * @param {SerialPort} port the serial port to use.\n     */\n    constructor(port) {\n        super();\n\n        // the serial port to use\n        this._port = port;\n\n        // state variables\n        this._transactions = {};\n        this._timeout = null; // timeout in msec before unanswered request throws timeout error\n        this._unitID = 1;\n\n        // Flag to indicate whether debug mode (pass-through of raw\n        // request/response) is enabled.\n        this._debugEnabled = false;\n\n        this._onReceive = _onReceive.bind(this);\n        this._onError = _onError.bind(this);\n    }\n\n    /**\n     * Open the serial port and register Modbus parsers\n     *\n     * @param {Function} callback the function to call next on open success\n     *      of failure.\n     */\n    open(callback) {\n        const modbus = this;\n\n        // open the serial port\n        modbus._port.open(function(error) {\n            if (error) {\n                modbusSerialDebug({ action: \"port open error\", error: error });\n                /* On serial port open error call next function */\n                if (callback)\n                    callback(error);\n            } else {\n                /* init ports transaction id and counter */\n                modbus._port._transactionIdRead = 1;\n                modbus._port._transactionIdWrite = 1;\n\n                /* On serial port success\n                 * (re-)register the modbus parser functions\n                 */\n                modbus._port.removeListener(\"data\", modbus._onReceive);\n                modbus._port.on(\"data\", modbus._onReceive);\n\n                /* On serial port error\n                 * (re-)register the error listener function\n                 */\n                modbus._port.removeListener(\"error\", modbus._onError);\n                modbus._port.on(\"error\", modbus._onError);\n\n                /* Hook the close event so we can relay it to our callers. */\n                modbus._port.once(\"close\", modbus.emit.bind(modbus, \"close\"));\n\n                /* On serial port open OK call next function with no error */\n                if (callback)\n                    callback(error);\n            }\n        });\n    }\n\n    get isDebugEnabled() {\n        return this._debugEnabled;\n    }\n\n    set isDebugEnabled(enable) {\n        enable = Boolean(enable);\n        this._debugEnabled = enable;\n    }\n\n    get isOpen() {\n        if (this._port) {\n            return this._port.isOpen;\n        }\n\n        return false;\n    }\n\n    /**\n     * Clears the timeout for all pending transactions.\n     * This essentially cancels all pending requests.\n     */\n    _cancelPendingTransactions() {\n        if (Object.keys(this._transactions).length > 0) {\n            Object.values(this._transactions).forEach((transaction) => {\n                if (transaction._timeoutHandle) {\n                    _cancelTimeout(transaction._timeoutHandle);\n                }\n            });\n        }\n    }\n\n    /**\n     * Close the serial port\n     *\n     * @param {Function} callback the function to call next on close success\n     *      or failure.\n     */\n    close(callback) {\n        // close the serial port if exist\n        if (this._port) {\n            this._port.removeAllListeners(\"data\");\n            this._port.close(callback);\n        } else {\n            // nothing needed to be done\n            callback();\n        }\n    }\n\n    /**\n     * Destroy the serial port\n     *\n     * @param {Function} callback the function to call next on close success\n     *      or failure.\n     */\n    destroy(callback) {\n        // cancel all pending requests as we're closing the port\n        this._cancelPendingTransactions();\n\n        // close the serial port if exist and it has a destroy function\n        if (this._port && this._port.destroy) {\n            this._port.removeAllListeners(\"data\");\n            this._port.destroy();\n            callback();\n        } else {\n            // nothing needed to be done\n            callback();\n        }\n    }\n\n    /**\n     * Write a Modbus \"Read Coil Status\" (FC=01) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the first coil.\n     * @param {number} length the total number of coils requested.\n     * @param {Function} next the function to call next.\n     */\n    writeFC1(address, dataAddress, length, next) {\n        this.writeFC2(address, dataAddress, length, next, 1);\n    }\n\n    /**\n     * Write a Modbus \"Read Input Status\" (FC=02) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the first digital input.\n     * @param {number} length the total number of digital inputs requested.\n     * @param {Function} next the function to call next.\n     */\n    writeFC2(address, dataAddress, length, next, code) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        // sanity check\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        // function code defaults to 2\n        code = code || 2;\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            nextLength: 3 + parseInt((length - 1) / 8 + 1) + 2,\n            next: next\n        };\n\n        const codeLength = 6;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n        buf.writeUInt16BE(length, 4);\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Read Holding Registers\" (FC=03) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the first register.\n     * @param {number} length the total number of registers requested.\n     * @param {Function} next the function to call next.\n     */\n    writeFC3(address, dataAddress, length, next) {\n        this.writeFC4(address, dataAddress, length, next, 3);\n    }\n\n    /**\n     * Write a Modbus \"Read Input Registers\" (FC=04) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the first register.\n     * @param {number} length the total number of registers requested.\n     * @param {Function} next the function to call next.\n     */\n    writeFC4(address, dataAddress, length, next, code) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        // sanity check\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        // function code defaults to 4\n        code = code || 4;\n\n        let valueSize = 2;\n        if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n            valueSize = 4;\n        }\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextDataAddress: dataAddress,\n            nextCode: code,\n            nextLength: 3 + (valueSize * length) + 2,\n            next: next\n        };\n\n        const codeLength = 6;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n        buf.writeUInt16BE(length, 4);\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Force Single Coil\" (FC=05) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the coil.\n     * @param {number} state the boolean state to write to the coil (true / false).\n     * @param {Function} next the function to call next.\n     */\n    writeFC5(address, dataAddress, state, next) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        // sanity check\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        const code = 5;\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            nextLength: 8,\n            next: next\n        };\n\n        const codeLength = 6;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n\n        if (state) {\n            buf.writeUInt16BE(0xff00, 4);\n        } else {\n            buf.writeUInt16BE(0x0000, 4);\n        }\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Preset Single Register \" (FC=6) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the register.\n     * @param {number} value the value to write to the register.\n     * @param {Function} next the function to call next.\n     */\n    writeFC6(address, dataAddress, value, next) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        // sanity check\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        const code = 6;\n\n        let valueSize = 8;\n        if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n            valueSize = 10;\n        }\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextDataAddress: dataAddress,\n            nextCode: code,\n            nextLength: valueSize,\n            next: next\n        };\n\n        let codeLength = 6; // 1B deviceAddress + 1B functionCode + 2B dataAddress + (2B value | 4B value (enron))\n        if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n            codeLength = 8;\n        }\n\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n\n        if (Buffer.isBuffer(value)) {\n            value.copy(buf, 4);\n        } else if (this._enron && !(dataAddress >= this._enronTables.shortRange[0] && dataAddress <= this._enronTables.shortRange[1])) {\n            buf.writeUInt32BE(value, 4);\n        } else {\n            buf.writeUInt16BE(value, 4);\n        }\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Force Multiple Coils\" (FC=15) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the first coil.\n     * @param {Array} array the array of boolean states to write to coils.\n     * @param {Function} next the function to call next.\n     */\n    writeFC15(address, dataAddress, array, next) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        // sanity check\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        const code = 15;\n        let i = 0;\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            nextLength: 8,\n            next: next\n        };\n\n        const dataBytes = Math.ceil(array.length / 8);\n        const codeLength = 7 + dataBytes;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n        buf.writeUInt16BE(array.length, 4);\n        buf.writeUInt8(dataBytes, 6);\n\n        // clear the data bytes before writing bits data\n        for (i = 0; i < dataBytes; i++) {\n            buf.writeUInt8(0, 7 + i);\n        }\n\n        for (i = 0; i < array.length; i++) {\n            // buffer bits are already all zero (0)\n            // only set the ones set to one (1)\n            if (array[i]) {\n                buf.writeBit(1, i, 7);\n            }\n        }\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Preset Multiple Registers\" (FC=16) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the first register.\n     * @param {Array} array the array of values to write to registers.\n     * @param {Function} next the function to call next.\n     */\n    writeFC16(address, dataAddress, array, next) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        // sanity check\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        const code = 16;\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            nextLength: 8,\n            next: next\n        };\n\n        let dataLength = array.length;\n        if (Buffer.isBuffer(array)) {\n            // if array is a buffer it has double length\n            dataLength = array.length / 2;\n        }\n\n        const codeLength = 7 + 2 * dataLength;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n        buf.writeUInt16BE(dataLength, 4);\n        buf.writeUInt8(dataLength * 2, 6);\n\n        // copy content of array to buf\n        if (Buffer.isBuffer(array)) {\n            array.copy(buf, 7);\n        } else {\n            for (let i = 0; i < dataLength; i++) {\n                buf.writeUInt16BE(array[i], 7 + 2 * i);\n            }\n        }\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Report Server ID\" (FC=17) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {Function} next the function to call next.\n     */\n    writeFC17(address, da, l, next) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        const code = 17;\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            lengthUnknown: true,\n            next: next\n        };\n\n        const codeLength = 2;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n\n    /**\n     * Write  mODBUS \"Read Device Identification\" (FC=20) to serial port\n     * @param {number} address the slave unit address.\n     * @param {Function} next;\n     */\n    writeFC20(address, fileNumber, recordNumber, next) {\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n        // sanity check\n        if (typeof address === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n        // function code defaults to 20\n        const code = 20;\n        const codeLength = 10;\n        const byteCount = 7;\n        const chunck = 100;\n\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            lengthUnknown: true,\n            next: next\n        };\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt8(byteCount, 2);\n        buf.writeUInt8(6, 3); // ReferenceType\n        buf.writeUInt16BE(fileNumber, 4);\n        buf.writeUInt16BE(recordNumber, 6);\n        buf.writeUInt8(chunck, 9);\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Mask Write Register\" (FC=22) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} dataAddress the Data Address of the register.\n     * @param {number} andMask the AND mask value.\n     * @param {number} orMask the OR mask value.\n     * @param {Function} next the function to call next.\n     */\n    writeFC22(address, dataAddress, andMask, orMask, next) {\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        if (typeof address === \"undefined\" || typeof dataAddress === \"undefined\") {\n            if (next) next(new BadAddressError());\n            return;\n        }\n\n        const code = 22;\n        const codeLength = 8;\n\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            nextLength: codeLength + 2,\n            next: next\n        };\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt16BE(dataAddress, 2);\n        buf.writeUInt16BE(andMask, 4);\n        buf.writeUInt16BE(orMask, 6);\n        buf.writeUInt16LE(crc16(buf.slice(0, -2)), codeLength);\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n\n    /**\n     * Write a Modbus \"Read Device Identification\" (FC=43) to serial port.\n     *\n     * @param {number} address the slave unit address.\n     * @param {number} deviceIdCode the read device access code.\n     * @param {number} objectId the array of values to write to registers.\n     * @param {Function} next the function to call next.\n     */\n    writeFC43(address, deviceIdCode, objectId, next) {\n        // check port is actually open before attempting write\n        if (this.isOpen !== true) {\n            if (next) next(new PortNotOpenError());\n            return;\n        }\n\n        const code = 0x2B; // 43\n\n        // set state variables\n        this._transactions[this._port._transactionIdWrite] = {\n            nextAddress: address,\n            nextCode: code,\n            lengthUnknown: true,\n            next: next\n        };\n        const codeLength = 5;\n        const buf = Buffer.alloc(codeLength + 2); // add 2 crc bytes\n        buf.writeUInt8(address, 0);\n        buf.writeUInt8(code, 1);\n        buf.writeUInt8(0x0E, 2); // 16 MEI Type\n        buf.writeUInt8(deviceIdCode, 3);\n        buf.writeUInt8(objectId, 4);\n        // add crc bytes to buffer\n        buf.writeUInt16LE(crc16(buf.subarray(0, -2)), codeLength);\n        // write buffer to serial port\n        _writeBufferToPort.call(this, buf, this._port._transactionIdWrite);\n    }\n}\n\n// add the connection shorthand API\nrequire(\"./apis/connection\")(ModbusRTU);\n\n// add the promise API\nrequire(\"./apis/promise\")(ModbusRTU);\n\n// add worker API\nrequire(\"./apis/worker\")(ModbusRTU);\n\n// exports\nmodule.exports = ModbusRTU;\n\nmodule.exports.getPorts = function getPorts() {\n    const { SerialPort } = require(\"serialport\");\n\n    return SerialPort.list();\n};\n\nmodule.exports.TestPort = require(\"./ports/testport\");\ntry {\n    module.exports.RTUBufferedPort = require(\"./ports/rtubufferedport\");\n} catch (err) { }\nmodule.exports.TcpPort = require(\"./ports/tcpport\");\nmodule.exports.TcpRTUBufferedPort = require(\"./ports/tcprtubufferedport\");\nmodule.exports.TelnetPort = require(\"./ports/telnetport\");\nmodule.exports.C701Port = require(\"./ports/c701port\");\n\nmodule.exports.ServerTCP = require(\"./servers/servertcp\");\ntry {\n    module.exports.ServerSerial = require(\"./servers/serverserial\");\n} catch (err) { }\nmodule.exports.default = module.exports;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}