{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable no-ternary */\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst SerialPort = require(\"serialport\").SerialPort;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\nconst crc16 = require(\"../utils/crc16\");\nconst calculateLrc = require(\"./../utils/lrc\");\n\n/* TODO: const should be set once, maybe */\nconst MIN_DATA_LENGTH = 6;\n\n/**\n * Ascii encode a 'request' buffer and return it. This includes removing\n * the CRC bytes and replacing them with an LRC.\n *\n * @param {Buffer} buf the data buffer to encode.\n * @return {Buffer} the ascii encoded buffer\n * @private\n */\nfunction _asciiEncodeRequestBuffer(buf) {\n  // replace the 2 byte crc16 with a single byte lrc\n  buf.writeUInt8(calculateLrc(buf.slice(0, -2)), buf.length - 2);\n\n  // create a new buffer of the correct size\n  const bufAscii = Buffer.alloc(buf.length * 2 + 1); // 1 byte start delimit + x2 data as ascii encoded + 2 lrc + 2 end delimit\n\n  // create the ascii payload\n\n  // start with the single start delimiter\n  bufAscii.write(\":\", 0);\n  // encode the data, with the new single byte lrc\n  bufAscii.write(buf.toString(\"hex\", 0, buf.length - 1).toUpperCase(), 1);\n  // end with the two end delimiters\n  bufAscii.write(\"\\r\", bufAscii.length - 2);\n  bufAscii.write(\"\\n\", bufAscii.length - 1);\n  return bufAscii;\n}\n\n/**\n * Ascii decode a 'response' buffer and return it.\n *\n * @param {Buffer} bufAscii the ascii data buffer to decode.\n * @return {Buffer} the decoded buffer, or null if decode error\n * @private\n */\nfunction _asciiDecodeResponseBuffer(bufAscii) {\n  // create a new buffer of the correct size (based on ascii encoded buffer length)\n  const bufDecoded = Buffer.alloc((bufAscii.length - 1) / 2);\n\n  // decode into new buffer (removing delimiters at start and end)\n  for (let i = 0; i < (bufAscii.length - 3) / 2; i++) {\n    bufDecoded.write(String.fromCharCode(bufAscii.readUInt8(i * 2 + 1), bufAscii.readUInt8(i * 2 + 2)), i, 1, \"hex\");\n  }\n\n  // check the lrc is true\n  const lrcIn = bufDecoded.readUInt8(bufDecoded.length - 2);\n  if (calculateLrc(bufDecoded.slice(0, -2)) !== lrcIn) {\n    // return null if lrc error\n    const calcLrc = calculateLrc(bufDecoded.slice(0, -2));\n    modbusSerialDebug({\n      action: \"LRC error\",\n      LRC: lrcIn.toString(16),\n      calcLRC: calcLrc.toString(16)\n    });\n    return null;\n  }\n\n  // replace the 1 byte lrc with a two byte crc16\n  bufDecoded.writeUInt16LE(crc16(bufDecoded.slice(0, -2)), bufDecoded.length - 2);\n  return bufDecoded;\n}\n\n/**\n * check if a buffer chunk can be a modbus answer\n * or modbus exception\n *\n * @param {AsciiPort} modbus\n * @param {Buffer} buf the buffer to check.\n * @return {boolean} if the buffer can be an answer\n * @private\n */\nfunction _checkData(modbus, buf) {\n  // check buffer size\n  if (buf.length !== modbus._length && buf.length !== 5) {\n    modbusSerialDebug({\n      action: \"length error\",\n      recive: buf.length,\n      expected: modbus._length\n    });\n    return false;\n  }\n\n  // check buffer unit-id and command\n  return buf[0] === modbus._id && (0x7f & buf[1]) === modbus._cmd;\n}\nclass AsciiPort extends EventEmitter {\n  /**\n   * Simulate a modbus-ascii port using serial connection.\n   *\n   * @param path\n   * @param options\n   * @constructor\n   */\n  constructor(path, options) {\n    super();\n    const modbus = this;\n\n    // options\n    options = options || {};\n\n    // select char for start of slave frame (usually :)\n    this._startOfSlaveFrameChar = options.startOfSlaveFrameChar === undefined ? 0x3A : options.startOfSlaveFrameChar;\n\n    // disable auto open, as we handle the open\n    options.autoOpen = false;\n\n    // internal buffer\n    this._buffer = Buffer.from(\"\");\n    this._id = 0;\n    this._cmd = 0;\n    this._length = 0;\n\n    // create the SerialPort\n    this._client = new SerialPort(Object.assign({}, {\n      path\n    }, options));\n\n    // register the port data event\n    this._client.on(\"data\", function (data) {\n      // add new data to buffer\n      modbus._buffer = Buffer.concat([modbus._buffer, data]);\n      modbusSerialDebug({\n        action: \"receive serial ascii port\",\n        data: data,\n        buffer: modbus._buffer\n      });\n      modbusSerialDebug(JSON.stringify({\n        action: \"receive serial ascii port strings\",\n        data: data,\n        buffer: modbus._buffer\n      }));\n\n      // check buffer for start delimiter\n      const sdIndex = modbus._buffer.indexOf(modbus._startOfSlaveFrameChar);\n      if (sdIndex === -1) {\n        // if not there, reset the buffer and return\n        modbus._buffer = Buffer.from(\"\");\n        return;\n      }\n      // if there is data before the start delimiter, remove it\n      if (sdIndex > 0) {\n        modbus._buffer = modbus._buffer.slice(sdIndex);\n      }\n      // do we have the complete message (i.e. are the end delimiters there)\n      if (modbus._buffer.includes(\"\\r\\n\", 1, \"ascii\") === true) {\n        // check there is no excess data after end delimiters\n        const edIndex = modbus._buffer.indexOf(0x0A); // ascii for '\\n'\n        if (edIndex !== modbus._buffer.length - 1) {\n          // if there is, remove it\n          modbus._buffer = modbus._buffer.slice(0, edIndex + 1);\n        }\n\n        // we have what looks like a complete ascii encoded response message, so decode\n        const _data = _asciiDecodeResponseBuffer(modbus._buffer);\n        modbusSerialDebug({\n          action: \"got EOM\",\n          data: _data,\n          buffer: modbus._buffer\n        });\n        if (_data !== null) {\n          // check if this is the data we are waiting for\n          if (_checkData(modbus, _data)) {\n            modbusSerialDebug({\n              action: \"emit data serial ascii port\",\n              data: data,\n              buffer: modbus._buffer\n            });\n            modbusSerialDebug(JSON.stringify({\n              action: \"emit data serial ascii port strings\",\n              data: data,\n              buffer: modbus._buffer\n            }));\n            // emit a data signal\n            modbus.emit(\"data\", _data);\n          }\n        }\n        // reset the buffer now its been used\n        modbus._buffer = Buffer.from(\"\");\n      } else {\n        // otherwise just wait for more data to arrive\n      }\n    });\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return this._client.isOpen;\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  open(callback) {\n    this._client.open(callback);\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    this._client.close(callback);\n    this.removeAllListeners();\n  }\n\n  /**\n   * Send data to a modbus slave.\n   *\n   * @param data\n   */\n  write(data) {\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n    let length = null;\n\n    // remember current unit and command\n    this._id = data[0];\n    this._cmd = data[1];\n\n    // calculate expected answer length (this is checked after ascii decoding)\n    switch (this._cmd) {\n      case 1:\n      case 2:\n        length = data.readUInt16BE(4);\n        this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n        break;\n      case 3:\n      case 4:\n        length = data.readUInt16BE(4);\n        this._length = 3 + 2 * length + 2;\n        break;\n      case 5:\n      case 6:\n      case 15:\n      case 16:\n        this._length = 6 + 2;\n        break;\n      default:\n        // raise and error ?\n        modbusSerialDebug({\n          action: \"unknown command\",\n          id: this._id.toString(16),\n          command: this._cmd.toString(16)\n        });\n        this._length = 0;\n        break;\n    }\n\n    // ascii encode buffer\n    const _encodedData = _asciiEncodeRequestBuffer(data);\n\n    // send buffer to slave\n    this._client.write(_encodedData);\n    modbusSerialDebug({\n      action: \"send serial ascii port\",\n      data: _encodedData,\n      unitid: this._id,\n      functionCode: this._cmd\n    });\n    modbusSerialDebug(JSON.stringify({\n      action: \"send serial ascii port\",\n      data: _encodedData,\n      unitid: this._id,\n      functionCode: this._cmd\n    }));\n  }\n}\n\n/**\n * ASCII port for Modbus.\n *\n * @type {AsciiPort}\n */\nmodule.exports = AsciiPort;","map":{"version":3,"names":["events","require","EventEmitter","SerialPort","modbusSerialDebug","crc16","calculateLrc","MIN_DATA_LENGTH","_asciiEncodeRequestBuffer","buf","writeUInt8","slice","length","bufAscii","Buffer","alloc","write","toString","toUpperCase","_asciiDecodeResponseBuffer","bufDecoded","i","String","fromCharCode","readUInt8","lrcIn","calcLrc","action","LRC","calcLRC","writeUInt16LE","_checkData","modbus","_length","recive","expected","_id","_cmd","AsciiPort","constructor","path","options","_startOfSlaveFrameChar","startOfSlaveFrameChar","undefined","autoOpen","_buffer","from","_client","Object","assign","on","data","concat","buffer","JSON","stringify","sdIndex","indexOf","includes","edIndex","_data","emit","isOpen","open","callback","close","removeAllListeners","readUInt16BE","parseInt","id","command","_encodedData","unitid","functionCode","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/asciiport.js"],"sourcesContent":["\"use strict\";\n/* eslint-disable no-ternary */\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst SerialPort = require(\"serialport\").SerialPort;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\nconst crc16 = require(\"../utils/crc16\");\nconst calculateLrc = require(\"./../utils/lrc\");\n\n/* TODO: const should be set once, maybe */\nconst MIN_DATA_LENGTH = 6;\n\n/**\n * Ascii encode a 'request' buffer and return it. This includes removing\n * the CRC bytes and replacing them with an LRC.\n *\n * @param {Buffer} buf the data buffer to encode.\n * @return {Buffer} the ascii encoded buffer\n * @private\n */\nfunction _asciiEncodeRequestBuffer(buf) {\n\n    // replace the 2 byte crc16 with a single byte lrc\n    buf.writeUInt8(calculateLrc(buf.slice(0, -2)), buf.length - 2);\n\n    // create a new buffer of the correct size\n    const bufAscii = Buffer.alloc(buf.length * 2 + 1); // 1 byte start delimit + x2 data as ascii encoded + 2 lrc + 2 end delimit\n\n    // create the ascii payload\n\n    // start with the single start delimiter\n    bufAscii.write(\":\", 0);\n    // encode the data, with the new single byte lrc\n    bufAscii.write(buf.toString(\"hex\", 0, buf.length - 1).toUpperCase(), 1);\n    // end with the two end delimiters\n    bufAscii.write(\"\\r\", bufAscii.length - 2);\n    bufAscii.write(\"\\n\", bufAscii.length - 1);\n\n    return bufAscii;\n}\n\n/**\n * Ascii decode a 'response' buffer and return it.\n *\n * @param {Buffer} bufAscii the ascii data buffer to decode.\n * @return {Buffer} the decoded buffer, or null if decode error\n * @private\n */\nfunction _asciiDecodeResponseBuffer(bufAscii) {\n\n    // create a new buffer of the correct size (based on ascii encoded buffer length)\n    const bufDecoded = Buffer.alloc((bufAscii.length - 1) / 2);\n\n    // decode into new buffer (removing delimiters at start and end)\n    for (let i = 0; i < (bufAscii.length - 3) / 2; i++) {\n        bufDecoded.write(String.fromCharCode(bufAscii.readUInt8(i * 2 + 1), bufAscii.readUInt8(i * 2 + 2)), i, 1, \"hex\");\n    }\n\n    // check the lrc is true\n    const lrcIn = bufDecoded.readUInt8(bufDecoded.length - 2);\n    if(calculateLrc(bufDecoded.slice(0, -2)) !== lrcIn) {\n        // return null if lrc error\n        const calcLrc = calculateLrc(bufDecoded.slice(0, -2));\n\n        modbusSerialDebug({ action: \"LRC error\", LRC: lrcIn.toString(16), calcLRC: calcLrc.toString(16) });\n        return null;\n    }\n\n    // replace the 1 byte lrc with a two byte crc16\n    bufDecoded.writeUInt16LE(crc16(bufDecoded.slice(0, -2)), bufDecoded.length - 2);\n\n    return bufDecoded;\n}\n\n/**\n * check if a buffer chunk can be a modbus answer\n * or modbus exception\n *\n * @param {AsciiPort} modbus\n * @param {Buffer} buf the buffer to check.\n * @return {boolean} if the buffer can be an answer\n * @private\n */\nfunction _checkData(modbus, buf) {\n    // check buffer size\n    if (buf.length !== modbus._length && buf.length !== 5) {\n        modbusSerialDebug({ action: \"length error\", recive: buf.length, expected: modbus._length });\n\n        return false;\n    }\n\n    // check buffer unit-id and command\n    return (buf[0] === modbus._id &&\n        (0x7f & buf[1]) === modbus._cmd);\n}\n\nclass AsciiPort extends EventEmitter {\n    /**\n     * Simulate a modbus-ascii port using serial connection.\n     *\n     * @param path\n     * @param options\n     * @constructor\n     */\n    constructor(path, options) {\n        super();\n\n        const modbus = this;\n\n        // options\n        options = options || {};\n\n        // select char for start of slave frame (usually :)\n        this._startOfSlaveFrameChar =\n            (options.startOfSlaveFrameChar === undefined)\n                ? 0x3A\n                : options.startOfSlaveFrameChar;\n\n        // disable auto open, as we handle the open\n        options.autoOpen = false;\n\n        // internal buffer\n        this._buffer = Buffer.from(\"\");\n        this._id = 0;\n        this._cmd = 0;\n        this._length = 0;\n\n        // create the SerialPort\n        this._client = new SerialPort(Object.assign({}, { path }, options));\n\n        // register the port data event\n        this._client.on(\"data\", function(data) {\n\n            // add new data to buffer\n            modbus._buffer = Buffer.concat([modbus._buffer, data]);\n\n            modbusSerialDebug({ action: \"receive serial ascii port\", data: data, buffer: modbus._buffer });\n            modbusSerialDebug(JSON.stringify({ action: \"receive serial ascii port strings\", data: data, buffer: modbus._buffer }));\n\n            // check buffer for start delimiter\n            const sdIndex = modbus._buffer.indexOf(modbus._startOfSlaveFrameChar);\n            if(sdIndex === -1) {\n                // if not there, reset the buffer and return\n                modbus._buffer = Buffer.from(\"\");\n                return;\n            }\n            // if there is data before the start delimiter, remove it\n            if(sdIndex > 0) {\n                modbus._buffer = modbus._buffer.slice(sdIndex);\n            }\n            // do we have the complete message (i.e. are the end delimiters there)\n            if(modbus._buffer.includes(\"\\r\\n\", 1, \"ascii\") === true) {\n                // check there is no excess data after end delimiters\n                const edIndex = modbus._buffer.indexOf(0x0A); // ascii for '\\n'\n                if(edIndex !== modbus._buffer.length - 1) {\n                    // if there is, remove it\n                    modbus._buffer = modbus._buffer.slice(0, edIndex + 1);\n                }\n\n                // we have what looks like a complete ascii encoded response message, so decode\n                const _data = _asciiDecodeResponseBuffer(modbus._buffer);\n                modbusSerialDebug({ action: \"got EOM\", data: _data, buffer: modbus._buffer });\n                if(_data !== null) {\n\n                    // check if this is the data we are waiting for\n                    if (_checkData(modbus, _data)) {\n                        modbusSerialDebug({ action: \"emit data serial ascii port\", data: data, buffer: modbus._buffer });\n                        modbusSerialDebug(JSON.stringify({ action: \"emit data serial ascii port strings\", data: data, buffer: modbus._buffer }));\n                        // emit a data signal\n                        modbus.emit(\"data\", _data);\n                    }\n                }\n                // reset the buffer now its been used\n                modbus._buffer = Buffer.from(\"\");\n            } else {\n                // otherwise just wait for more data to arrive\n            }\n        });\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return this._client.isOpen;\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    open(callback) {\n        this._client.open(callback);\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        this._client.close(callback);\n        this.removeAllListeners();\n    }\n\n    /**\n     * Send data to a modbus slave.\n     *\n     * @param data\n     */\n    write(data) {\n        if(data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n            return;\n        }\n\n        let length = null;\n\n        // remember current unit and command\n        this._id = data[0];\n        this._cmd = data[1];\n\n        // calculate expected answer length (this is checked after ascii decoding)\n        switch (this._cmd) {\n            case 1:\n            case 2:\n                length = data.readUInt16BE(4);\n                this._length = 3 + parseInt((length - 1) / 8 + 1) + 2;\n                break;\n            case 3:\n            case 4:\n                length = data.readUInt16BE(4);\n                this._length = 3 + 2 * length + 2;\n                break;\n            case 5:\n            case 6:\n            case 15:\n            case 16:\n                this._length = 6 + 2;\n                break;\n            default:\n                // raise and error ?\n                modbusSerialDebug({ action: \"unknown command\", id: this._id.toString(16), command: this._cmd.toString(16) });\n                this._length = 0;\n                break;\n        }\n\n        // ascii encode buffer\n        const _encodedData = _asciiEncodeRequestBuffer(data);\n\n        // send buffer to slave\n        this._client.write(_encodedData);\n\n        modbusSerialDebug({\n            action: \"send serial ascii port\",\n            data: _encodedData,\n            unitid: this._id,\n            functionCode: this._cmd\n        });\n\n        modbusSerialDebug(JSON.stringify({\n            action: \"send serial ascii port\",\n            data: _encodedData,\n            unitid: this._id,\n            functionCode: this._cmd\n        }));\n    }\n}\n\n/**\n * ASCII port for Modbus.\n *\n * @type {AsciiPort}\n */\nmodule.exports = AsciiPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}