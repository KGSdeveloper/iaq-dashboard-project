{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\"use strict\";\n\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"../utils/buffer_bit\")();\nconst crc16 = require(\"../utils/crc16\");\nconst MIN_DATA_LENGTH = 7;\nclass TestPort extends EventEmitter {\n  /**\n   * Simulate a serial port with 4 modbus-rtu slaves connected.\n   *\n   * 1 - a modbus slave working correctly\n   * 2 - a modbus slave that answer short replays\n   * 3 - a modbus slave that answer with bad crc\n   * 4 - a modbus slave that answer with bad unit number\n   * 5 - a modbus slave that answer with an exception\n   * 6 - a modbus slave that times out (does not answer)\n   */\n  constructor() {\n    super();\n\n    // simulate 11 input registers\n    this._registers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    // simulate 11 holding registers\n    this._holding_registers = [0, 0, 0, 0, 0, 0, 0, 0, 0xa12b, 0xffff, 0xb21a];\n\n    // simulate 16 coils / digital inputs\n    this._coils = 0x0000; // TODO 0xa12b, 1010 0001 0010 1011\n  }\n\n  /**\n   * Check if port is open.\n   *\n   * @returns {boolean}\n   */\n  get isOpen() {\n    return true;\n  }\n\n  /**\n   * Simulate successful port open.\n   *\n   * @param callback\n   */\n  open(callback) {\n    if (callback) callback(null);\n  }\n\n  /**\n   * Simulate successful close port.\n   *\n   * @param callback\n   */\n  close(callback) {\n    if (callback) callback(null);\n  }\n\n  /**\n   * Simulate successful/failure port requests and replays.\n   *\n   * @param {Buffer} data\n   */\n  write(data) {\n    let buffer = null;\n    let length = null;\n    let address = null;\n    let value = null;\n    let state = null;\n    let i = null;\n    if (data.length < MIN_DATA_LENGTH) {\n      modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n      return;\n    }\n    const unitNumber = data[0];\n    const functionCode = data[1];\n    let crc = data[data.length - 2] + data[data.length - 1] * 0x100;\n    // if crc is bad, ignore message\n    if (crc !== crc16(data.slice(0, -2))) {\n      return;\n    }\n\n    // function code 1 and 2\n    if (functionCode === 1 || functionCode === 2) {\n      address = data.readUInt16BE(2);\n      length = data.readUInt16BE(4);\n\n      // if length is bad, ignore message\n      if (data.length !== 8) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(3 + parseInt((length - 1) / 8 + 1) + 2);\n      buffer.writeUInt8(parseInt((length - 1) / 8 + 1), 2);\n\n      // read coils\n      buffer.writeUInt16LE(this._coils >> address, 3);\n    }\n\n    // function code 3\n    if (functionCode === 3) {\n      address = data.readUInt16BE(2);\n      length = data.readUInt16BE(4);\n\n      // if length is bad, ignore message\n      if (data.length !== 8) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(3 + length * 2 + 2);\n      buffer.writeUInt8(length * 2, 2);\n\n      // read registers\n      for (i = 0; i < length; i++) {\n        buffer.writeUInt16BE(this._holding_registers[address + i], 3 + i * 2);\n      }\n    }\n\n    // function code 4\n    if (functionCode === 4) {\n      address = data.readUInt16BE(2);\n      length = data.readUInt16BE(4);\n\n      // if length is bad, ignore message\n      if (data.length !== 8) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(3 + length * 2 + 2);\n      buffer.writeUInt8(length * 2, 2);\n\n      // read registers\n      for (i = 0; i < length; i++) {\n        buffer.writeUInt16BE(this._registers[address + i], 3 + i * 2);\n      }\n    }\n\n    // function code 5\n    if (functionCode === 5) {\n      address = data.readUInt16BE(2);\n      state = data.readUInt16BE(4);\n\n      // if length is bad, ignore message\n      if (data.length !== 8) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(8);\n      buffer.writeUInt16BE(address, 2);\n      buffer.writeUInt16BE(state, 4);\n\n      // write coil\n      if (state === 0xff00) {\n        this._coils |= 1 << address;\n      } else {\n        this._coils &= ~(1 << address);\n      }\n    }\n\n    // function code 6\n    if (functionCode === 6) {\n      address = data.readUInt16BE(2);\n      value = data.readUInt16BE(4);\n      // if length is bad, ignore message\n      if (data.length !== 6 + 2) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(8);\n      buffer.writeUInt16BE(address, 2);\n      buffer.writeUInt16BE(value, 4);\n      this._holding_registers[address] = value;\n    }\n\n    // function code 15\n    if (functionCode === 15) {\n      address = data.readUInt16BE(2);\n      length = data.readUInt16BE(4);\n\n      // if length is bad, ignore message\n      if (data.length !== 7 + Math.ceil(length / 8) + 2) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(8);\n      buffer.writeUInt16BE(address, 2);\n      buffer.writeUInt16BE(length, 4);\n\n      // write coils\n      for (i = 0; i < length; i++) {\n        state = data.readBit(i, 7);\n        if (state) {\n          this._coils |= 1 << address + i;\n        } else {\n          this._coils &= ~(1 << address + i);\n        }\n      }\n    }\n\n    // function code 16\n    if (functionCode === 16) {\n      address = data.readUInt16BE(2);\n      length = data.readUInt16BE(4);\n\n      // if length is bad, ignore message\n      if (data.length !== 7 + length * 2 + 2) {\n        return;\n      }\n\n      // build answer\n      buffer = Buffer.alloc(8);\n      buffer.writeUInt16BE(address, 2);\n      buffer.writeUInt16BE(length, 4);\n\n      // write registers\n      for (i = 0; i < length; i++) {\n        this._holding_registers[address + i] = data.readUInt16BE(7 + i * 2);\n      }\n    }\n    if (functionCode === 22) {\n      address = data.readUInt16BE(2);\n      const andMask = data.readUInt16BE(4);\n      const orMask = data.readUInt16BE(6);\n      if (data.length !== 10) {\n        return;\n      }\n      const oldValue = this._holding_registers[address] || 0;\n      this._holding_registers[address] = oldValue & andMask | orMask & ~andMask;\n      buffer = Buffer.alloc(10);\n      buffer.writeUInt16BE(address, 2);\n      buffer.writeUInt16BE(andMask, 4);\n      buffer.writeUInt16BE(orMask, 6);\n    }\n    if (functionCode === 43) {\n      const productCode = \"MyProductCode1234\";\n      buffer = Buffer.alloc(12 + productCode.length);\n      buffer.writeUInt8(16, 2); // MEI Type\n      buffer.writeUInt8(data.readInt8(3), 3); // read device ID code\n      buffer.writeUInt8(0x01, 4); // conformity level\n      buffer.writeUInt8(0, 5); // number of follows left\n      buffer.writeUInt8(0, 6); // next object ID\n      buffer.writeUInt8(1, 7); // number of objects\n      buffer.writeUInt8(data.readInt8(4), 8);\n      buffer.writeUInt8(productCode.length, 9);\n      buffer.write(productCode, 10, productCode.length, \"ascii\");\n    }\n\n    // send data back\n    if (buffer) {\n      // add unit number and function code\n      buffer.writeUInt8(unitNumber, 0);\n      buffer.writeUInt8(functionCode, 1);\n\n      // corrupt the answer\n      switch (unitNumber) {\n        case 1:\n          // unit 1: answers correctly\n          break;\n        case 2:\n          // unit 2: answers short data\n          buffer = buffer.slice(0, buffer.length - 5);\n          break;\n        case 4:\n          // unit 4: answers with bad unit number\n          buffer[0] = unitNumber + 2;\n          break;\n        case 5:\n          // unit 5: answers with exception\n          buffer.writeUInt8(functionCode + 128, 1);\n          buffer.writeUInt8(4, 2);\n          buffer = buffer.slice(0, 5);\n          break;\n        case 6:\n          // unit 6: does not answer\n          return;\n      }\n\n      // add crc\n      crc = crc16(buffer.slice(0, -2));\n      buffer.writeUInt16LE(crc, buffer.length - 2);\n\n      // unit 3: answers with bad crc\n      if (unitNumber === 3) {\n        buffer.writeUInt16LE(crc + 1, buffer.length - 2);\n      }\n      this.emit(\"data\", buffer);\n      modbusSerialDebug({\n        action: \"send test port\",\n        data: data,\n        buffer: buffer,\n        unitid: unitNumber,\n        functionCode: functionCode\n      });\n      modbusSerialDebug(JSON.stringify({\n        action: \"send test port strings\",\n        data: data,\n        buffer: buffer,\n        unitid: unitNumber,\n        functionCode: functionCode\n      }));\n    }\n  }\n}\n\n/**\n * Test port for Modbus.\n *\n * @type {TestPort}\n */\nmodule.exports = TestPort;","map":{"version":3,"names":["events","require","EventEmitter","modbusSerialDebug","crc16","MIN_DATA_LENGTH","TestPort","constructor","_registers","_holding_registers","_coils","isOpen","open","callback","close","write","data","buffer","length","address","value","state","i","unitNumber","functionCode","crc","slice","readUInt16BE","Buffer","alloc","parseInt","writeUInt8","writeUInt16LE","writeUInt16BE","Math","ceil","readBit","andMask","orMask","oldValue","productCode","readInt8","emit","action","unitid","JSON","stringify","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/ports/testport.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n\"use strict\";\nconst events = require(\"events\");\nconst EventEmitter = events.EventEmitter || events;\nconst modbusSerialDebug = require(\"debug\")(\"modbus-serial\");\n\n/* Add bit operation functions to Buffer\n */\nrequire(\"../utils/buffer_bit\")();\nconst crc16 = require(\"../utils/crc16\");\n\nconst MIN_DATA_LENGTH = 7;\n\nclass TestPort extends EventEmitter {\n    /**\n     * Simulate a serial port with 4 modbus-rtu slaves connected.\n     *\n     * 1 - a modbus slave working correctly\n     * 2 - a modbus slave that answer short replays\n     * 3 - a modbus slave that answer with bad crc\n     * 4 - a modbus slave that answer with bad unit number\n     * 5 - a modbus slave that answer with an exception\n     * 6 - a modbus slave that times out (does not answer)\n     */\n    constructor() {\n        super();\n\n        // simulate 11 input registers\n        this._registers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        // simulate 11 holding registers\n        this._holding_registers = [0, 0, 0, 0, 0, 0, 0, 0, 0xa12b, 0xffff, 0xb21a];\n\n        // simulate 16 coils / digital inputs\n        this._coils = 0x0000; // TODO 0xa12b, 1010 0001 0010 1011\n    }\n\n    /**\n     * Check if port is open.\n     *\n     * @returns {boolean}\n     */\n    get isOpen() {\n        return true;\n    }\n\n    /**\n     * Simulate successful port open.\n     *\n     * @param callback\n     */\n    open(callback) {\n        if (callback)\n            callback(null);\n    }\n\n    /**\n     * Simulate successful close port.\n     *\n     * @param callback\n     */\n    close(callback) {\n        if (callback)\n            callback(null);\n    }\n\n    /**\n     * Simulate successful/failure port requests and replays.\n     *\n     * @param {Buffer} data\n     */\n    write(data) {\n        let buffer = null;\n        let length = null;\n        let address = null;\n        let value = null;\n        let state = null;\n        let i = null;\n\n        if(data.length < MIN_DATA_LENGTH) {\n            modbusSerialDebug(\"expected length of data is to small - minimum is \" + MIN_DATA_LENGTH);\n            return;\n        }\n\n        const unitNumber = data[0];\n        const functionCode = data[1];\n        let crc = data[data.length - 2] + data[data.length - 1] * 0x100;\n        // if crc is bad, ignore message\n        if (crc !== crc16(data.slice(0, -2))) {\n            return;\n        }\n\n        // function code 1 and 2\n        if (functionCode === 1 || functionCode === 2) {\n            address = data.readUInt16BE(2);\n            length = data.readUInt16BE(4);\n\n            // if length is bad, ignore message\n            if (data.length !== 8) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(3 + parseInt((length - 1) / 8 + 1) + 2);\n            buffer.writeUInt8(parseInt((length - 1) / 8 + 1), 2);\n\n            // read coils\n            buffer.writeUInt16LE(this._coils >> address, 3);\n        }\n\n        // function code 3\n        if (functionCode === 3) {\n            address = data.readUInt16BE(2);\n            length = data.readUInt16BE(4);\n\n            // if length is bad, ignore message\n            if (data.length !== 8) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(3 + length * 2 + 2);\n            buffer.writeUInt8(length * 2, 2);\n\n            // read registers\n            for (i = 0; i < length; i++) {\n                buffer.writeUInt16BE(this._holding_registers[address + i], 3 + i * 2);\n            }\n        }\n\n        // function code 4\n        if (functionCode === 4) {\n            address = data.readUInt16BE(2);\n            length = data.readUInt16BE(4);\n\n            // if length is bad, ignore message\n            if (data.length !== 8) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(3 + length * 2 + 2);\n            buffer.writeUInt8(length * 2, 2);\n\n            // read registers\n            for (i = 0; i < length; i++) {\n                buffer.writeUInt16BE(this._registers[address + i], 3 + i * 2);\n            }\n        }\n\n        // function code 5\n        if (functionCode === 5) {\n            address = data.readUInt16BE(2);\n            state = data.readUInt16BE(4);\n\n            // if length is bad, ignore message\n            if (data.length !== 8) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(8);\n            buffer.writeUInt16BE(address, 2);\n            buffer.writeUInt16BE(state, 4);\n\n            // write coil\n            if (state === 0xff00) {\n                this._coils |= (1 << address);\n            } else {\n                this._coils &= ~(1 << address);\n            }\n        }\n\n        // function code 6\n        if (functionCode === 6) {\n            address = data.readUInt16BE(2);\n            value = data.readUInt16BE(4);\n            // if length is bad, ignore message\n            if (data.length !== (6 + 2)) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(8);\n            buffer.writeUInt16BE(address, 2);\n            buffer.writeUInt16BE(value, 4);\n\n            this._holding_registers[address] = value;\n        }\n\n        // function code 15\n        if (functionCode === 15) {\n            address = data.readUInt16BE(2);\n            length = data.readUInt16BE(4);\n\n            // if length is bad, ignore message\n            if (data.length !== 7 + Math.ceil(length / 8) + 2) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(8);\n            buffer.writeUInt16BE(address, 2);\n            buffer.writeUInt16BE(length, 4);\n\n            // write coils\n            for (i = 0; i < length; i++) {\n                state = data.readBit(i, 7);\n\n                if (state) {\n                    this._coils |= (1 << (address + i));\n                } else {\n                    this._coils &= ~(1 << (address + i));\n                }\n            }\n        }\n\n        // function code 16\n        if (functionCode === 16) {\n            address = data.readUInt16BE(2);\n            length = data.readUInt16BE(4);\n\n            // if length is bad, ignore message\n            if (data.length !== (7 + length * 2 + 2)) {\n                return;\n            }\n\n            // build answer\n            buffer = Buffer.alloc(8);\n            buffer.writeUInt16BE(address, 2);\n            buffer.writeUInt16BE(length, 4);\n\n            // write registers\n            for (i = 0; i < length; i++) {\n                this._holding_registers[address + i] = data.readUInt16BE(7 + i * 2);\n            }\n        }\n\n        if (functionCode === 22) {\n            address = data.readUInt16BE(2);\n            const andMask = data.readUInt16BE(4);\n            const orMask = data.readUInt16BE(6);\n\n            if (data.length !== 10) {\n                return;\n            }\n\n            const oldValue = this._holding_registers[address] || 0;\n            this._holding_registers[address] = (oldValue & andMask) | (orMask & ~andMask);\n\n            buffer = Buffer.alloc(10);\n            buffer.writeUInt16BE(address, 2);\n            buffer.writeUInt16BE(andMask, 4);\n            buffer.writeUInt16BE(orMask, 6);\n        }\n\n        if (functionCode === 43) {\n            const productCode = \"MyProductCode1234\";\n            buffer = Buffer.alloc(12 + productCode.length);\n            buffer.writeUInt8(16, 2); // MEI Type\n            buffer.writeUInt8(data.readInt8(3), 3); // read device ID code\n            buffer.writeUInt8(0x01, 4); // conformity level\n            buffer.writeUInt8(0, 5); // number of follows left\n            buffer.writeUInt8(0, 6); // next object ID\n            buffer.writeUInt8(1, 7); // number of objects\n            buffer.writeUInt8(data.readInt8(4), 8);\n            buffer.writeUInt8(productCode.length, 9);\n            buffer.write(productCode, 10, productCode.length, \"ascii\");\n        }\n\n        // send data back\n        if (buffer) {\n            // add unit number and function code\n            buffer.writeUInt8(unitNumber, 0);\n            buffer.writeUInt8(functionCode, 1);\n\n            // corrupt the answer\n            switch (unitNumber) {\n                case 1:\n                    // unit 1: answers correctly\n                    break;\n                case 2:\n                    // unit 2: answers short data\n                    buffer = buffer.slice(0, buffer.length - 5);\n                    break;\n                case 4:\n                    // unit 4: answers with bad unit number\n                    buffer[0] = unitNumber + 2;\n                    break;\n                case 5:\n                    // unit 5: answers with exception\n                    buffer.writeUInt8(functionCode + 128, 1);\n                    buffer.writeUInt8(4, 2);\n                    buffer = buffer.slice(0, 5);\n                    break;\n                case 6:\n                    // unit 6: does not answer\n                    return;\n            }\n\n            // add crc\n            crc = crc16(buffer.slice(0, -2));\n            buffer.writeUInt16LE(crc, buffer.length - 2);\n\n            // unit 3: answers with bad crc\n            if (unitNumber === 3) {\n                buffer.writeUInt16LE(crc + 1, buffer.length - 2);\n            }\n\n            this.emit(\"data\", buffer);\n\n            modbusSerialDebug({\n                action: \"send test port\",\n                data: data,\n                buffer: buffer,\n                unitid: unitNumber,\n                functionCode: functionCode\n            });\n\n            modbusSerialDebug(JSON.stringify({\n                action: \"send test port strings\",\n                data: data,\n                buffer: buffer,\n                unitid: unitNumber,\n                functionCode: functionCode\n            }));\n        }\n    }\n}\n\n/**\n * Test port for Modbus.\n *\n * @type {TestPort}\n */\nmodule.exports = TestPort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}