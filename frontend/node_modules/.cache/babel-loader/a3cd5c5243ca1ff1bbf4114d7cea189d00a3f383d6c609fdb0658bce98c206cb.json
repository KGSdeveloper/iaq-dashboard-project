{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2015, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\n/**\n * Take a modbus serial function and convert it to use promises.\n *\n * @param {Function} f the function to convert\n * @return a function that calls function \"f\" and return a promise.\n * @private\n */\nconst _convert = function (f) {\n  const converted = function (...args) {\n    const client = this;\n    const id = this._unitID;\n\n    // The last argument might be the callback (next)\n    const next = args[args.length - 1];\n\n    // Determine if the last argument is actually a callback\n    const hasCallback = typeof next === \"function\";\n    if (hasCallback) {\n      // If there is a callback, call the function with the appropriate arguments\n      if (args.length === 1) {\n        // This case is used for client close method\n        f.bind(client)(next);\n      } else {\n        // This case is used for client writeFC methods\n        f.bind(client)(id, ...args);\n      }\n    } else {\n      // Otherwise, use a promise\n      return new Promise(function (resolve, reject) {\n        function cb(err, data) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        }\n        if (args.length === 0) {\n          // This case is used for client close method\n          f.bind(client)(cb);\n        } else {\n          // This case is used for client writeFC methods\n          f.bind(client)(id, ...args, cb);\n        }\n      });\n    }\n  };\n  return converted;\n};\n\n/**\n * Adds promise API to a Modbus object.\n *\n * @param {ModbusRTU} Modbus the ModbusRTU object.\n */\nconst addPromiseAPI = function (Modbus) {\n  const cl = Modbus.prototype;\n\n  // set/get unitID\n  cl.setID = function (id) {\n    this._unitID = Number(id);\n  };\n  cl.getID = function () {\n    return this._unitID;\n  };\n\n  // set/get timeout\n  cl.setTimeout = function (timeout) {\n    this._timeout = timeout;\n  };\n  cl.getTimeout = function () {\n    return this._timeout;\n  };\n\n  // convert functions to return promises\n  cl.close = _convert(cl.close);\n  cl.readCoils = _convert(cl.writeFC1);\n  cl.readDiscreteInputs = _convert(cl.writeFC2);\n  cl.readHoldingRegisters = _convert(cl.writeFC3);\n  cl.readRegistersEnron = _convert(cl.writeFC3);\n  cl.readInputRegisters = _convert(cl.writeFC4);\n  cl.writeCoil = _convert(cl.writeFC5);\n  cl.writeRegister = _convert(cl.writeFC6);\n  cl.writeRegisterEnron = _convert(cl.writeFC6);\n  cl.writeCoils = _convert(cl.writeFC15);\n  cl.writeRegisters = _convert(cl.writeFC16);\n  cl.reportServerID = _convert(cl.writeFC17);\n  cl.readFileRecords = _convert(cl.writeFC20);\n  cl.maskWriteRegister = _convert(cl.writeFC22);\n  cl.readDeviceIdentification = _convert(cl.writeFC43);\n};\n\n/**\n * Promise API Modbus library.\n *\n * @type {addPromiseAPI}\n */\nmodule.exports = addPromiseAPI;","map":{"version":3,"names":["_convert","f","converted","args","client","id","_unitID","next","length","hasCallback","bind","Promise","resolve","reject","cb","err","data","addPromiseAPI","Modbus","cl","prototype","setID","Number","getID","setTimeout","timeout","_timeout","getTimeout","close","readCoils","writeFC1","readDiscreteInputs","writeFC2","readHoldingRegisters","writeFC3","readRegistersEnron","readInputRegisters","writeFC4","writeCoil","writeFC5","writeRegister","writeFC6","writeRegisterEnron","writeCoils","writeFC15","writeRegisters","writeFC16","reportServerID","writeFC17","readFileRecords","writeFC20","maskWriteRegister","writeFC22","readDeviceIdentification","writeFC43","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/apis/promise.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2015, Yaacov Zamir <kobi.zamir@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF  THIS SOFTWARE.\n */\n\n/**\n * Take a modbus serial function and convert it to use promises.\n *\n * @param {Function} f the function to convert\n * @return a function that calls function \"f\" and return a promise.\n * @private\n */\nconst _convert = function(f) {\n    const converted = function(...args) {\n        const client = this;\n        const id = this._unitID;\n\n        // The last argument might be the callback (next)\n        const next = args[args.length - 1];\n\n        // Determine if the last argument is actually a callback\n        const hasCallback = typeof next === \"function\";\n\n        if (hasCallback) {\n            // If there is a callback, call the function with the appropriate arguments\n            if (args.length === 1) {\n                // This case is used for client close method\n                f.bind(client)(next);\n            } else {\n                // This case is used for client writeFC methods\n                f.bind(client)(id, ...args);\n            }\n        } else {\n            // Otherwise, use a promise\n            return new Promise(function(resolve, reject) {\n                function cb(err, data) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(data);\n                    }\n                }\n\n                if (args.length === 0) {\n                // This case is used for client close method\n                    f.bind(client)(cb);\n                } else {\n                // This case is used for client writeFC methods\n                    f.bind(client)(id, ...args, cb);\n                }\n            });\n        }\n    };\n\n    return converted;\n};\n\n/**\n * Adds promise API to a Modbus object.\n *\n * @param {ModbusRTU} Modbus the ModbusRTU object.\n */\nconst addPromiseAPI = function(Modbus) {\n\n    const cl = Modbus.prototype;\n\n    // set/get unitID\n    cl.setID = function(id) {this._unitID = Number(id);};\n    cl.getID = function() {return this._unitID;};\n\n    // set/get timeout\n    cl.setTimeout = function(timeout) {this._timeout = timeout;};\n    cl.getTimeout = function() {return this._timeout;};\n\n    // convert functions to return promises\n    cl.close = _convert(cl.close);\n    cl.readCoils = _convert(cl.writeFC1);\n    cl.readDiscreteInputs = _convert(cl.writeFC2);\n    cl.readHoldingRegisters = _convert(cl.writeFC3);\n    cl.readRegistersEnron = _convert(cl.writeFC3);\n    cl.readInputRegisters = _convert(cl.writeFC4);\n    cl.writeCoil = _convert(cl.writeFC5);\n    cl.writeRegister = _convert(cl.writeFC6);\n    cl.writeRegisterEnron = _convert(cl.writeFC6);\n    cl.writeCoils = _convert(cl.writeFC15);\n    cl.writeRegisters = _convert(cl.writeFC16);\n    cl.reportServerID = _convert(cl.writeFC17);\n    cl.readFileRecords = _convert(cl.writeFC20);\n    cl.maskWriteRegister = _convert(cl.writeFC22);\n    cl.readDeviceIdentification = _convert(cl.writeFC43);\n};\n\n/**\n * Promise API Modbus library.\n *\n * @type {addPromiseAPI}\n */\nmodule.exports = addPromiseAPI;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,QAAQ,GAAG,SAAAA,CAASC,CAAC,EAAE;EACzB,MAAMC,SAAS,GAAG,SAAAA,CAAS,GAAGC,IAAI,EAAE;IAChC,MAAMC,MAAM,GAAG,IAAI;IACnB,MAAMC,EAAE,GAAG,IAAI,CAACC,OAAO;;IAEvB;IACA,MAAMC,IAAI,GAAGJ,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC;;IAElC;IACA,MAAMC,WAAW,GAAG,OAAOF,IAAI,KAAK,UAAU;IAE9C,IAAIE,WAAW,EAAE;MACb;MACA,IAAIN,IAAI,CAACK,MAAM,KAAK,CAAC,EAAE;QACnB;QACAP,CAAC,CAACS,IAAI,CAACN,MAAM,CAAC,CAACG,IAAI,CAAC;MACxB,CAAC,MAAM;QACH;QACAN,CAAC,CAACS,IAAI,CAACN,MAAM,CAAC,CAACC,EAAE,EAAE,GAAGF,IAAI,CAAC;MAC/B;IACJ,CAAC,MAAM;MACH;MACA,OAAO,IAAIQ,OAAO,CAAC,UAASC,OAAO,EAAEC,MAAM,EAAE;QACzC,SAASC,EAAEA,CAACC,GAAG,EAAEC,IAAI,EAAE;UACnB,IAAID,GAAG,EAAE;YACLF,MAAM,CAACE,GAAG,CAAC;UACf,CAAC,MAAM;YACHH,OAAO,CAACI,IAAI,CAAC;UACjB;QACJ;QAEA,IAAIb,IAAI,CAACK,MAAM,KAAK,CAAC,EAAE;UACvB;UACIP,CAAC,CAACS,IAAI,CAACN,MAAM,CAAC,CAACU,EAAE,CAAC;QACtB,CAAC,MAAM;UACP;UACIb,CAAC,CAACS,IAAI,CAACN,MAAM,CAAC,CAACC,EAAE,EAAE,GAAGF,IAAI,EAAEW,EAAE,CAAC;QACnC;MACJ,CAAC,CAAC;IACN;EACJ,CAAC;EAED,OAAOZ,SAAS;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMe,aAAa,GAAG,SAAAA,CAASC,MAAM,EAAE;EAEnC,MAAMC,EAAE,GAAGD,MAAM,CAACE,SAAS;;EAE3B;EACAD,EAAE,CAACE,KAAK,GAAG,UAAShB,EAAE,EAAE;IAAC,IAAI,CAACC,OAAO,GAAGgB,MAAM,CAACjB,EAAE,CAAC;EAAC,CAAC;EACpDc,EAAE,CAACI,KAAK,GAAG,YAAW;IAAC,OAAO,IAAI,CAACjB,OAAO;EAAC,CAAC;;EAE5C;EACAa,EAAE,CAACK,UAAU,GAAG,UAASC,OAAO,EAAE;IAAC,IAAI,CAACC,QAAQ,GAAGD,OAAO;EAAC,CAAC;EAC5DN,EAAE,CAACQ,UAAU,GAAG,YAAW;IAAC,OAAO,IAAI,CAACD,QAAQ;EAAC,CAAC;;EAElD;EACAP,EAAE,CAACS,KAAK,GAAG5B,QAAQ,CAACmB,EAAE,CAACS,KAAK,CAAC;EAC7BT,EAAE,CAACU,SAAS,GAAG7B,QAAQ,CAACmB,EAAE,CAACW,QAAQ,CAAC;EACpCX,EAAE,CAACY,kBAAkB,GAAG/B,QAAQ,CAACmB,EAAE,CAACa,QAAQ,CAAC;EAC7Cb,EAAE,CAACc,oBAAoB,GAAGjC,QAAQ,CAACmB,EAAE,CAACe,QAAQ,CAAC;EAC/Cf,EAAE,CAACgB,kBAAkB,GAAGnC,QAAQ,CAACmB,EAAE,CAACe,QAAQ,CAAC;EAC7Cf,EAAE,CAACiB,kBAAkB,GAAGpC,QAAQ,CAACmB,EAAE,CAACkB,QAAQ,CAAC;EAC7ClB,EAAE,CAACmB,SAAS,GAAGtC,QAAQ,CAACmB,EAAE,CAACoB,QAAQ,CAAC;EACpCpB,EAAE,CAACqB,aAAa,GAAGxC,QAAQ,CAACmB,EAAE,CAACsB,QAAQ,CAAC;EACxCtB,EAAE,CAACuB,kBAAkB,GAAG1C,QAAQ,CAACmB,EAAE,CAACsB,QAAQ,CAAC;EAC7CtB,EAAE,CAACwB,UAAU,GAAG3C,QAAQ,CAACmB,EAAE,CAACyB,SAAS,CAAC;EACtCzB,EAAE,CAAC0B,cAAc,GAAG7C,QAAQ,CAACmB,EAAE,CAAC2B,SAAS,CAAC;EAC1C3B,EAAE,CAAC4B,cAAc,GAAG/C,QAAQ,CAACmB,EAAE,CAAC6B,SAAS,CAAC;EAC1C7B,EAAE,CAAC8B,eAAe,GAAGjD,QAAQ,CAACmB,EAAE,CAAC+B,SAAS,CAAC;EAC3C/B,EAAE,CAACgC,iBAAiB,GAAGnD,QAAQ,CAACmB,EAAE,CAACiC,SAAS,CAAC;EAC7CjC,EAAE,CAACkC,wBAAwB,GAAGrD,QAAQ,CAACmB,EAAE,CAACmC,SAAS,CAAC;AACxD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAGvC,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}