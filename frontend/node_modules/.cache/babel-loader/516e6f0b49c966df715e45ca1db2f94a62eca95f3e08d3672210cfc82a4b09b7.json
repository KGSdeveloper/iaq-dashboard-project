{"ast":null,"code":"const stream = require(\"stream\");\nclass ServerSerialPipeHandler extends stream.Transform {\n  constructor({\n    maxBufferSize = 65536,\n    interval,\n    transformOptions\n  }) {\n    super(transformOptions);\n    if (!interval) {\n      throw new TypeError(\"\\\"interval\\\" is required\");\n    }\n    if (typeof interval !== \"number\" || Number.isNaN(interval)) {\n      throw new TypeError(\"\\\"interval\\\" is not a number\");\n    }\n    if (interval < 1) {\n      throw new TypeError(\"\\\"interval\\\" is not greater than 0\");\n    }\n    if (typeof maxBufferSize !== \"number\" || Number.isNaN(maxBufferSize)) {\n      throw new TypeError(\"\\\"maxBufferSize\\\" is not a number\");\n    }\n    if (maxBufferSize < 1) {\n      throw new TypeError(\"\\\"maxBufferSize\\\" is not greater than 0\");\n    }\n    this.maxBufferSize = maxBufferSize;\n    this.currentPacket = Buffer.from([]);\n    this.interval = interval;\n  }\n  _transform(chunk, encoding, cb) {\n    if (this.intervalID) {\n      clearTimeout(this.intervalID);\n    }\n    let offset = 0;\n    while (this.currentPacket.length + chunk.length >= this.maxBufferSize) {\n      this.currentPacket = Buffer.concat([this.currentPacket, chunk.slice(offset, this.maxBufferSize - this.currentPacket.length)]);\n      offset = offset + this.maxBufferSize;\n      chunk = chunk.slice(offset);\n      this.emitPacket();\n    }\n    this.currentPacket = Buffer.concat([this.currentPacket, chunk]);\n    this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);\n    cb();\n  }\n  emitPacket() {\n    if (this.intervalID) {\n      clearTimeout(this.intervalID);\n    }\n    if (this.currentPacket.length > 0) {\n      this.push(this.currentPacket);\n    }\n    this.currentPacket = Buffer.from([]);\n  }\n  _flush(cb) {\n    this.emitPacket();\n    cb();\n  }\n}\nmodule.exports = ServerSerialPipeHandler;","map":{"version":3,"names":["stream","require","ServerSerialPipeHandler","Transform","constructor","maxBufferSize","interval","transformOptions","TypeError","Number","isNaN","currentPacket","Buffer","from","_transform","chunk","encoding","cb","intervalID","clearTimeout","offset","length","concat","slice","emitPacket","setTimeout","bind","push","_flush","module","exports"],"sources":["D:/code projects/iaq-dashboard/node_modules/modbus-serial/servers/serverserial_pipe_handler.js"],"sourcesContent":["const stream = require(\"stream\");\n\nclass ServerSerialPipeHandler extends stream.Transform {\n    constructor({ maxBufferSize = 65536, interval, transformOptions }) {\n        super(transformOptions);\n        if (!interval) {\n            throw new TypeError(\"\\\"interval\\\" is required\");\n        }\n        if (typeof interval !== \"number\" || Number.isNaN(interval)) {\n            throw new TypeError(\"\\\"interval\\\" is not a number\");\n        }\n        if (interval < 1) {\n            throw new TypeError(\"\\\"interval\\\" is not greater than 0\");\n        }\n        if (typeof maxBufferSize !== \"number\" || Number.isNaN(maxBufferSize)) {\n            throw new TypeError(\"\\\"maxBufferSize\\\" is not a number\");\n        }\n        if (maxBufferSize < 1) {\n            throw new TypeError(\"\\\"maxBufferSize\\\" is not greater than 0\");\n        }\n        this.maxBufferSize = maxBufferSize;\n        this.currentPacket = Buffer.from([]);\n        this.interval = interval;\n    }\n\n    _transform(chunk, encoding, cb) {\n        if (this.intervalID) {\n            clearTimeout(this.intervalID);\n        }\n\n        let offset = 0;\n        while ((this.currentPacket.length + chunk.length) >= this.maxBufferSize) {\n            this.currentPacket = Buffer.concat([this.currentPacket, chunk.slice(offset, this.maxBufferSize - this.currentPacket.length)]);\n            offset = offset + this.maxBufferSize;\n            chunk = chunk.slice(offset);\n            this.emitPacket();\n        }\n        this.currentPacket = Buffer.concat([this.currentPacket, chunk]);\n        this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);\n        cb();\n    }\n    emitPacket() {\n        if (this.intervalID) {\n            clearTimeout(this.intervalID);\n        }\n        if (this.currentPacket.length > 0) {\n            this.push(this.currentPacket);\n        }\n        this.currentPacket = Buffer.from([]);\n    }\n    _flush(cb) {\n        this.emitPacket();\n        cb();\n    }\n}\n\nmodule.exports = ServerSerialPipeHandler;\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAEhC,MAAMC,uBAAuB,SAASF,MAAM,CAACG,SAAS,CAAC;EACnDC,WAAWA,CAAC;IAAEC,aAAa,GAAG,KAAK;IAAEC,QAAQ;IAAEC;EAAiB,CAAC,EAAE;IAC/D,KAAK,CAACA,gBAAgB,CAAC;IACvB,IAAI,CAACD,QAAQ,EAAE;MACX,MAAM,IAAIE,SAAS,CAAC,0BAA0B,CAAC;IACnD;IACA,IAAI,OAAOF,QAAQ,KAAK,QAAQ,IAAIG,MAAM,CAACC,KAAK,CAACJ,QAAQ,CAAC,EAAE;MACxD,MAAM,IAAIE,SAAS,CAAC,8BAA8B,CAAC;IACvD;IACA,IAAIF,QAAQ,GAAG,CAAC,EAAE;MACd,MAAM,IAAIE,SAAS,CAAC,oCAAoC,CAAC;IAC7D;IACA,IAAI,OAAOH,aAAa,KAAK,QAAQ,IAAII,MAAM,CAACC,KAAK,CAACL,aAAa,CAAC,EAAE;MAClE,MAAM,IAAIG,SAAS,CAAC,mCAAmC,CAAC;IAC5D;IACA,IAAIH,aAAa,GAAG,CAAC,EAAE;MACnB,MAAM,IAAIG,SAAS,CAAC,yCAAyC,CAAC;IAClE;IACA,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACM,aAAa,GAAGC,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;IACpC,IAAI,CAACP,QAAQ,GAAGA,QAAQ;EAC5B;EAEAQ,UAAUA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC5B,IAAI,IAAI,CAACC,UAAU,EAAE;MACjBC,YAAY,CAAC,IAAI,CAACD,UAAU,CAAC;IACjC;IAEA,IAAIE,MAAM,GAAG,CAAC;IACd,OAAQ,IAAI,CAACT,aAAa,CAACU,MAAM,GAAGN,KAAK,CAACM,MAAM,IAAK,IAAI,CAAChB,aAAa,EAAE;MACrE,IAAI,CAACM,aAAa,GAAGC,MAAM,CAACU,MAAM,CAAC,CAAC,IAAI,CAACX,aAAa,EAAEI,KAAK,CAACQ,KAAK,CAACH,MAAM,EAAE,IAAI,CAACf,aAAa,GAAG,IAAI,CAACM,aAAa,CAACU,MAAM,CAAC,CAAC,CAAC;MAC7HD,MAAM,GAAGA,MAAM,GAAG,IAAI,CAACf,aAAa;MACpCU,KAAK,GAAGA,KAAK,CAACQ,KAAK,CAACH,MAAM,CAAC;MAC3B,IAAI,CAACI,UAAU,CAAC,CAAC;IACrB;IACA,IAAI,CAACb,aAAa,GAAGC,MAAM,CAACU,MAAM,CAAC,CAAC,IAAI,CAACX,aAAa,EAAEI,KAAK,CAAC,CAAC;IAC/D,IAAI,CAACG,UAAU,GAAGO,UAAU,CAAC,IAAI,CAACD,UAAU,CAACE,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAACpB,QAAQ,CAAC;IACvEW,EAAE,CAAC,CAAC;EACR;EACAO,UAAUA,CAAA,EAAG;IACT,IAAI,IAAI,CAACN,UAAU,EAAE;MACjBC,YAAY,CAAC,IAAI,CAACD,UAAU,CAAC;IACjC;IACA,IAAI,IAAI,CAACP,aAAa,CAACU,MAAM,GAAG,CAAC,EAAE;MAC/B,IAAI,CAACM,IAAI,CAAC,IAAI,CAAChB,aAAa,CAAC;IACjC;IACA,IAAI,CAACA,aAAa,GAAGC,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;EACxC;EACAe,MAAMA,CAACX,EAAE,EAAE;IACP,IAAI,CAACO,UAAU,CAAC,CAAC;IACjBP,EAAE,CAAC,CAAC;EACR;AACJ;AAEAY,MAAM,CAACC,OAAO,GAAG5B,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}